<!DOCTYPE html><html class="appearance-light" lang="en"><head><meta charset="UTF-8"><title>Python 到底是 Call by Value, Call by Reference, 還是 Call by Sharing？</title><meta name="description"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/widget-post-list.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="
常見的語言的求值策略(Evaluation strategy)大概離不開這幾個，例如：JavaScript (Call by Value, Call by Sharing)、Java (Call by Value)、C (Call by Value)、C++ (Call by Value, Call by Reference)
這次使用使用淺顯易懂的語言，並搭配圖片來說明到底 Python 中是 Pass by Value, Pass by Reference, 還是 Pass Sharing？
本篇目錄：  

用 C++ 理解 Pass by Value  
用 C++ 理解 Pass by Reference  
來看看 Python 是不是 Pass by Value  
來看看 Python 是.."><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Luka.tw</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Python 到底是 Call by Value, Call by Reference, 還是 Call by Sharing？</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><div class="post-container" style="position: sticky; top: 50px;"><main class="aside-card-container categories-widget category-page"><h3 style="font-size:1em;">Categories</h3><section><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/01-Python-%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8/">01 Python 基礎教學</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/02-Python-%E7%88%AC%E8%9F%B2%E6%95%99%E5%AD%B8/">02 Python 爬蟲教學</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/03-Python-Flask-%E6%95%99%E5%AD%B8/">03 Python Flask 教學</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/04-Python-Django-%E6%95%99%E5%AD%B8/">04 Python Django 教學</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/05-Python-%E8%B3%87%E6%96%99%E5%BA%AB%E6%95%99%E5%AD%B8/">05 Python 資料庫教學</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/06-Python-%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90/">06 Python 資料分析</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/07-Python-%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/">07 Python 機器學習</a><span class="category-list-count">1</span></li></ul></section></main><div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%94%A8-C-%E7%90%86%E8%A7%A3-Pass-by-Value"><span class="toc-text">1. 用 C++ 理解 Pass by Value</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pass-by-Value-Output"><span class="toc-text">Pass by Value (Output)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pass-by-Value-Address"><span class="toc-text">Pass by Value (Address)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%94%A8-C-%E7%90%86%E8%A7%A3-Pass-by-Reference"><span class="toc-text">2. 用 C++ 理解 Pass by Reference</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pass-by-Reference"><span class="toc-text">Pass by Reference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pass-by-Reference-Address"><span class="toc-text">Pass by Reference (Address)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BE%86%E7%9C%8B%E7%9C%8B-Python-%E6%98%AF%E4%B8%8D%E6%98%AF-Pass-by-Value"><span class="toc-text">3. 來看看 Python 是不是 Pass by Value</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BE%86%E7%9C%8B%E7%9C%8B-Python-%E6%98%AF%E4%B8%8D%E6%98%AFPass-By-Reference"><span class="toc-text">4. 來看看 Python 是不是Pass By Reference</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5%E5%AD%97%E5%85%B8-dict-%E7%9A%84%E8%A8%98%E6%86%B6%E9%AB%94%E8%AA%BF%E7%94%A8"><span class="toc-text">深入資料型別字典(dict) 的記憶體調用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BE%86%E7%9C%8B%E7%9C%8B-Python-%E6%98%AF%E4%B8%8D%E6%98%AF-Pass-by-Sharing"><span class="toc-text">5. 來看看 Python 是不是 Pass by Sharing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Python-%E5%88%B0%E5%BA%95%E6%98%AF-Pass-by-Value-Pass-Value-%E9%82%84%E6%98%AF-Pass-Sharing-%E5%91%A2%EF%BC%9F"><span class="toc-text">6. Python 到底是 Pass by Value, Pass Value 還是 Pass Sharing 呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%BD%E4%B8%8D%E6%98%AF%EF%BC%8CPython-%E6%98%AF-Pass-by-Assignment%EF%BC%81"><span class="toc-text">都不是，Python 是 Pass by Assignment！</span></a></li></ol></li></ol></div></div></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">Python 到底是 Call by Value, Call by Reference, 還是 Call by Sharing？</h1><time class="has-text-grey" datetime="2021-09-21T12:50:00.000Z">2021-09-21</time><article class="mt-2 post-content"><p><img src="https://miro.medium.com/max/1400/1*u7A0F0uSK_7dXz-cBbw7Wg.jpeg"></p>
<p>常見的語言的求值策略(Evaluation strategy)大概離不開這幾個，例如：JavaScript (Call by Value, Call by Sharing)、Java (Call by Value)、C (Call by Value)、C++ (Call by Value, Call by Reference)</p>
<p>這次使用使用淺顯易懂的語言，並搭配圖片來說明到底 Python 中是 Pass by Value, Pass by Reference, 還是 Pass Sharing？</p>
<p>本篇目錄：  </p>
<ol>
<li>用 C++ 理解 Pass by Value  </li>
<li>用 C++ 理解 Pass by Reference  </li>
<li>來看看 Python 是不是 Pass by Value  </li>
<li>來看看 Python 是不是 Pass by Reference  </li>
<li>來看看 Python 是不是 Pass By Sharing  </li>
<li>Python 到底是 Pass by Value, Pass Value 還是 Pass Sharing 呢？</li>
</ol>
<h2 id="1-用-C-理解-Pass-by-Value"><a href="#1-用-C-理解-Pass-by-Value" class="headerlink" title="1. 用 C++ 理解 Pass by Value"></a>1. 用 C++ 理解 Pass by Value</h2><p>C++ 是探討 Pass by Value 與 Pass by Reference 的最佳選擇。我們先來理解 Pass by Value。</p>
<h3 id="Pass-by-Value-Output"><a href="#Pass-by-Value-Output" class="headerlink" title="Pass by Value (Output)"></a>Pass by Value (Output)</h3><p><img src="https://miro.medium.com/max/1400/1*_Kv0cQp2ot5CaFq4F-eeeA.png"></p>
<p>執行結果</p>
<pre><code>Before: number is 7  
Before: the num is 7  
After: the num is 3  
After: number is 7
</code></pre>
<h3 id="Pass-by-Value-Address"><a href="#Pass-by-Value-Address" class="headerlink" title="Pass by Value (Address)"></a>Pass by Value (Address)</h3><p>可以看到函式內部的數並不會受到影響，遵守作用域( Scope)範圍。我們再執行另一個程式，查看記憶體位址的改變。</p>
<p><img src="https://miro.medium.com/max/1400/1*_tqEX2mp6P1mmhQXz3giYw.png"></p>
<p>執行結果:</p>
<pre><code>The Address of number is 0x7ffd0abe7b74  
The Address of num is 0x7ffd0abe7b5c  
The Address of num is 0x7ffd0abe7b5c  
The Address of number is 0x7ffd0abe7b74
</code></pre>
<p>可以發現 num 的位址遵守作用域 (Scope)，經過這兩個程式之後，可以理解到 Pass by Value 是在呼叫函式的時候，複製一份引數(number)給函式使用。</p>
<p>Step 1：宣告 number 為 7</p>
<p><img src="https://miro.medium.com/max/1400/1*COCGC0koxgEwwAcyjIxPqQ.jpeg"></p>
<p>Step 2：呼叫函式時，複製一份給 number 的值複製一份給 num。</p>
<p><img src="https://miro.medium.com/max/1400/1*effkI4tD0QRbyshr32eZTQ.jpeg"></p>
<p>step 3：修改 num 的值時，修改的是複製出來的那一份。因此原本的 number 不受影響。</p>
<p><img src="https://miro.medium.com/max/1400/1*DmDfGRZBfjNgsJOz0djjTg.jpeg"></p>
<h2 id="2-用-C-理解-Pass-by-Reference"><a href="#2-用-C-理解-Pass-by-Reference" class="headerlink" title="2. 用 C++ 理解 Pass by Reference"></a>2. 用 C++ 理解 Pass by Reference</h2><h3 id="Pass-by-Reference"><a href="#Pass-by-Reference" class="headerlink" title="Pass by Reference"></a>Pass by Reference</h3><p><img src="https://miro.medium.com/max/1400/1*iq5MtwlbxH2pauCvUn1IlA.png"></p>
<p>執行結果：</p>
<pre><code>Before: number is 7  
Before: the num is 7  
After: the num is 3  
After: number is 3
</code></pre>
<h3 id="Pass-by-Reference-Address"><a href="#Pass-by-Reference-Address" class="headerlink" title="Pass by Reference (Address)"></a>Pass by Reference (Address)</h3><p>跟剛剛不同的是，因為 Pass by Reference 傳的是參照，也就是地址，所以裡外等同於是一個變數。接著我們一樣把記憶體位址印出來。看看是不是真的是同樣的記憶體位址。</p>
<p><img src="https://miro.medium.com/max/1400/1*g5dJuhrsAhHU9KCEG8kv6Q.png"></p>
<p>執行結果：</p>
<pre><code>The Address of number is 0x7ffd45470b64  
The Address of num is 0x7ffd45470b64  
The Address of num is 0x7ffd45470b64  
The Address of number is 0x7ffd45470b64
</code></pre>
<p>發現結果如我們推測的，從頭到尾記憶體位址都是 <code>0x7ffd45470b64</code> 。因為我們傳的是記憶體位址嘛。</p>
<p>Step 1：宣告 number</p>
<p><img src="https://miro.medium.com/max/1400/1*gJ2brrZQhpC2H_dkak1avw.jpeg"></p>
<p>Step 2：呼叫 passByReference 時不會複製一份 number 的值，也就是「共用」同一份的值。</p>
<p><img src="https://miro.medium.com/max/1400/1*_zpwpMD4wtsfNFRvwcmgPA.jpeg"></p>
<p>Step 3：因為共用一份資料，num 更新時，也更新到了 number。</p>
<p><img src="https://miro.medium.com/max/1400/1*lQxer-s2-Ajq7SMHxt-ejQ.jpeg"></p>
<p>Step 4: 看所以最後得到的結果是 <code>After: number is 3</code> ，因為 number 已經被改變</p>
<p><img src="https://miro.medium.com/max/1400/1*kwzZQt9H5kmtG-2WEJyKDQ.jpeg"></p>
<h2 id="3-來看看-Python-是不是-Pass-by-Value"><a href="#3-來看看-Python-是不是-Pass-by-Value" class="headerlink" title="3. 來看看 Python 是不是 Pass by Value"></a>3. 來看看 Python 是不是 Pass by Value</h2><p>接著我們來看看 Python 是否是 Pass by Value。</p>
<p><img src="https://miro.medium.com/max/1400/1*acxTqQr7L_rbJacALb8ZgQ.png"></p>
<p>執行結果</p>
<pre><code>Before the function starts, the number is 7  
Before the function starts, the number is 7  
After the function ends, the number is 1  
After the function ends, the number is 7
</code></pre>
<p>執行完 function_1 後，發現原本的 number，並<strong>沒有</strong>因為在函式中重新指派而改變成 1，還是維持原本的 7。</p>
<p>看起來跟 C++ 的 Pass Value 很像，接著我們再做一個實驗，把記憶體位置印出來。</p>
<p><img src="https://miro.medium.com/max/1400/1*quhWD010vL1GiWYlr2_SVQ.png"></p>
<p>執行結果：</p>
<pre><code>Before the function starts, the id is 4321770416  
Before assigning, the num is %d 4321770416  
After assigning, the num is %d 4321770224  
After the function ends, the id is 4321770416
</code></pre>
<p>可以發現，行為雖然像是 Pass by Value，但是記憶體位址變化的時候，並不是執行 function_1 函式的當下，而是在指派 num = 1 之後。這是為什麼呢？</p>
<p>Step 1：將 7 指派給變數 number，此時 7 存到記憶體中。</p>
<p><img src="https://miro.medium.com/max/1400/1*cxodciZzJQTX0Jqds0LoOg.jpeg"></p>
<p>Step 2：呼叫函式 pass_by_value() 的時候，將 7 傳了進去。此時函式並不會複製一份值進去。</p>
<p><img src="https://miro.medium.com/max/1400/1*yRz_pkqny6-wtLUKOwB1OA.jpeg"></p>
<p>Step 3：當執行到 <code>num=1</code>時， num 是整數型別，是 Imuttable Object 不可變物件，值無法改變，因此會新增一塊記憶體來儲存 num。</p>
<p><img src="https://miro.medium.com/max/1400/1*5YlFf5L6ZQ4g0x_R6tW29g.jpeg"></p>
<p>Step 4 : 所以最後印出時，不會是 1，而是 7 ，因為 number 與 num 已經沒有共用記憶體位置</p>
<p><img src="https://miro.medium.com/max/1400/1*Up_KTylJRgd-DTY9--hJEA.jpeg"></p>
<p>結論：Python 的 function_1 跟 C++的 Call by Value 最後的結果都有分開的記憶體位址。但是從記憶體位址變化的時機可以看得出來，讓 Python 有此現象的，是 Imuttable Object 不可變的特性，而非 Call by Value。</p>
<h2 id="4-來看看-Python-是不是Pass-By-Reference"><a href="#4-來看看-Python-是不是Pass-By-Reference" class="headerlink" title="4. 來看看 Python 是不是Pass By Reference"></a>4. 來看看 Python 是不是Pass By Reference</h2><p>接著我們來看看 Python 是否是 Pass by Reference。</p>
<p><img src="https://miro.medium.com/max/1400/1*-cE58YFm5qjm83E1QfFi4Q.png"></p>
<p>執行結果</p>
<pre><code>before the function starts, the object is `&#123;‘name’: ‘Leo’, ‘age’: 25&#125;`  
before the variable assign, the obj is `&#123;‘name’: ‘Leo’, ‘age’: 25&#125;`  
after the variable assign, the obj is `&#123;‘name’: ‘9m88’, ‘age’: 20&#125;`  
after the function ends, the object is `&#123;‘name’: ‘9m88’, ‘age’: 20&#125;`
</code></pre>
<p>哇，外面 object 的內容居然被改變了，跟剛剛的 number 行為完全不一樣，這是怎麼回事？難道這是 Call by Reference？ 可是我們沒有傳地址進去呀。</p>
<p>一樣，我們先把記憶體位址印出來試試看。</p>
<p><img src="https://miro.medium.com/max/1400/1*9VkabOJ6eL1vxFlRA2tWRA.png"></p>
<p>執行結果：</p>
<pre><code>Before variable assign, the object id is 4508274560  
Before variable assign, the obj id is 4508274560  
After variable assign, the obj id is 4508274560  
After variable assign, the object id is 4508274560
</code></pre>
<p>記憶體位址完全沒有改變，這是為什麼呢？因為剛剛我們使用字典 (dict) 這種資料型別，是屬於可變物件 (Mutable Object)，內容可以改變</p>
<h3 id="深入資料型別字典-dict-的記憶體調用"><a href="#深入資料型別字典-dict-的記憶體調用" class="headerlink" title="深入資料型別字典(dict) 的記憶體調用"></a>深入資料型別字典(dict) 的記憶體調用</h3><p>我們來看看這段程式記憶體的調用。這次的圖表將記憶體更精確的分為儲存空間所儲存的「資料 Data」與儲存空間的「地址 Address」。</p>
<p>因為字典這種物件是 mutable 可變的，代表這種物件的值是可以改變的，所以想要來看看到底是記憶體怎麼儲存，才是可以改變的</p>
<p>如果不了解 Imuttable 的人可以參考我寫的另外一篇文章。<a target="_blank" rel="noopener" href="https://medium.com/starbugs/python-mutable-%E8%88%87-immutable-8ef7804181cd">Python — Mutable vs Immutable</a>。裡面講解了 Python 中可變與不可變的概念。</p>
<p><img src="https://miro.medium.com/max/1400/1*zb9rX_Vz5LW6YKjnFfPLjA.jpeg"></p>
<p>宣告 object 物件的時候，變數 Variable: object，指向一個記憶體位址為 <code>x8</code> 資料為 <code>x7</code>。變數本身不直接儲存資料的，只會儲存資料的記憶體位址。而真正的資料儲存在地址為 <code>x7</code> 資料為 <code>&#123;‘name’: ‘Leo’, ‘age’: 25&#125;</code> 。</p>
<p><img src="https://miro.medium.com/max/1400/1*Aol6KUSfse1xiSL1NcoKzw.jpeg"></p>
<p>是呼叫function_2 函式的時候，object 的參照傳進去函式裡面，變數名稱變為 obj 。 變數 obj 將內容的地址，儲存在 x9 記憶體位址，資料為 x7。告訴變數 obj 可以去地址 x7 拿資料，這樣就會找到原本物件內容了。</p>
<p><img src="https://miro.medium.com/max/1400/1*ZJCeT_6VlT9O3ov8uBodhA.jpeg"></p>
<p>接著實際執行 pass_by_reference() 函式，因為之前變數 obj 將資料指向跟變數 dict_object 相同的物件，<strong>所以實際修改到的資料，是原本的資料</strong>。最後印出來的時候發現，原始的物件內容已經被改變。</p>
<p>回顧一下 function_2 的執行結果，函式內部的改變會改變 object 外部的內容。</p>
<p>執行結果：  </p>
<pre><code>before the function starts, the object is &#123;‘name’: ‘Leo’, ‘age’: 25&#125;   
before the variable assign, the obj is &#123;‘name’: ‘Leo’, ‘age’: 25&#125;   
after the variable assign, the obj is &#123;‘name’: ‘9m88’, ‘age’: 20&#125;   
after the function ends, the object is &#123;‘name’: ‘9m88’, ‘age’: 20&#125;
</code></pre>
<h2 id="5-來看看-Python-是不是-Pass-by-Sharing"><a href="#5-來看看-Python-是不是-Pass-by-Sharing" class="headerlink" title="5. 來看看 Python 是不是 Pass by Sharing"></a>5. 來看看 Python 是不是 Pass by Sharing</h2><p>接下來我們來看範例 3，將範例 2 稍作改變，來看看會發生什麼事情</p>
<p><img src="https://miro.medium.com/max/1400/1*HQBLuze2e6fjD3XmuXdPFA.png"></p>
<p>我們將 function_2() 方法改成 function_3()。並且把將方法的內容改成建立新物件的方式。</p>
<pre><code class="python">def function\_3(obj):  
    obj = &#123;  
      &#39;name&#39;: &#39;Amy&#39;,  
      &#39;age&#39;: 50  
    &#125;
</code></pre>
<p>執行結果:</p>
<pre><code>before the function starts, the dict_object is &#123;‘name’: ‘Leo’, ‘age’: 25&#125;
before assign, the obj is &#123;‘name’: ‘Leo’, ‘age’: 25&#125;
after assign, the obj is &#123;‘name’: ‘Amy’, ‘age’: 50&#125;
after the function ends, the dict_object is &#123;‘name’: ‘Leo’, ‘age’: 25&#125;
</code></pre>
<p>輸出結果再度變回跟 function_1 的結果一樣，無法改變外部物件，這是為什麼呢？</p>
<p>Step 1: 跟 function_2 完全相同。初始化字典物件內容。</p>
<p><img src="https://miro.medium.com/max/1400/1*uZkD4xgrcbl5jaPxIFD3qQ.jpeg"></p>
<p>Step 2: 這時就可以看得出來到底發生了什麼事情了，如果是直接使用建立一個新物件的來賦予變數 obj，那麼將不會改變原本變數 dict_obj 的值。</p>
<p><img src="https://miro.medium.com/max/1400/1*8N1xB7HsUQr5GKEVMOgy1Q.jpeg"></p>
<p>我們可以得出一個結論，在使用可變物件(Muttable Object)的時候，如果重新指派新的物件給它，它就不會保持共用記憶體，而是建立一個心的物件。</p>
<h2 id="6-Python-到底是-Pass-by-Value-Pass-Value-還是-Pass-Sharing-呢？"><a href="#6-Python-到底是-Pass-by-Value-Pass-Value-還是-Pass-Sharing-呢？" class="headerlink" title="6. Python 到底是 Pass by Value, Pass Value 還是 Pass Sharing 呢？"></a>6. Python 到底是 Pass by Value, Pass Value 還是 Pass Sharing 呢？</h2><h3 id="都不是，Python-是-Pass-by-Assignment！"><a href="#都不是，Python-是-Pass-by-Assignment！" class="headerlink" title="都不是，Python 是 Pass by Assignment！"></a>都不是，Python 是 Pass by Assignment！</h3><p>我覺得最清楚的是這篇 Stack Overflow 的回答，簡單解釋，引數傳的是物件的參照(Call by Object Reference)，但此 Reference 是由 Pass by Value 的方式實作。</p>
<p>可以歸納出兩個結論：</p>
<ul>
<li>如果你傳遞的可變物件 (Mutable Object)，傳遞的是物件的參照(記憶體位址)，所以可變物件的值是可以改變的，你可以因此修改到原始的物件的內容。</li>
<li>可變物件 (Mutable Object) 有一個例外是你重新指派一個新的物件給他，外部的作用域(Scope)將無法得知你做的事情，所以外部作用域會認舊的物件，而不是新指派的物件。</li>
<li>如果你用的是不可變物件(Imutable Object)，那麼因為每次指派都會是新的物件，但是物件是在函式作用域內部生成的，所以外部作用域無法得知。就變成了兩個物件</li>
</ul>
<p><img src="https://miro.medium.com/max/1400/1*g8i5cH_ceTp0t7msLsl6Nw.png"></p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference">https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference</a></p>
<p>最後再回到官方文件的定義，確認一下 Python 真的是 Pass by Assignment，打完收工。</p>
<p><img src="https://miro.medium.com/max/1400/1*OPI1RZvLI-0gCoAvsS8Xog.png"></p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference">https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference</a></p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2021/08/24/2021-08-24-mutable-and-imuttable/" title="Python — Mutable vs Immutable"><span class="has-text-weight-semibold">Next: Python — Mutable vs Immutable</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="LukaHuang/" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/LukaHuang"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><a title="linkedin" target="_blank" rel="noopener nofollow" href="//www.linkedin.com/in/LukaHuang"><i class="iconfont icon-linkedin"></i></a><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//CodeShiba"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Luka.tw 2021</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo </p></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>