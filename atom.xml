<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Luka.tw 魯卡與阿柴的窩</title>
  
  
  <link href="https://luka.tw/atom.xml" rel="self"/>
  
  <link href="https://luka.tw/"/>
  <updated>2021-10-08T18:53:53.368Z</updated>
  <id>https://luka.tw/</id>
  
  <author>
    <name>Luka Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 到底是 Call by Value, Call by Reference, 還是 Call by Sharing？</title>
    <link href="https://luka.tw/2021/09/21/2021-09-21-is-python-call-by-sharing/"/>
    <id>https://luka.tw/2021/09/21/2021-09-21-is-python-call-by-sharing/</id>
    <published>2021-09-21T12:50:00.000Z</published>
    <updated>2021-10-08T18:53:53.368Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://miro.medium.com/max/1400/1*u7A0F0uSK_7dXz-cBbw7Wg.jpeg"></p><p>常見的語言的求值策略(Evaluation strategy)大概離不開這幾個，例如：JavaScript (Call by Value, Call by Sharing)、Java (Call by Value)、C (Call by Value)、C++ (Call by Value, Call by Reference)</p><p>這次使用使用淺顯易懂的語言，並搭配圖片來說明到底 Python 中是 Pass by Value, Pass by Reference, 還是 Pass Sharing？</p><p>本篇目錄：  </p><ol><li>用 C++ 理解 Pass by Value  </li><li>用 C++ 理解 Pass by Reference  </li><li>來看看 Python 是不是 Pass by Value  </li><li>來看看 Python 是不是 Pass by Reference  </li><li>來看看 Python 是不是 Pass By Sharing  </li><li>Python 到底是 Pass by Value, Pass Value 還是 Pass Sharing 呢？</li></ol><h2 id="1-用-C-理解-Pass-by-Value"><a href="#1-用-C-理解-Pass-by-Value" class="headerlink" title="1. 用 C++ 理解 Pass by Value"></a>1. 用 C++ 理解 Pass by Value</h2><p>C++ 是探討 Pass by Value 與 Pass by Reference 的最佳選擇。我們先來理解 Pass by Value。</p><h3 id="Pass-by-Value-Output"><a href="#Pass-by-Value-Output" class="headerlink" title="Pass by Value (Output)"></a>Pass by Value (Output)</h3><p><img src="https://miro.medium.com/max/1400/1*_Kv0cQp2ot5CaFq4F-eeeA.png"></p><p>執行結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Before: number is 7  <br>Before: the num is 7  <br>After: the num is 3  <br>After: number is 7<br></code></pre></td></tr></table></figure><h3 id="Pass-by-Value-Address"><a href="#Pass-by-Value-Address" class="headerlink" title="Pass by Value (Address)"></a>Pass by Value (Address)</h3><p>可以看到函式內部的數並不會受到影響，遵守作用域( Scope)範圍。我們再執行另一個程式，查看記憶體位址的改變。</p><p><img src="https://miro.medium.com/max/1400/1*_tqEX2mp6P1mmhQXz3giYw.png"></p><p>執行結果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">The Address of number is 0x7ffd0abe7b74  <br>The Address of num is 0x7ffd0abe7b5c  <br>The Address of num is 0x7ffd0abe7b5c  <br>The Address of number is 0x7ffd0abe7b74<br></code></pre></td></tr></table></figure><p>可以發現 num 的位址遵守作用域 (Scope)，經過這兩個程式之後，可以理解到 Pass by Value 是在呼叫函式的時候，複製一份引數(number)給函式使用。</p><p>Step 1：宣告 number 為 7</p><p><img src="https://miro.medium.com/max/1400/1*COCGC0koxgEwwAcyjIxPqQ.jpeg"></p><p>Step 2：呼叫函式時，複製一份給 number 的值複製一份給 num。</p><p><img src="https://miro.medium.com/max/1400/1*effkI4tD0QRbyshr32eZTQ.jpeg"></p><p>step 3：修改 num 的值時，修改的是複製出來的那一份。因此原本的 number 不受影響。</p><p><img src="https://miro.medium.com/max/1400/1*DmDfGRZBfjNgsJOz0djjTg.jpeg"></p><h2 id="2-用-C-理解-Pass-by-Reference"><a href="#2-用-C-理解-Pass-by-Reference" class="headerlink" title="2. 用 C++ 理解 Pass by Reference"></a>2. 用 C++ 理解 Pass by Reference</h2><h3 id="Pass-by-Reference"><a href="#Pass-by-Reference" class="headerlink" title="Pass by Reference"></a>Pass by Reference</h3><p><img src="https://miro.medium.com/max/1400/1*iq5MtwlbxH2pauCvUn1IlA.png"></p><p>執行結果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Before: number is 7  <br>Before: the num is 7  <br>After: the num is 3  <br>After: number is 3<br></code></pre></td></tr></table></figure><h3 id="Pass-by-Reference-Address"><a href="#Pass-by-Reference-Address" class="headerlink" title="Pass by Reference (Address)"></a>Pass by Reference (Address)</h3><p>跟剛剛不同的是，因為 Pass by Reference 傳的是參照，也就是地址，所以裡外等同於是一個變數。接著我們一樣把記憶體位址印出來。看看是不是真的是同樣的記憶體位址。</p><p><img src="https://miro.medium.com/max/1400/1*g5dJuhrsAhHU9KCEG8kv6Q.png"></p><p>執行結果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">The Address of number is 0x7ffd45470b64  <br>The Address of num is 0x7ffd45470b64  <br>The Address of num is 0x7ffd45470b64  <br>The Address of number is 0x7ffd45470b64<br></code></pre></td></tr></table></figure><p>發現結果如我們推測的，從頭到尾記憶體位址都是 <code>0x7ffd45470b64</code> 。因為我們傳的是記憶體位址嘛。</p><p>Step 1：宣告 number</p><p><img src="https://miro.medium.com/max/1400/1*gJ2brrZQhpC2H_dkak1avw.jpeg"></p><p>Step 2：呼叫 passByReference 時不會複製一份 number 的值，也就是「共用」同一份的值。</p><p><img src="https://miro.medium.com/max/1400/1*_zpwpMD4wtsfNFRvwcmgPA.jpeg"></p><p>Step 3：因為共用一份資料，num 更新時，也更新到了 number。</p><p><img src="https://miro.medium.com/max/1400/1*lQxer-s2-Ajq7SMHxt-ejQ.jpeg"></p><p>Step 4: 看所以最後得到的結果是 <code>After: number is 3</code> ，因為 number 已經被改變</p><p><img src="https://miro.medium.com/max/1400/1*kwzZQt9H5kmtG-2WEJyKDQ.jpeg"></p><h2 id="3-來看看-Python-是不是-Pass-by-Value"><a href="#3-來看看-Python-是不是-Pass-by-Value" class="headerlink" title="3. 來看看 Python 是不是 Pass by Value"></a>3. 來看看 Python 是不是 Pass by Value</h2><p>接著我們來看看 Python 是否是 Pass by Value。</p><p><img src="https://miro.medium.com/max/1400/1*acxTqQr7L_rbJacALb8ZgQ.png"></p><p>執行結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Before the function starts, the number is 7  <br>Before the function starts, the number is 7  <br>After the function ends, the number is 1  <br>After the function ends, the number is 7<br></code></pre></td></tr></table></figure><p>執行完 function_1 後，發現原本的 number，並<strong>沒有</strong>因為在函式中重新指派而改變成 1，還是維持原本的 7。</p><p>看起來跟 C++ 的 Pass Value 很像，接著我們再做一個實驗，把記憶體位置印出來。</p><p><img src="https://miro.medium.com/max/1400/1*quhWD010vL1GiWYlr2_SVQ.png"></p><p>執行結果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Before the function starts, the id is 4321770416  <br>Before assigning, the num is %d 4321770416  <br>After assigning, the num is %d 4321770224  <br>After the function ends, the id is 4321770416<br></code></pre></td></tr></table></figure><p>可以發現，行為雖然像是 Pass by Value，但是記憶體位址變化的時候，並不是執行 function_1 函式的當下，而是在指派 num = 1 之後。這是為什麼呢？</p><p>Step 1：將 7 指派給變數 number，此時 7 存到記憶體中。</p><p><img src="https://miro.medium.com/max/1400/1*cxodciZzJQTX0Jqds0LoOg.jpeg"></p><p>Step 2：呼叫函式 pass_by_value() 的時候，將 7 傳了進去。此時函式並不會複製一份值進去。</p><p><img src="https://miro.medium.com/max/1400/1*yRz_pkqny6-wtLUKOwB1OA.jpeg"></p><p>Step 3：當執行到 <code>num=1</code>時， num 是整數型別，是 Imuttable Object 不可變物件，值無法改變，因此會新增一塊記憶體來儲存 num。</p><p><img src="https://miro.medium.com/max/1400/1*5YlFf5L6ZQ4g0x_R6tW29g.jpeg"></p><p>Step 4 : 所以最後印出時，不會是 1，而是 7 ，因為 number 與 num 已經沒有共用記憶體位置</p><p><img src="https://miro.medium.com/max/1400/1*Up_KTylJRgd-DTY9--hJEA.jpeg"></p><p>結論：Python 的 function_1 跟 C++的 Call by Value 最後的結果都有分開的記憶體位址。但是從記憶體位址變化的時機可以看得出來，讓 Python 有此現象的，是 Imuttable Object 不可變的特性，而非 Call by Value。</p><h2 id="4-來看看-Python-是不是Pass-By-Reference"><a href="#4-來看看-Python-是不是Pass-By-Reference" class="headerlink" title="4. 來看看 Python 是不是Pass By Reference"></a>4. 來看看 Python 是不是Pass By Reference</h2><p>接著我們來看看 Python 是否是 Pass by Reference。</p><p><img src="https://miro.medium.com/max/1400/1*-cE58YFm5qjm83E1QfFi4Q.png"></p><p>執行結果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">before the function starts, the object is `&#123;‘name’: ‘Leo’, ‘age’: 25&#125;`  <br>before the variable assign, the obj is `&#123;‘name’: ‘Leo’, ‘age’: 25&#125;`  <br>after the variable assign, the obj is `&#123;‘name’: ‘9m88’, ‘age’: 20&#125;`  <br>after the function ends, the object is `&#123;‘name’: ‘9m88’, ‘age’: 20&#125;`<br></code></pre></td></tr></table></figure><p>哇，外面 object 的內容居然被改變了，跟剛剛的 number 行為完全不一樣，這是怎麼回事？難道這是 Call by Reference？ 可是我們沒有傳地址進去呀。</p><p>一樣，我們先把記憶體位址印出來試試看。</p><p><img src="https://miro.medium.com/max/1400/1*9VkabOJ6eL1vxFlRA2tWRA.png"></p><p>執行結果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Before variable assign, the object id is 4508274560  <br>Before variable assign, the obj id is 4508274560  <br>After variable assign, the obj id is 4508274560  <br>After variable assign, the object id is 4508274560<br></code></pre></td></tr></table></figure><p>記憶體位址完全沒有改變，這是為什麼呢？因為剛剛我們使用字典 (dict) 這種資料型別，是屬於可變物件 (Mutable Object)，內容可以改變</p><h3 id="深入資料型別字典-dict-的記憶體調用"><a href="#深入資料型別字典-dict-的記憶體調用" class="headerlink" title="深入資料型別字典(dict) 的記憶體調用"></a>深入資料型別字典(dict) 的記憶體調用</h3><p>我們來看看這段程式記憶體的調用。這次的圖表將記憶體更精確的分為儲存空間所儲存的「資料 Data」與儲存空間的「地址 Address」。</p><p>因為字典這種物件是 mutable 可變的，代表這種物件的值是可以改變的，所以想要來看看到底是記憶體怎麼儲存，才是可以改變的</p><p>如果不了解 Imuttable 的人可以參考我寫的另外一篇文章。<a href="https://medium.com/starbugs/python-mutable-%E8%88%87-immutable-8ef7804181cd">Python — Mutable vs Immutable</a>。裡面講解了 Python 中可變與不可變的概念。</p><p><img src="https://miro.medium.com/max/1400/1*zb9rX_Vz5LW6YKjnFfPLjA.jpeg"></p><p>宣告 object 物件的時候，變數 Variable: object，指向一個記憶體位址為 <code>x8</code> 資料為 <code>x7</code>。變數本身不直接儲存資料的，只會儲存資料的記憶體位址。而真正的資料儲存在地址為 <code>x7</code> 資料為 <code>&#123;‘name’: ‘Leo’, ‘age’: 25&#125;</code> 。</p><p><img src="https://miro.medium.com/max/1400/1*Aol6KUSfse1xiSL1NcoKzw.jpeg"></p><p>是呼叫function_2 函式的時候，object 的參照傳進去函式裡面，變數名稱變為 obj 。 變數 obj 將內容的地址，儲存在 x9 記憶體位址，資料為 x7。告訴變數 obj 可以去地址 x7 拿資料，這樣就會找到原本物件內容了。</p><p><img src="https://miro.medium.com/max/1400/1*ZJCeT_6VlT9O3ov8uBodhA.jpeg"></p><p>接著實際執行 pass_by_reference() 函式，因為之前變數 obj 將資料指向跟變數 dict_object 相同的物件，<strong>所以實際修改到的資料，是原本的資料</strong>。最後印出來的時候發現，原始的物件內容已經被改變。</p><p>回顧一下 function_2 的執行結果，函式內部的改變會改變 object 外部的內容。</p><p>執行結果：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">before the function starts, the object is &#123;‘name’: ‘Leo’, ‘age’: 25&#125;   <br>before the variable assign, the obj is &#123;‘name’: ‘Leo’, ‘age’: 25&#125;   <br>after the variable assign, the obj is &#123;‘name’: ‘9m88’, ‘age’: 20&#125;   <br>after the function ends, the object is &#123;‘name’: ‘9m88’, ‘age’: 20&#125;<br></code></pre></td></tr></table></figure><h2 id="5-來看看-Python-是不是-Pass-by-Sharing"><a href="#5-來看看-Python-是不是-Pass-by-Sharing" class="headerlink" title="5. 來看看 Python 是不是 Pass by Sharing"></a>5. 來看看 Python 是不是 Pass by Sharing</h2><p>接下來我們來看範例 3，將範例 2 稍作改變，來看看會發生什麼事情</p><p><img src="https://miro.medium.com/max/1400/1*HQBLuze2e6fjD3XmuXdPFA.png"></p><p>我們將 function_2() 方法改成 function_3()。並且把將方法的內容改成建立新物件的方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">function</span>\<span class="hljs-title">_3</span>(<span class="hljs-params">obj</span>):</span>  <br>    obj = &#123;  <br>      <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Amy&#x27;</span>,  <br>      <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">50</span>  <br>    &#125;<br></code></pre></td></tr></table></figure><p>執行結果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">before the function starts, the dict_object is &#123;‘name’: ‘Leo’, ‘age’: 25&#125;<br>before assign, the obj is &#123;‘name’: ‘Leo’, ‘age’: 25&#125;<br>after assign, the obj is &#123;‘name’: ‘Amy’, ‘age’: 50&#125;<br>after the function ends, the dict_object is &#123;‘name’: ‘Leo’, ‘age’: 25&#125;<br></code></pre></td></tr></table></figure><p>輸出結果再度變回跟 function_1 的結果一樣，無法改變外部物件，這是為什麼呢？</p><p>Step 1: 跟 function_2 完全相同。初始化字典物件內容。</p><p><img src="https://miro.medium.com/max/1400/1*uZkD4xgrcbl5jaPxIFD3qQ.jpeg"></p><p>Step 2: 這時就可以看得出來到底發生了什麼事情了，如果是直接使用建立一個新物件的來賦予變數 obj，那麼將不會改變原本變數 dict_obj 的值。</p><p><img src="https://miro.medium.com/max/1400/1*8N1xB7HsUQr5GKEVMOgy1Q.jpeg"></p><p>我們可以得出一個結論，在使用可變物件(Muttable Object)的時候，如果重新指派新的物件給它，它就不會保持共用記憶體，而是建立一個心的物件。</p><h2 id="6-Python-到底是-Pass-by-Value-Pass-Value-還是-Pass-Sharing-呢？"><a href="#6-Python-到底是-Pass-by-Value-Pass-Value-還是-Pass-Sharing-呢？" class="headerlink" title="6. Python 到底是 Pass by Value, Pass Value 還是 Pass Sharing 呢？"></a>6. Python 到底是 Pass by Value, Pass Value 還是 Pass Sharing 呢？</h2><h3 id="都不是，Python-是-Pass-by-Assignment！"><a href="#都不是，Python-是-Pass-by-Assignment！" class="headerlink" title="都不是，Python 是 Pass by Assignment！"></a>都不是，Python 是 Pass by Assignment！</h3><p>我覺得最清楚的是這篇 Stack Overflow 的回答，簡單解釋，引數傳的是物件的參照(Call by Object Reference)，但此 Reference 是由 Pass by Value 的方式實作。</p><p>可以歸納出兩個結論：</p><ul><li>如果你傳遞的可變物件 (Mutable Object)，傳遞的是物件的參照(記憶體位址)，所以可變物件的值是可以改變的，你可以因此修改到原始的物件的內容。</li><li>可變物件 (Mutable Object) 有一個例外是你重新指派一個新的物件給他，外部的作用域(Scope)將無法得知你做的事情，所以外部作用域會認舊的物件，而不是新指派的物件。</li><li>如果你用的是不可變物件(Imutable Object)，那麼因為每次指派都會是新的物件，但是物件是在函式作用域內部生成的，所以外部作用域無法得知。就變成了兩個物件</li></ul><p><img src="https://miro.medium.com/max/1400/1*g8i5cH_ceTp0t7msLsl6Nw.png"></p><p><a href="https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference">https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference</a></p><p>最後再回到官方文件的定義，確認一下 Python 真的是 Pass by Assignment，打完收工。</p><p><img src="https://miro.medium.com/max/1400/1*OPI1RZvLI-0gCoAvsS8Xog.png"></p><p><a href="https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference">https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/1400/1*u7A0F0uSK_7dXz-cBbw7Wg.jpeg&quot;&gt;&lt;/p&gt;
&lt;p&gt;常見的語言的求值策略(Evaluation strategy)大概離不開這幾個，例如：JavaScript (Call by Value, Call by Sharing)、Java (Call by Value)、C (Call by Value)、C++ (Call by Value, Call by Reference)&lt;/p&gt;
&lt;p&gt;這次使用使用淺顯易懂的語言，並搭配圖片來說明到底 Python 中是 Pass by Value, Pass by Reference, 還是 Pass Sharing？&lt;/p&gt;
&lt;p&gt;本篇目錄：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用 C++ 理解 Pass by Value  &lt;/li&gt;
&lt;li&gt;用 C++ 理解 Pass by Reference  &lt;/li&gt;
&lt;li&gt;來看看 Python 是不是 Pass by Value  &lt;/li&gt;
&lt;li&gt;來看看 Python 是不是 Pass by Reference  &lt;/li&gt;
&lt;li&gt;來看看 Python 是不是 Pass By Sharing  &lt;/li&gt;
&lt;li&gt;Python 到底是 Pass by Value, Pass Value 還是 Pass Sharing 呢？&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Python" scheme="https://luka.tw/categories/Python/"/>
    
    <category term="01 基礎教學" scheme="https://luka.tw/categories/Python/01-%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>[Python 教學] 探討重要特性 Mutable 與 Immutable</title>
    <link href="https://luka.tw/2021/08/24/2021-08-24-mutable-and-imuttable/"/>
    <id>https://luka.tw/2021/08/24/2021-08-24-mutable-and-imuttable/</id>
    <published>2021-08-24T11:32:00.000Z</published>
    <updated>2021-10-09T15:00:40.205Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://hackmd.io/_uploads/SJ2qmZySK.jpg"></p><p>今天來探討 Python 中的 Mutable 與 Immutable 的概念。Mutable 顧名思意就是「可變的」，而「Immutable」顧名思義是不可變得。</p><p>那麼什麼在 Python 中什麼是「可變的」？什麼是「不可變的」呢？我們來說得具體一點。</p><blockquote><p>Python 中 Mutable 定義，</p><p>物件的「值」可以被改變。</p></blockquote><p>反之，Immutable 就是物件的值不可以被改變。</p><p>聽到這邊你可能產生一些疑惑，為什麼是「物件」？什麼是「值」？可以改變和不可以被改變又是怎麼回事？</p><p>我們先來探討第一個問題，為什麼是物件。</p><blockquote><p>Everything Is an Object by <a href="https://linux.die.net/diveintopython/html/getting_to_know_python/everything_is_an_object.html#d0e4665">DiveIntoPython</a></p></blockquote><p>這是什麼意思呢？ 在 Python 中你所使用的一切東西都是物件。 如果你有寫過其他語言，例如：Java。你可能會產生一些疑惑。Java 中的 int 是基本型別(<a href="http://download.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">Primitive Data Types</a>)。</p><p>我們來看看 Java 中的基本型別是怎麼定義的：</p><blockquote><p>Primitive types are special data types built into the language; they are not objects created from a class. A <em>literal</em> is the source code representation of a fixed value; literals are represented directly in your code without requiring computation.</p></blockquote><p>Java 中的基本型別是語言中特別的資料型別，「不是」物件。</p><p>Python 中一切皆是物件，跟 Java 剛好成為強烈的對比。我們來試試看一下 Python 中的資料型別。</p><p>使用 id(object) 可以找到物件 id。<br>使用 __class__ 特殊方法可以找到物件是由哪個類別(class)生成的。</p><p>由此可知，在 Python 中的基本型別也是物件。其他特殊情況，例如函式，在 Python 中也是物件，這邊講太多會有點失焦，所以我們先回到主軸。</p><p>接下來來談談「可變的物件」，那麼什麼東西是可變的呢？同理，此物件的值可以被改變。</p><p>我們用字典 ( dict) 資料型別來演示，當我們創造出一個字典資料結構的時候，裡面的內容是可以被改變的，而且外部的 id 卻不會改變。這樣的特性就跟 JS 之類的動態語言比較相似。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://hackmd.io/_uploads/SJ2qmZySK.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天來探討 Python 中的 Mutable 與 Immutable 的概念。Mutable 顧名思意就是「可變的」，而「Immutable」顧名思義是不可變得。&lt;/p&gt;
&lt;p&gt;那麼什麼在 Python 中什麼是「可變的」？什麼是「不可變的」呢？我們來說得具體一點。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Python 中 Mutable 定義，&lt;/p&gt;
&lt;p&gt;物件的「值」可以被改變。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;反之，Immutable 就是物件的值不可以被改變。&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://luka.tw/categories/Python/"/>
    
    <category term="01 基礎教學" scheme="https://luka.tw/categories/Python/01-%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>WSL - 在 Windows 上打造 Linux 的開發體驗</title>
    <link href="https://luka.tw/2020/11/15/2020-11-15-wsl/"/>
    <id>https://luka.tw/2020/11/15/2020-11-15-wsl/</id>
    <published>2020-11-15T12:50:00.000Z</published>
    <updated>2021-10-04T14:39:32.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在-Windows-上打造-Linux-的開發體驗-WSL是關鍵"><a href="#在-Windows-上打造-Linux-的開發體驗-WSL是關鍵" class="headerlink" title="在 Windows 上打造 Linux 的開發體驗 WSL是關鍵"></a>在 Windows 上打造 Linux 的開發體驗 WSL是關鍵</h2><p><img src="https://cdn-images-1.medium.com/max/12032/0*EkacF0gY7pC8VNHP"></p><p>延續上一篇，打造舒適的 Windows ＋ Mac 雙系統開發環境，打算用一系列的文章，一一來介紹開發各種環境。<br><a href="https://medium.com/starbugs/%E6%89%93%E9%80%A0%E8%88%92%E9%81%A9%E7%9A%84%E9%9B%99%E7%B3%BB%E7%B5%B1%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83-windows-mac-%E9%9B%99%E5%88%80%E6%B5%81-6127ce8583a"><strong>打造舒適的雙系統開發環境 Windows + Mac 雙刀流</strong></a></p><h2 id="重度-Mac-Linux-開發者，嘗試-Windows-開發"><a href="#重度-Mac-Linux-開發者，嘗試-Windows-開發" class="headerlink" title="重度 Mac / Linux 開發者，嘗試 Windows 開發"></a>重度 Mac / Linux 開發者，嘗試 Windows 開發</h2><p>先來說說我是個怎麼樣的人，我是個 Mac / Linux 重度使用者，學生時期使用 Windows 開發實在雷，光是搞環境平均就要花一個禮拜以上。再換成一台二手的 Macbook 之後就一路大順暢，從此只用 Mac / Linux 環境開發。</p><p>直到最近看到強者我朋友用 Windows 用得滿順的，不僅 Web 這些比較通用的東西跑得順，連 Linux 套件和 Docker 甚至 K8S 都可以順利執行。於是我就買了一台 Windows 電腦，那就<strong>來打造出能夠媲美 Linux 開發環境的舒適 Windows 開發體驗吧！</strong></p><h3 id="對-Window-敬而遠之的時期"><a href="#對-Window-敬而遠之的時期" class="headerlink" title="對 Window 敬而遠之的時期"></a>對 Window 敬而遠之的時期</h3><p>過去幾年我的主力開發環境以 Mac 或是 Linux 為主要開發環境，主要的原因是，有許多 Linux 的套件在 Windows 上不太穩定，安裝時發生的錯誤，10 台有 7 台會發生不一樣的情況。可能是軟體發生問題，也有可能是硬體導致，雖然說最終還是可以找到解決方案，可是每台電腦或是重灌都要重複花費大量時間的時間在處理環境。讓我這個 Windows 使用者毅然決然使用 Macbook 做為開發工具，這一用下去，也用了 7 年以上了。</p><h3 id="長年使用-Mac-的我，為什麼想要使用-Windows-開發？"><a href="#長年使用-Mac-的我，為什麼想要使用-Windows-開發？" class="headerlink" title="長年使用 Mac 的我，為什麼想要使用 Windows 開發？"></a>長年使用 Mac 的我，為什麼想要使用 Windows 開發？</h3><p>第一個原因是，看到強者我朋友 Windows 上跑各種環境跑的很順，滿讓我訝異的，因為以往雷到爆的 Windows，好像突然間不雷了？</p><p>但現在的 Windows 滿穩定的，我觀察了一些現象，在安裝了一些套件之後，沒有發生以前動不動就爆炸，卻又非常難排除的情形。</p><h2 id="Cmder-—-類似-Linux-的開發體驗"><a href="#Cmder-—-類似-Linux-的開發體驗" class="headerlink" title="Cmder — 類似 Linux 的開發體驗"></a>Cmder — 類似 Linux 的開發體驗</h2><p><img src="https://cdn-images-1.medium.com/max/2000/1*Qr8dmZO-NTn9U6leLk4Kvg.png"></p><p>Cmder 安裝很簡單，去<a href="https://cmder.net/">官方網站</a>下載即可使用，選擇完全安裝的話，可以連 git 一起安裝起來。可以說是懶人最快建置好環境的方式。</p><p><img src="https://cdn-images-1.medium.com/max/2020/1*xngE0OGWPyxxILjPzSWQhw.png"></p><p>不過由於 Cmder 只是提供一些「類似」Linux 的體驗。並且他是一種「終端機」，所以並不能解鎖好用的 Linux 開發環境。因此接著介紹下一個好冰友 WSL。</p><h2 id="WSL-—-如果想要一勞永逸，選他"><a href="#WSL-—-如果想要一勞永逸，選他" class="headerlink" title="WSL — 如果想要一勞永逸，選他"></a>WSL — 如果想要一勞永逸，選他</h2><p>WSL 讓 Windows 使用者，不必透過虛擬機，就能直接使用 Linux 環境。現在，Windows 變得對 Linux 開發者更友善。</p><p>可以使用 Linux 指令來操作 Windows 系統，令我感到驚豔。以前裝 Linux 套件用一堆奇怪的方法，最後還是裝不好，現在可以直接在 Windows 無縫銜接 Linux，真滴棒！</p><blockquote><h1 id="WSL-讓我們可以在-Windows-上體驗到-Linux-的開發流暢感。"><a href="#WSL-讓我們可以在-Windows-上體驗到-Linux-的開發流暢感。" class="headerlink" title="WSL 讓我們可以在 Windows 上體驗到 Linux 的開發流暢感。"></a>WSL 讓我們可以在 Windows 上體驗到 Linux 的開發流暢感。</h1></blockquote><p>附上 WSL 的架構圖，簡單的說 Linux 的指令會被轉成 NTCore 的 system call，來達到期待的效果。例如：ls 可以列出檔案，</p><p><img src="https://cdn-images-1.medium.com/max/2000/0*TG6RajSFiq-VVYVv.png" alt="[https://blog.jessfraz.com/post/windows-for-linux-nerds/](https://blog.jessfraz.com/post/windows-for-linux-nerds/)"></p><p><em>ps: 想要深入了解 WSL 原理請看這篇 ：<a href="https://hackmd.io/@billsun/Bkh8oAmGX?type=view">**WSL 原理介紹</a></em>**</p><h3 id="WSL-的安裝"><a href="#WSL-的安裝" class="headerlink" title="WSL 的安裝"></a>WSL 的安裝</h3><p>按照下面網頁逐一步驟安裝即可，下面連結中有幾個步驟，依序跑完，即可安裝完成。建議不要參加實驗計畫當白老鼠，跑幾個</p><p>如果沒有加入微軟的實驗計畫，那下面連結中有幾個步驟，依序跑完，即可安裝完成。我自己是沒有參加實驗計畫當白老鼠，指令貼一貼比較省事。<br><a href="https://docs.microsoft.com/zh-tw/windows/wsl/install-win10"><strong>在 Windows 10 上安裝適用於 Linux 的 Windows 子系統 (WSL)</strong><br><em>Windows 子系統 Linux 版有兩個不同的版本，可在安裝過程中進行選擇。 Windows Subsystem for Linux has two different versions to choose between…</em>docs.microsoft.com</a></p><h2 id="有了-WSL-之後，來個終端機吧！"><a href="#有了-WSL-之後，來個終端機吧！" class="headerlink" title="有了 WSL 之後，來個終端機吧！"></a>有了 WSL 之後，來個終端機吧！</h2><p>安裝好 WSL 以後，你就可以在 Windows 上面使用 Linux 指令，該怎麼使用終端機呢？</p><p>打開終端機，輸入 wsl 即會進入 WSL 的環境，並且會將路徑綁定到 Windows 的檔案系統上。下面使用的終端機為 Windows Terminal。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*2JFsU9UUVv3lLs8L-CfqEA.png" alt="圖片來自 Luka 的 Windows"></p><h2 id="Terminal-終端機的選擇"><a href="#Terminal-終端機的選擇" class="headerlink" title="Terminal 終端機的選擇"></a>Terminal 終端機的選擇</h2><p>終端機有幾個選擇，如果你是 Windows 慣用的使用者，你可使用 Cmder 來開啟 WSL，因為你已經習慣了 Cmder 帶來的整合度與習慣。Cmder 也滿漂亮的，只是有些地方，還是需要設定和調教，才能符合自己的使用習慣，例如：$ 的取代 … 等等瑣碎的小事。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*JhFBTyGKv6Fv1kUm1eiCXg.png" alt="圖片來自 Luka 的 Windows"></p><p>如果你是輕量使用者 ，對終端機不是很熟悉，可以用用看 Windows Terminal。微軟推出了一款 Terminal，簡單素雅的頁面，可以輕鬆切換 Powershell 與 WSL 環境，好像也有很多主題可以客製，算是一個簡單好上手的組合。</p><p><img src="https://cdn-images-1.medium.com/max/2092/1*uMK22R1kZv_NugktY8Xymw.png" alt="圖片來自 Luka 的 Windows"></p><p>順帶一提，來看看 Powershell 原始的終端機有多恐怖！！藍色的底，加上進入 WSL 的藍色字體，根本是眼睛殺手，哎呀～我的眼睛業障重！</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*M63D3S3jNvTmEhGHTwu2pA.png" alt="圖片來自 Luka 的 Windows"></p><p>最後一個選項是使用 VS Code 來整合 WSL，方便大家開發的時候順便使用 VSCode 直接下指令。我覺得這也不失為一個理想的開發環境解決方案。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*UfDGLDWWfcnHTxMr1DKrTQ.png" alt="圖片來自 Luka 的 Windows"></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>讓 Windows 上也可以擁有舒適的開發環境是突破自己舒適圈的一小步，現在微軟越來越邁向開源，給他一次機會，雖然因為 Windows 的更新非常的奇葩，你不更新還要給你強制更新，根本使用者體驗殺手，這個情形讓我不會想要轉移主要開發環境過去，但，現在 Windows 是否已經是一個「還可以」的開發環境了呢？我覺得是 ok 的。</p><p>希望這篇有幫助到 Windows 使用者的你😃</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;在-Windows-上打造-Linux-的開發體驗-WSL是關鍵&quot;&gt;&lt;a href=&quot;#在-Windows-上打造-Linux-的開發體驗-WSL是關鍵&quot; class=&quot;headerlink&quot; title=&quot;在 Windows 上打造 Linux 的開發體驗 WSL是關鍵&quot;&gt;&lt;/a&gt;在 Windows 上打造 Linux 的開發體驗 WSL是關鍵&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/12032/0*EkacF0gY7pC8VNHP&quot;&gt;&lt;/p&gt;
&lt;p&gt;延續上一篇，打造舒適的 Windows ＋ Mac 雙系統開發環境，打算用一系列的文章，一一來介紹開發各種環境。&lt;br&gt;&lt;a href=&quot;https://medium.com/starbugs/%E6%89%93%E9%80%A0%E8%88%92%E9%81%A9%E7%9A%84%E9%9B%99%E7%B3%BB%E7%B5%B1%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83-windows-mac-%E9%9B%99%E5%88%80%E6%B5%81-6127ce8583a&quot;&gt;&lt;strong&gt;打造舒適的雙系統開發環境 Windows + Mac 雙刀流&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;重度-Mac-Linux-開發者，嘗試-Windows-開發&quot;&gt;&lt;a href=&quot;#重度-Mac-Linux-開發者，嘗試-Windows-開發&quot; class=&quot;headerlink&quot; title=&quot;重度 Mac / Linux 開發者，嘗試 Windows 開發&quot;&gt;&lt;/a&gt;重度 Mac / Linux 開發者，嘗試 Windows 開發&lt;/h2&gt;&lt;p&gt;先來說說我是個怎麼樣的人，我是個 Mac / Linux 重度使用者，學生時期使用 Windows 開發實在雷，光是搞環境平均就要花一個禮拜以上。再換成一台二手的 Macbook 之後就一路大順暢，從此只用 Mac / Linux 環境開發。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ArgoCD — 透過 ArgoCD 認識 GitOps</title>
    <link href="https://luka.tw/2020/09/21/2020-09-21-introduction-to-gitops-via-argocd/"/>
    <id>https://luka.tw/2020/09/21/2020-09-21-introduction-to-gitops-via-argocd/</id>
    <published>2020-09-21T12:50:00.000Z</published>
    <updated>2021-10-04T14:39:07.248Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/2000/1*4Ggl4UF7SjZk4qoapcDBnA.jpeg"></p><h3 id="什麼是-GitOps"><a href="#什麼是-GitOps" class="headerlink" title="什麼是 GitOps ?"></a>什麼是 GitOps ?</h3><p>兩年前初次聽到 GitOps 的時候，我想說是不是只要 Git tag 觸發一些部屬相關的事情，像是下了某個 tag，就會觸發某 Ansible 的工作，部屬某一台伺服器。很遺憾，完全不是我想的那樣。</p><p>在最近實際將 GitOps 整合進開發流程的過程中，深入研究了一下 GitOps。對 GitOps 有了多一點的了解，趁這個機會來跟大家分享一下。</p><p>GitOps 是 Weaveworks 提出的一種持續交付(CD)的概念，透過 Git 來聲明基礎設施(infrastructure)希望的狀態。什麼是聲明基礎設施希望的狀態？</p><h3 id="從聲明基礎設施希望的狀態談到-K8S"><a href="#從聲明基礎設施希望的狀態談到-K8S" class="headerlink" title="從聲明基礎設施希望的狀態談到 K8S"></a>從聲明基礎設施希望的狀態談到 K8S</h3><p>說到聲明希望的狀態，這就要來了解一下屬於 Cloud Native 體系的 Kubernetes 了。</p><p>因為 Kubernetes 是使用 yaml 檔來建立或是修改所擁有的 K8S 元件。例如你想把某個服務擴展從 3 個 pod 擴展到 5 個 pod。那麼你就會修改 yaml 檔裡面的數字。並使用 kubectl 來應用 yaml 檔案至所對應的 K8S 集群。</p><p>簡單說就是 yaml 等於你目前的 K8S 系統狀態。歡迎來到 yaml 的世界！</p><h3 id="GitOps-解決了哪些痛點？"><a href="#GitOps-解決了哪些痛點？" class="headerlink" title="GitOps 解決了哪些痛點？"></a>GitOps 解決了哪些痛點？</h3><p>當我們想要對 K8S 集群做出改變的時候，我們可以做什麼事情？可以直接下 kubectl apply 直接對 K8S 集群進行修改。可是這樣就出現了一個問題，當有許多人都想要對同一個 K8S 進行修改的時候。A 怎麼知道 B 做了什麼修改？如果 B 修改過後，A 並不知道 B 修改了什麼，也進行了一次修改。那麼很有造成系統全面癱瘓。</p><p>Kubernetes 就像一個終極兵器，你可以讓他輕鬆的做到你想做的事情，例如：在幾分鐘內長出具有負載均衡能力的服務。但是也因此如果操作不當，後果會比傳統架構還要嚴重很多。</p><p>這就是 GitOps 出現的原因！</p><h3 id="GitOps-的原則"><a href="#GitOps-的原則" class="headerlink" title="GitOps 的原則"></a>GitOps 的原則</h3><p><img src="https://cdn-images-1.medium.com/max/2000/1*HHeZOMbdqCwuJ5GxiAkNQw.jpeg"></p><p>Weaveworks 提出 GitOps 的概念，並使用 Flux (不是前端的Flux) 來實作之。其中有幾個比較重要的原則：</p><ol><li><p>整個系統必須是聲名式的</p></li><li><p>希望的狀態必須用 Git 做版控</p></li><li><p>在 Git 中獲准(appoved)的改變可以自動應用到系統上</p></li><li><p>軟體代理(Agent)必須確保系統正確性，如果不正確的話需要有警報通知使用者。</p></li></ol><p>核心觀念其實就是讓你的系統具有「可觀測性」，你可以看到系統目前的狀態。並將所有對 K8S 做的操作，都透過 Git 來操作，這樣的話所有的操作過程都會是一個一個的 Commit。</p><p>下圖左邊是希望的狀態，也就是 Git 中定義的狀態。而實際的狀態，則是右邊。</p><p><img src="https://cdn-images-1.medium.com/max/NaN/1*IDeYMbyPP8-V-L456PRFHg.jpeg" alt="[https://github.com/weaveworks/awesome-](https://github.com/weaveworks/awesome-gitops)"></p><p>如果我們使用的是 ArgoCD 可以輕鬆看到希望狀態與實際狀態的不同。</p><h3 id="用-Argo-CD-來了解-GitOps"><a href="#用-Argo-CD-來了解-GitOps" class="headerlink" title="用 Argo CD 來了解 GitOps"></a>用 Argo CD 來了解 GitOps</h3><p><img src="https://cdn-images-1.medium.com/max/NaN/1*TgJWIt9bE2UDgKLwlp2_hA.jpeg"></p><p>ArogCD 是一款 GitOps 的實現。我們來看看上述說的 GitOps 原則到底是怎麼回事。</p><p><img src="https://cdn-images-1.medium.com/max/NaN/1*rwgdphu1Aq59cG_stmrtRA.jpeg"></p><p>這是 Argo CD 的圖案，一支外太空章魚(還是什麼生物？)，他提供了強大的觀測介面。可以很好的觀測目前 Kubernetes 集群的狀態。</p><p><img src="https://cdn-images-1.medium.com/max/NaN/1*8CA6GfxOSSb9t3FLRPUePA.jpeg"></p><p>來動手做做看！做一個小改變</p><p><img src="https://cdn-images-1.medium.com/max/NaN/1*j_vkc6z1D78bGRIYqttJxA.jpeg"></p><p>Argo CD 顯示 Out of sync</p><p><img src="https://cdn-images-1.medium.com/max/NaN/1*lbeE9qAMq4OzWBpHDLcn2w.jpeg"></p><p>透過 ArgoCD 可以看到到底對 K8S 集群做了哪些改變。</p><p><img src="https://cdn-images-1.medium.com/max/NaN/1*pkCl-99a3QdDNqLE1r02-w.jpeg"></p><p>手動按下 Sync</p><p><img src="https://cdn-images-1.medium.com/max/NaN/1*bCNQ2LDOOEoMKx_4TPra0A.jpeg"></p><p>看看到底發生了什麼事</p><p><img src="https://cdn-images-1.medium.com/max/NaN/1*6J7atxk6ZSVwoArW31lAZA.jpeg"></p><p>並且部屬也有版控，萬一不幸弄壞，也可以即時回到上一版本。</p><p><img src="https://cdn-images-1.medium.com/max/NaN/1*6I5lTwZkVhrYWXCYhSCqMQ.jpeg"></p><p>用起來是不是很輕鬆寫意！</p><h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>GitOps 提供 K8S 集群良好可觀測性，並且把開發或是運維對集群的操作記錄在 Git 中，讓任何人可以清楚看到集群做了哪些改變。並且提供了單一的出口，讓開發者和運惟人員不會私自的對集群改變。萬一被改變了，也提供了警報功能來通知主要運維人員。這樣的方式對於 K8S 日常維護來說，無疑是提供了一個非常實用且可靠的方案。</p><h3 id="同場加映"><a href="#同場加映" class="headerlink" title="同場加映"></a>同場加映</h3><p>2021/5/11 update，本篇是 ArgoCD 入門，如果想要看看 ArgoCD 進階運用，請參閱小城老師的文章：<br><a href="https://medium.com/starbugs/argo-cd-applicationset-controller-%E4%B8%96%E7%95%8C%E7%82%BA%E6%88%91%E8%80%8C%E8%BD%89%E5%8B%95-a837f9392298"><strong>Argo CD ApplicationSet Controller: 世界為我而轉動！</strong><br><em>新推出的 Argo CD ApplicationSet Controller 讓使用者在單個 YAML 檔案內像是寫 For Loop 程式，隨需求一次性地建立大量的 Application CRD，就讓我們使用實際範例來看它如何解放…</em>medium.com</a></p><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><ul><li><a href="https://www.weave.works/technologies/gitops/">Guide To GitOps</a></li><li><a href="https://www.hwchiu.com/gitops.html">淺談 GitOps 的概念</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*4Ggl4UF7SjZk4qoapcDBnA.jpeg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;什麼是-GitOps&quot;&gt;&lt;a href=&quot;#什麼是-GitOps&quot; class=&quot;headerlink&quot; title=&quot;什麼是 GitOps ?&quot;&gt;&lt;/a&gt;什麼是 GitOps ?&lt;/h3&gt;&lt;p&gt;兩年前初次聽到 GitOps 的時候，我想說是不是只要 Git tag 觸發一些部屬相關的事情，像是下了某個 tag，就會觸發某 Ansible 的工作，部屬某一台伺服器。很遺憾，完全不是我想的那樣。&lt;/p&gt;
&lt;p&gt;在最近實際將 GitOps 整合進開發流程的過程中，深入研究了一下 GitOps。對 GitOps 有了多一點的了解，趁這個機會來跟大家分享一下。&lt;/p&gt;
&lt;p&gt;GitOps 是 Weaveworks 提出的一種持續交付(CD)的概念，透過 Git 來聲明基礎設施(infrastructure)希望的狀態。什麼是聲明基礎設施希望的狀態？&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>從 Github 開源指南｜學習如何貢獻開源專案</title>
    <link href="https://luka.tw/2020/08/15/2020-08-05-introduction-to-open-source-guild/"/>
    <id>https://luka.tw/2020/08/15/2020-08-05-introduction-to-open-source-guild/</id>
    <published>2020-08-15T12:50:00.000Z</published>
    <updated>2021-10-04T14:39:03.116Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/7872/0*8Mqb8j7gMZ3_R-UI" alt="Photo by [Tim Mossholder](https://unsplash.com/@timmossholder?utm_source=medium&amp;utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&amp;utm_medium=referral)"></p><p>本週我們來讀一下「如何為開源做貢獻」。這份文件是 Github 的 Open Source Guide 開源指南，約莫兩年前剛出的時候全部是英文版的，已經三年了，拖到現在才讀（汗）。</p><blockquote><p> （這篇是閱讀開源指南的筆記，原創內容偏少，原文在下方連結）<br><a href="https://opensource.guide/zh-hant/how-to-contribute/"><strong>如何為開源做貢獻？</strong><br><em>透過為開源貢獻力量，能從中學習、幫助他人並且從中累積相關技能的經驗 - 任何你能想像得到的技能。 為什麼會有人為開源做出貢獻？有數不清的原因！…</em>opensource.guide</a></p></blockquote><p>是 Github 7000 顆星星的開源專案<br><a href="https://github.com/github/opensource.guide"><strong>github/opensource.guide</strong><br><em>Open Source Guides ( https://opensource.guide/) are a collection of resources for individuals, communities, and…</em>github.com</a></p><h2 id="為何要貢獻開源專案？"><a href="#為何要貢獻開源專案？" class="headerlink" title="為何要貢獻開源專案？"></a><strong>為何要貢獻開源專案？</strong></h2><blockquote><p> 原文寫的很好，我用我的話說出來。</p></blockquote><h3 id="1-打磨你的專業技能"><a href="#1-打磨你的專業技能" class="headerlink" title="1. 打磨你的專業技能"></a>1. 打磨你的專業技能</h3><p>專案中包含了撰寫程式碼、平面設計、使用者體驗設計、撰寫文章 … 等等的工作。只要你想，你就可以在開源專案中找到你的位置。</p><h3 id="2-認識與你有相似興趣的人"><a href="#2-認識與你有相似興趣的人" class="headerlink" title="2. 認識與你有相似興趣的人"></a>2. 認識與你有相似興趣的人</h3><p>我覺得這真的滿重要，在現實生活中要找到相同興趣的人就很困難了，但是透過貢獻開源，你可以無遠弗屆的認識世界各地與你有相似興趣的人。</p><h3 id="3-鍛鍊溝通能力"><a href="#3-鍛鍊溝通能力" class="headerlink" title="3. 鍛鍊溝通能力"></a>3. 鍛鍊溝通能力</h3><p>因為開源專案是一個「共同協做」的專案。你需要向他人解釋自己是用什麼方法實作，也會需要其他人的幫助。</p><h3 id="4-建立名聲"><a href="#4-建立名聲" class="headerlink" title="4. 建立名聲"></a>4. 建立名聲</h3><p>你在開源專案中實作的成果一切都是看的到的，這也意味開源專案是一個能好好火力展示的地方。</p><h3 id="5-學習人際關係的能力"><a href="#5-學習人際關係的能力" class="headerlink" title="5. 學習人際關係的能力"></a>5. 學習人際關係的能力</h3><p>開源為練習領導及管理的能力提供了很好的機會。例如如何解決衝突、組織團隊以及如何為工作的優先順序排列。</p><blockquote><p> 小訣竅：走進開源專案，就像你走進一群陌生人中，想要嘗試融入。這群人討論的非常深入了，你突然打岔肯定會讓人覺得奇怪。<br> 與其盲目地在社群中拋出你自己的看法，不如先觀察一下社群的氛圍後再提出，這樣你的想法被注意到的機會才會增加。</p></blockquote><h2 id="找尋專案開始貢獻"><a href="#找尋專案開始貢獻" class="headerlink" title="找尋專案開始貢獻"></a>找尋專案開始貢獻</h2><p>如果你還未貢獻任何一個開源專案的話，可以想想，你能夠為開源專案做些什麼？</p><p>可以從你有使用過的開源專案開始著手，跟你比較有關係的開源專案，或是你比較感興趣的開源專案，你才會積極的參加。</p><p>平均一個專案有 28% 的貢獻是隨意且偶然的，像是 Readme、改錯字、失效連結 … 等等的小地方。</p><h2 id="找到專案時，先確保專案是否接受貢獻"><a href="#找到專案時，先確保專案是否接受貢獻" class="headerlink" title="找到專案時，先確保專案是否接受貢獻"></a><strong>找到專案時，先確保專案是否接受貢獻</strong></h2><p>可以從幾個地方，看出專案是否活躍，樂於接受貢獻：</p><p>從 Master 分支上看看觀察</p><ul><li><p>最近一次的 Commit 是什麼時候？</p></li><li><p>Commit 的次數頻繁嘛？</p></li><li><p>專案目前有多少貢獻者？</p></li></ul><p>從 Issue 觀察</p><ul><li><p>目前有多少個 issue</p></li><li><p>維護者回覆 issue 是否迅速</p></li><li><p>是否有討論熱絡的 issue</p></li><li><p>issue 是否已經大量累積</p></li><li><p>最近 close 的 issue 是多久以前</p></li></ul><p>從 PR 觀察</p><ul><li><p>有多少處於進行中的 PR</p></li><li><p>提交 PR 後維護者回覆是否迅速</p></li><li><p>最近有多少 PR 被 Merge</p></li></ul><p>觀察專案的友善程度</p><ul><li><p>維護者的回應是否有幫助</p></li><li><p>討論過程是否親切</p></li><li><p>會不會審查 PR</p></li></ul><h2 id="如何將成果貢獻至開源專案"><a href="#如何將成果貢獻至開源專案" class="headerlink" title="如何將成果貢獻至開源專案"></a>如何將成果貢獻至開源專案</h2><p>最重要的是「有效的溝通」，把握幾個要點：</p><h3 id="1-交代來龍去脈"><a href="#1-交代來龍去脈" class="headerlink" title="1. 交代來龍去脈"></a>1. 交代來龍去脈</h3><p>讓他人快速的理解。如果是 Bug 交代清楚你想做的事情是什麼，你當實作了哪些步驟，以便重現錯誤。如果你想要發起一個新的想法，你要解釋為什麼你要這樣做，為什麼你覺得這樣會對專案有幫助。</p><h3 id="2-做好準備工作"><a href="#2-做好準備工作" class="headerlink" title="2. 做好準備工作"></a>2. 做好準備工作</h3><p>在尋求幫助之前，先確保你看過文件、相關 Issue 的討論，當你表達出強烈的意願時，人們會很樂意幫助你的。</p><h3 id="3-溝通時力求精簡明瞭"><a href="#3-溝通時力求精簡明瞭" class="headerlink" title="3. 溝通時力求精簡明瞭"></a>3. 溝通時力求精簡明瞭</h3><p>開源專案每次提交都是需要他人檢閱的，如果你能夠精準的表達你的看法，那麼你得到別人幫助的機會就會大幅提昇。</p><h3 id="4-大膽的提問（但是要有耐心！）"><a href="#4-大膽的提問（但是要有耐心！）" class="headerlink" title="4. 大膽的提問（但是要有耐心！）"></a><strong>4. 大膽的提問（但是要有耐心！）</strong></h3><p>每個人都有新手的時候，不要怕提問。需要注意的是長期維護的人不一定熟悉專案的每一個部分。協作時表現出你的耐心，你會得到相同回報。</p><h3 id="5-尊重社群的決定"><a href="#5-尊重社群的決定" class="headerlink" title="5. 尊重社群的決定"></a>5. 尊重社群的決定</h3><p>有時候你的看法跟社群的看法不一定相同。他們可能不接受你的建議。可能社群最後不接納你的建議。這時你可以試試看討論出折衷方案，或者將專案 fork 另起爐灶。</p><h2 id="提交之後"><a href="#提交之後" class="headerlink" title="提交之後"></a>提交之後</h2><h3 id="😭有可能沒有人理你"><a href="#😭有可能沒有人理你" class="headerlink" title="😭有可能沒有人理你"></a>😭有可能沒有人理你</h3><p>因為大家都很忙，尤其是熱門的開源專案。Issue 很多，維護者的人手不夠，此時就先耐心的等待。</p><blockquote><p> <em>千萬不要私下聯絡，在開源專案中，一切的溝通都應該是公開的。</em></p></blockquote><h3 id="🚧有人希望你修改你的貢獻"><a href="#🚧有人希望你修改你的貢獻" class="headerlink" title="🚧有人希望你修改你的貢獻"></a>🚧有人希望你修改你的貢獻</h3><p>這是好的開始，溝通、改進直到符合維護者得期待。</p><h3 id="👎你的貢獻沒有被採納"><a href="#👎你的貢獻沒有被採納" class="headerlink" title="👎你的貢獻沒有被採納"></a>👎你的貢獻沒有被採納</h3><p>你的工作最後沒有被採納，這時你可以問問維護者，為什麼沒有被採納。需要注意的是別花時間在爭論上，這會讓你樹立更多敵人。</p><h3 id="🎉-你的貢獻被接受。"><a href="#🎉-你的貢獻被接受。" class="headerlink" title="🎉 你的貢獻被接受。"></a>🎉 你的貢獻被接受。</h3><p>太棒了！你完成了一次開源貢獻！</p><h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><ul><li><a href="https://opensource.guide/zh-hant/starting-a-project/"><strong>發起一個開源專案</strong></a></li><li><a href="https://opensource.guide/zh-hant/best-practices/"><strong>維護者最佳實踐</strong></a></li><li><a href="https://opensource.guide/zh-hant/leadership-and-governance/"><strong>領導與治理</strong></a></li><li><a href="https://opensource.guide/zh-hant/code-of-conduct/"><strong>建立一套行為準則</strong></a></li><li><a href="https://opensource.guide/zh-hant/finding-users/"><strong>找尋專案的使用者</strong></a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/7872/0*8Mqb8j7gMZ3_R-UI&quot; alt=&quot;Photo by [Tim Mossholder](https://unsplash.com/@timmossholder?utm_source=medium&amp;amp;utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&amp;amp;utm_medium=referral)&quot;&gt;&lt;/p&gt;
&lt;p&gt;本週我們來讀一下「如何為開源做貢獻」。這份文件是 Github 的 Open Source Guide 開源指南，約莫兩年前剛出的時候全部是英文版的，已經三年了，拖到現在才讀（汗）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; （這篇是閱讀開源指南的筆記，原創內容偏少，原文在下方連結）&lt;br&gt;&lt;a href=&quot;https://opensource.guide/zh-hant/how-to-contribute/&quot;&gt;&lt;strong&gt;如何為開源做貢獻？&lt;/strong&gt;&lt;br&gt;&lt;em&gt;透過為開源貢獻力量，能從中學習、幫助他人並且從中累積相關技能的經驗 - 任何你能想像得到的技能。 為什麼會有人為開源做出貢獻？有數不清的原因！…&lt;/em&gt;opensource.guide&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是 Github 7000 顆星星的開源專案&lt;br&gt;&lt;a href=&quot;https://github.com/github/opensource.guide&quot;&gt;&lt;strong&gt;github/opensource.guide&lt;/strong&gt;&lt;br&gt;&lt;em&gt;Open Source Guides ( https://opensource.guide/) are a collection of resources for individuals, communities, and…&lt;/em&gt;github.com&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;為何要貢獻開源專案？&quot;&gt;&lt;a href=&quot;#為何要貢獻開源專案？&quot; class=&quot;headerlink&quot; title=&quot;為何要貢獻開源專案？&quot;&gt;&lt;/a&gt;&lt;strong&gt;為何要貢獻開源專案？&lt;/strong&gt;&lt;/h2&gt;</summary>
    
    
    
    
    <category term="Github" scheme="https://luka.tw/tags/Github/"/>
    
    <category term="Open Source" scheme="https://luka.tw/tags/Open-Source/"/>
    
  </entry>
  
  <entry>
    <title>TLDR 命令列神兵｜Linux 入門必裝</title>
    <link href="https://luka.tw/2020/07/28/2020-07-28-tldr/"/>
    <id>https://luka.tw/2020/07/28/2020-07-28-tldr/</id>
    <published>2020-07-28T08:01:00.000Z</published>
    <updated>2021-10-04T14:02:14.844Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TL-DR-的意思是：哩供蝦？講重點好嘛？"><a href="#TL-DR-的意思是：哩供蝦？講重點好嘛？" class="headerlink" title="TL;DR 的意思是：哩供蝦？講重點好嘛？"></a>TL;DR 的意思是：哩供蝦？講重點好嘛？</h3><p><img src="https://cdn-images-1.medium.com/max/4000/0*UzoUjUPMJFmux31Z"></p><p>TLDR 能夠讓初學程式的新手 ，輕鬆了解命令列工具的各種 Linux 指令，並且自由運用。本篇文章分成幾個兩個部分：</p><ul><li><p>命令列工具 Command line tool 到底是什麼東西？</p></li><li><p>TLDR 是什麼東西？它如何幫助我們快速適應 Linux 命令列工具？</p></li></ul><p>話不多說，我們開始吧。</p><h2 id="命令列工具-Command-line-tool-到底是什麼？"><a href="#命令列工具-Command-line-tool-到底是什麼？" class="headerlink" title="命令列工具 Command line tool 到底是什麼？"></a>命令列工具 Command line tool 到底是什麼？</h2><p>命令列工具的英文是 Command Line Tool。下圖就是常見的命令列工具。那麼他的作用是什麼呢？</p><p><img src="https://cdn-images-1.medium.com/max/2728/0*SpNBj5mNjdNKxJoh.png" alt="source: [http://www.blogjava.net/xiaomage234/archive/2016/04/06/429988.html](http://www.blogjava.net/xiaomage234/archive/2016/04/06/429988.html)"></p><blockquote><p> 命令列工具的作用是「透過下指令的方式來做到你想做的事情」</p></blockquote><p>這是什麼意思？為什麼要透過下指令的方式讓做事？原因是：</p><blockquote><p> 用命令列工具的來做事情非常有效率。</p></blockquote><p>試想如果你想要安裝一個知名影音播放軟體 VLC，你會做些什麼事情？首先你會 Google，開幾個網頁，看看哪個載點比較值得信賴，然後選一個覺得不錯的下載，等到下載完成之後再安裝。</p><p>哪麼換成命令列工具呢，只要下一行指令即可</p><pre><code>brew cask install vlc</code></pre><p>來看看會發生什麼事情？</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*BCtzem0SRoWkPqgmnD2CTA.png"></p><p>VLC 已經裝好了，終端機顯示 VLC 安裝在 /Applications/VLC.app。接著我們打開 /Application 資料夾，VLC 已經安裝好了。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*ZL62K8u1qBANq5qvGu5hVg.png"></p><p>也許你覺得用手動點擊也可以幫你做到同樣的事情，但是當這種有效率的小動作逐步累積的時候，就會造成效率上的極大差異。別人用 15 分鐘做好的事情你可能需要花一個小時。隨著做的事情越複雜效率的差異會越大。</p><blockquote><h1 id="命令列工具那麼好用？-那到底要怎麼用？"><a href="#命令列工具那麼好用？-那到底要怎麼用？" class="headerlink" title="命令列工具那麼好用？ 那到底要怎麼用？"></a>命令列工具那麼好用？ 那到底要怎麼用？</h1><h1 id="tldr-就是告訴我們各種-Linux-指令怎麼用的工具。"><a href="#tldr-就是告訴我們各種-Linux-指令怎麼用的工具。" class="headerlink" title="tldr 就是告訴我們各種 Linux 指令怎麼用的工具。"></a>tldr 就是告訴我們各種 Linux 指令怎麼用的工具。</h1></blockquote><h2 id="TLDR-登場，看看它如何大發神威"><a href="#TLDR-登場，看看它如何大發神威" class="headerlink" title="TLDR 登場，看看它如何大發神威"></a>TLDR 登場，看看它如何大發神威</h2><p>這下子就輪到我們的主角登場啦，TLDR！TLDR 能夠用最簡短的方式告訴你各種指令的用法。</p><p>TL;DR 是 too long; didn’t read 的縮寫，初學 Linux 的時候一堆指令的縮寫有夠難懂，什麼 ls、pwd、mv … 諸如此類的指令。當你不懂的時候怎麼辦？用 TLDR 就對了！</p><p>來示範一下怎麼用，假設我們不知道 ls 指令怎麼使用。想破頭也不知道 ls 指令到底用來幹嘛的？ 輸入 tldr ls 立刻了解 ls 如何使用。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*tvVThnRqBgBo-yhGebG62g.png"></p><p>從上圖中的第一行就告訴你，ls 的功用是列出目前資料夾的內容。如果你需要更多的用法，可以參照 tldr 幫你精選出來的各種常用指令。<strong>TLDR 絕對不完整，但是很容易上手！</strong></p><p>另一種對比的 Linux 完整文件的指令是 man，在終端機輸入 man ls ，呈現的樣子如下圖，落落長，跟 TLDR 完全相反，保證完整，但要看很久。我們常常只是要用 Linux 指令做一些簡單的事情，所以並不需要看的那麼仔細。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*nGYQ67CJakspwFZkrsaX3w.png"></p><p>再來試試看 pwd，可以很清楚的看到 pwd的功用是印出目前工作的目錄。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*F3QTTv-8uiohS8hvHr7cMg.png"></p><p>然後你再輸入一次 pwd，就可以很清楚的知道「顯示出來的內容是目前的工作目錄」</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*uwhc7FNdVPZTmBPQXWVe0A.png"></p><h2 id="TLDR-如何安裝？"><a href="#TLDR-如何安裝？" class="headerlink" title="TLDR 如何安裝？"></a>TLDR 如何安裝？</h2><p>既然是新手教學文，最後我們就來講一下怎麼安裝</p><pre><code>npm install -g tldr</code></pre><p>一行指令搞定，就是這麼輕鬆寫意。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>TLDR 的出現，讓我除了<a href="http://linux.vbird.org/">鳥哥的Linux 私房菜</a>以外多了一個認識 Linux 指令的管道。更有趣的它是一個開源專案，如果用 tldr 某某指令 找不到結果，你還可以自行貢獻自己的小抄，讓世界上的其他人用得到。對於新手來講是一個滿好入門的工具。</p><p>如果覺得我的文章對你有幫助 ，<a href="https://medium.com/@LukaTW">來 follow 我吧</a>！最近我會常寫文的呦。<br>也別忘了 follow 星巴哥技術週刊，每週推送優質原創文章！</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;TL-DR-的意思是：哩供蝦？講重點好嘛？&quot;&gt;&lt;a href=&quot;#TL-DR-的意思是：哩供蝦？講重點好嘛？&quot; class=&quot;headerlink&quot; title=&quot;TL;DR 的意思是：哩供蝦？講重點好嘛？&quot;&gt;&lt;/a&gt;TL;DR 的意思是：哩供蝦？講重點好嘛？&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/4000/0*UzoUjUPMJFmux31Z&quot;&gt;&lt;/p&gt;
&lt;p&gt;TLDR 能夠讓初學程式的新手 ，輕鬆了解命令列工具的各種 Linux 指令，並且自由運用。本篇文章分成幾個兩個部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;命令列工具 Command line tool 到底是什麼東西？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;TLDR 是什麼東西？它如何幫助我們快速適應 Linux 命令列工具？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;話不多說，我們開始吧。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Kubernetes IDE | Lens 用圖形化介面管理 K8S</title>
    <link href="https://luka.tw/2020/06/30/2020-06-30-lens-the-ide-for-kubernetes/"/>
    <id>https://luka.tw/2020/06/30/2020-06-30-lens-the-ide-for-kubernetes/</id>
    <published>2020-06-30T09:01:00.000Z</published>
    <updated>2021-10-04T14:02:10.908Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/2400/0*P3QeV7d9iPBNeOCr.png" alt="https://k8slens.dev"></p><p>以往我們在管理 Kubernetes 集群的時候，需要大量的命令列操作，需要去四處找尋需要的資訊，例如你想看 Node 的狀態你可能需要在 AWS Console 上面看，如果你用的是 GKE 的話你就需要到的 GCP 的後台上看。你想要進入 Pod 你需要先下 kubectl get pods取得 pod 列表，接著再下 kubectl exec -it pod/xxxpod – bash 進入。</p><p>這些功能現在 Lens 全部幫你整合進去了。它能夠讓你快速的瀏覽你的 K8S 集群狀況，並且即時反應 K8S 集群的狀態讓你可以做相對應的反應。我們就來看看 Lens 有哪些殺手級的功能吧！</p><h2 id="Lens-有哪些殺手級功能"><a href="#Lens-有哪些殺手級功能" class="headerlink" title="Lens 有哪些殺手級功能"></a>Lens 有哪些殺手級功能</h2><h2 id="1-實時監控-pod-的狀態-realtime-monitoring"><a href="#1-實時監控-pod-的狀態-realtime-monitoring" class="headerlink" title="1. 實時監控 pod 的狀態 (realtime monitoring)"></a>1. 實時監控 pod 的狀態 (realtime monitoring)</h2><p>可以實時監控 pod 的狀態，不需要手動刷新，這個功能我覺得滿方便的。一般來說你想要重複獲取 pod 的狀態需要在終端機中輸入 kubectl get pods，用終端機下指令的方式只能知道下指令的「當下的狀態」，如果你想要獲得你想要的狀態，你必須不斷下指令。而現在使用 Lens 你只需要瞄一下螢幕，就可以知道 pod 就緒了沒，因為 Lens 會告訴你最即時的 Pod 狀態。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*ce7US7IAR0EPDvYlQIrhBQ.png" alt="為了不透漏機密資訊我使用 Lens 官方網站的圖片 ([https://k8slens.dev/](https://k8slens.dev/))"></p><h2 id="2-快速查看-Pod-的-CPU-、記憶體用量"><a href="#2-快速查看-Pod-的-CPU-、記憶體用量" class="headerlink" title="2. 快速查看 Pod 的 CPU 、記憶體用量"></a>2. 快速查看 Pod 的 CPU 、記憶體用量</h2><p>我覺得這是令人滿驚艷的功能，Newrelic 針對 K8S 推出的監控工具操作起來都沒有那麼直覺。因此目前的監控方案用 Newrelic 來看吞吐量與 request 的消耗時間，方便做一些效能調校。而觀看 Kubernetes 整體的狀態則是使用 Lens 為主。能夠快速找到想要的資訊並能夠反應實時(realtime)的狀態真的挺重要。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*Jv4voRbrXD7vFogoFwBskg.png" alt="image from [https://k8slens.dev/](https://k8slens.dev/)"></p><h2 id="3-快速觀看-Node-的狀態"><a href="#3-快速觀看-Node-的狀態" class="headerlink" title="3. 快速觀看 Node 的狀態"></a>3. 快速觀看 Node 的狀態</h2><p>Pod 是 Kubernetes 中的最小單位，但最後他還是會跑在某一台實體機器，也就是 Node 上面，所以我們可以快速的看到 Node 的狀態也是很重要的。</p><p>沒錯，Lens 就是那麼的威，可以快速的看到 K8S 中 Node 的 CPU、記憶體用量，還有 Node 上跑了哪些 Pod，運行了哪些資源。</p><p>我覺得根本整合度極高。偏愛用終端機的我，目前也離不開 Lens 的方便。</p><p><img src="https://cdn-images-1.medium.com/max/3340/1*XGv9gmMz73ZKZjw_bEb_ww.png"></p><h2 id="4-Event-列表，能夠即時知道-K8S-集群發生了什麼事"><a href="#4-Event-列表，能夠即時知道-K8S-集群發生了什麼事" class="headerlink" title="4. Event 列表，能夠即時知道 K8S 集群發生了什麼事"></a>4. Event 列表，能夠即時知道 K8S 集群發生了什麼事</h2><p>例如：一個 pod 中的 readiness probe 告訴你：你的 pod 還沒有準備好啦！Lens 就有這個功能，可以即時知道 K8S Cluster 的事件。不然很有可能 Kubernetes 發生了一些事情，但是你沒有察覺。</p><h2 id="5-Pod-gt-Terminal-一鍵搞定"><a href="#5-Pod-gt-Terminal-一鍵搞定" class="headerlink" title="5. Pod -&gt; Terminal 一鍵搞定"></a>5. Pod -&gt; Terminal 一鍵搞定</h2><p>平常要進入某 Pod 的時候先 k get pods，然後複製貼上 pod 的名稱，輸入 k exec -it pod/your-pod-name – /bin/bash 每次做真的有點煩。Lens 直接列出所有 Pod，你只需要點選有問題的 Pod，或是你想要進去的 Pod，點擊終端機鍵，即可連進 Pod 裡面。真～是～太～方～便～啦～！</p><p><img src="https://cdn-images-1.medium.com/max/2790/1*yGkNYU4kdqJ85C7u-Aq0Og.png"></p><h2 id="為什麼-Kubernetes-能夠有一款-IDE？"><a href="#為什麼-Kubernetes-能夠有一款-IDE？" class="headerlink" title="為什麼 Kubernetes 能夠有一款 IDE？"></a>為什麼 Kubernetes 能夠有一款 IDE？</h2><p>最後來聊一聊為什麼 Kubernetes 能夠出一款 IDE？一般來說 IDE 是基於語言設計出的 IDE，例如：java 有 Eclipse，c# 有 visual studio，Python 有 Pycharm，PHP 有 Phpstorm… 等等。</p><p>這些以語言為基礎的 IDE 可以提供語言為基礎的一些好用方法。例如方法的自動完成、原始碼的快速查找，或是提取方法、提取參數 … 等等重構的功能。基於每個語言的特性，IDE 提供不同的特性。</p><p>Kubernetes 的 IDE 是怎麼回事呢？各家提供雲服務的平台紛紛推出相對應 K8S 的服務。例如：Google 有 GKE，AWS 有 EKS，或是也可以自行架設 Kubernetes 集群。</p><p>這些 Kubernetes 服務都遵循著相同的 Kubernetes 規範，聽起來好像有點繞，如果不是因為有 Kubernetes 這樣明確的規範，就不可能有 IDE 產生。</p><p>例如：Google 的雲端平台 GCP 上如果你想要開機器，跟 AWS 平台上你想要開機器，那麼你是無法用一套 IDE 來監控或是控制兩者的機器狀態的。因為 Google 和 AWS 機器呼叫的規格各自有各自的定義，無法共通。</p><p>而 Kubernetes 大家都是透過 kubectl 來跟 Kubenetes Control Panel 溝通。Kubenetes 中的元件，例如：Pod、Service、Deployment … 等等，在各家雲服務商也都是遵照相同規範實作，因此可以使用一款 IDE，就能夠監控各家的 Kubernetes 集群。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a><strong>結語</strong></h2><p>Lens 的出現讓我用最少的力氣就可以快速的看到想看的資訊。而 Newrelic 的方式比較像是以往的 APM 的監控法。跟以前只有機器的時代，多了一層 Kubernetes 多了滿多思考點。另外警報(Alert)又是另一套系統了。如何在問題出現的時候，快速定位問題，在使用者察覺前解決掉，是一個有趣的挑戰。</p><blockquote><p> 最後不免俗的感謝大家觀看，喜歡我的文章請訂閱 Starbugs 星巴哥技術專欄，每週推送原創好文😀😀😀</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2400/0*P3QeV7d9iPBNeOCr.png&quot; alt=&quot;https://k8slens.dev&quot;&gt;&lt;/p&gt;
&lt;p&gt;以往我們在管理 Kubernetes 集群的時候，需要大量的命令列操作，需要去四處找尋需要的資訊，例如你想看 Node 的狀態你可能需要在 AWS Console 上面看，如果你用的是 GKE 的話你就需要到的 GCP 的後台上看。你想要進入 Pod 你需要先下 kubectl get pods取得 pod 列表，接著再下 kubectl exec -it pod/xxxpod – bash 進入。&lt;/p&gt;
&lt;p&gt;這些功能現在 Lens 全部幫你整合進去了。它能夠讓你快速的瀏覽你的 K8S 集群狀況，並且即時反應 K8S 集群的狀態讓你可以做相對應的反應。我們就來看看 Lens 有哪些殺手級的功能吧！&lt;/p&gt;
&lt;h2 id=&quot;Lens-有哪些殺手級功能&quot;&gt;&lt;a href=&quot;#Lens-有哪些殺手級功能&quot; class=&quot;headerlink&quot; title=&quot;Lens 有哪些殺手級功能&quot;&gt;&lt;/a&gt;Lens 有哪些殺手級功能&lt;/h2&gt;&lt;h2 id=&quot;1-實時監控-pod-的狀態-realtime-monitoring&quot;&gt;&lt;a href=&quot;#1-實時監控-pod-的狀態-realtime-monitoring&quot; class=&quot;headerlink&quot; title=&quot;1. 實時監控 pod 的狀態 (realtime monitoring)&quot;&gt;&lt;/a&gt;1. 實時監控 pod 的狀態 (realtime monitoring)&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>TPM — 套件管理工具 ，讓你的 TMUX 更好用</title>
    <link href="https://luka.tw/2020/06/02/2020-06-02-tmp-let-your-tmux-better/"/>
    <id>https://luka.tw/2020/06/02/2020-06-02-tmp-let-your-tmux-better/</id>
    <published>2020-06-02T11:51:00.000Z</published>
    <updated>2021-10-04T15:34:57.624Z</updated>
    
    <content type="html"><![CDATA[<p>最近因為工作上需要用到開很多個視窗的情景，研究了一下如何把 tmux 變得更具有生產力。</p><p><img src="https://cdn-images-1.medium.com/max/2000/0*wJrJdR3tFO84Tdsd.jpg"></p><h2 id="tmux-是什麼？"><a href="#tmux-是什麼？" class="headerlink" title="tmux 是什麼？"></a>tmux 是什麼？</h2><p><a href="https://github.com/tmux/tmux">tmux</a> 是一個很好用的遠端 session 管理套件，兼具效能與功能性，可以讓你在遠端伺服器中，輕易管理背景執行程式。</p><p>Larry 在 **<a href="https://larrylu.blog/tmux-33a24e595fbc">終端機 session 管理神器 — tmux</a> **文章中介紹了基本的概念、使用方式與經典的使用情景。如果沒有看過的話，請看文章了解一下。<br><a href="https://larrylu.blog/tmux-33a24e595fbc"><strong>終端機 session 管理神器 — tmux</strong><br><em>身為一名開發者對終端機應該不陌生，不管是要執行腳本、ssh 到遠端伺服器都會用到終端機。<br>這邊要介紹給大家一個工具 tmux，tmux 是個 terminal multiplexer，可以讓你的終端機更好用</em>larrylu.blog</a><a href="https://larrylu.blog/tmux-33a24e595fbc">t</a></p><p>不過其實不看也沒什麼關係啦，看我寫得就好<em>。</em></p><h2 id="Hello-tpm"><a href="#Hello-tpm" class="headerlink" title="Hello, tpm"></a>Hello, tpm</h2><p><a href="https://github.com/tmux-plugins/tpm">tpm</a> 是 tmux 的套件管理工具，英文是 Tmux Plugin Manager。tmux 之於 tpm 就如同是 nodejs 之於 npm。是一個在 github 上面有 6100 顆星星的開源專案。</p><p>今天我的重點放在 tpm 的介紹上，如果還沒安裝 tmux，請按照 **<a href="https://larrylu.blog/tmux-33a24e595fbc">終端機 session 管理神器 — tmux</a> **文章中的教學逐步安裝並學習使用方法。</p><p>回過頭來，我們想要用 tpm 來安裝一些好用的套件，先安裝好 tpm。 首先 git clone tpm 至本機。</p><pre><code>git clone [https://github.com/tmux-plugins/tpm](https://github.com/tmux-plugins/tpm) ~/.tmux/plugins/tpm</code></pre><p>接著修改 ~/.tmux.conf 檔案的內容，將下列內容複製貼上至檔案中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># List of plugins</span><br><span class="hljs-built_in">set</span> -g @plugin <span class="hljs-string">&#x27;tmux-plugins/tpm&#x27;</span><br><span class="hljs-built_in">set</span> -g @plugin <span class="hljs-string">&#x27;tmux-plugins/tmux-sensible&#x27;</span><br><br><span class="hljs-comment"># Other examples:</span><br><span class="hljs-comment"># set -g @plugin &#x27;github_username/plugin_name&#x27;</span><br><span class="hljs-comment"># set -g @plugin &#x27;git@github.com/user/plugin&#x27;</span><br><span class="hljs-comment"># set -g @plugin &#x27;git@bitbucket.com/user/plugin&#x27;</span><br><br><span class="hljs-comment"># Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)</span><br>run -b <span class="hljs-string">&#x27;~/.tmux/plugins/tpm/tpm&#x27;</span><br></code></pre></td></tr></table></figure><p>安裝完成後在終端機中輸入下列指令或是重開終端機即可載入完成。</p><pre><code>tmux source ~/.tmux.conf</code></pre><h2 id="要怎麼使用-tpm-安裝-tmux-套件"><a href="#要怎麼使用-tpm-安裝-tmux-套件" class="headerlink" title="要怎麼使用 tpm 安裝 tmux 套件"></a>要怎麼使用 tpm 安裝 tmux 套件</h2><p>安裝 tpm 套件可能跟你想的不太一樣，直接修改 ~/.tmux.conf 檔案的內容，並且重啟。例如你想要安裝 <a href="https://github.com/tmux-plugins/tmux-copycat">tmux-copycat</a>。</p><pre><code>vim ~/.tmux.conf</code></pre><p>加入這一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> -g @plugin <span class="hljs-string">&#x27;tmux-plugins/tmux-copycat&#x27;</span><br></code></pre></td></tr></table></figure><p>接著，重開 tmux session 或是在 tmux 中輸入 prefix (ctrl+b) + I 即可。</p><h2 id="ctrl-b-有點遠，修改-prefix-為-ctrl-a"><a href="#ctrl-b-有點遠，修改-prefix-為-ctrl-a" class="headerlink" title="ctrl+b 有點遠，修改 prefix 為 ctrl + a"></a>ctrl+b 有點遠，修改 prefix 為 ctrl + a</h2><p>tmux 大部分的指令是由組合鍵 prefix + 某某鍵所構成。 prefix 預設是 ctrl + b，外國鄉民大多是將 prefix 修改成 ctrl + a ，你也可以設成你喜歡的樣子，設定方法很簡單。在 .tmux.conf 中加上以下內容即可將 prefix 變成ctrl + a。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># remap prefix from &#x27;C-b&#x27; to &#x27;C-a&#x27;</span><br>unbind C-b<br>set-option -g prefix C-a<br>bind-key C-a send-prefix<br></code></pre></td></tr></table></figure><h2 id="介紹幾個好用的套件"><a href="#介紹幾個好用的套件" class="headerlink" title="介紹幾個好用的套件"></a>介紹幾個好用的套件</h2><h3 id="tmux-yank"><a href="#tmux-yank" class="headerlink" title="tmux-yank"></a><a href="https://github.com/tmux-plugins/tmux-yank">tmux-yank</a></h3><p>讓你的 tmux 可以用系統的剪貼簿，支援 osx, linux, WSL(Windows Subsystem for Linux) … 等等的環境。</p><h3 id="tmux-pain-control"><a href="#tmux-pain-control" class="headerlink" title="tmux-pain-control"></a><a href="https://github.com/tmux-plugins/tmux-pain-control">tmux-pain-control</a></h3><p>這個套件有三大功能，第一是切割視窗，第二是在視窗中跳躍，第三是縮放視窗大小。</p><h3 id="讓切割視窗變得更加簡單"><a href="#讓切割視窗變得更加簡單" class="headerlink" title="讓切割視窗變得更加簡單"></a>讓切割視窗變得更加簡單</h3><p>這兩個是 tmux 預設的切割視窗快捷鍵</p><ol><li><p>prefix + “：進行<strong>水平</strong>分割</p></li><li><p>prefix + %：進行<strong>垂直</strong>分割</p></li></ol><p>這兩個符號我一直記不起來😭，但是在使用<a href="https://github.com/tmux-plugins/tmux-pain-control">tmux-pain-control</a> 之後：</p><ol><li><p>prefix + |：進行<strong>水平</strong>分割</p></li><li><p>prefix + -：進行<strong>垂直</strong>分割</p></li></ol><p>圖型記憶法，真是太好記了。連續技用起來會有這樣的效果：</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*P3MQZDaihxlpHZwBNTvdpQ.gif"></p><h3 id="用-vim-的方向鍵跳轉視窗"><a href="#用-vim-的方向鍵跳轉視窗" class="headerlink" title="用 vim 的方向鍵跳轉視窗"></a>用 vim 的方向鍵跳轉視窗</h3><ol><li><p>prefix + h：往左跳</p></li><li><p>prefix + j：往上跳</p></li><li><p>prefix + k：往下跳</p></li><li><p>prefix + l：往右跳</p></li></ol><p><img src="https://cdn-images-1.medium.com/max/2000/1*F-mk4CsL1oh36EDK_cRr0g.gif"></p><h3 id="用-vim-的方向鍵縮放視窗"><a href="#用-vim-的方向鍵縮放視窗" class="headerlink" title="用 vim 的方向鍵縮放視窗"></a>用 vim 的方向鍵縮放視窗</h3><ol><li><p>prefix + shift + h：視窗邊界往左移</p></li><li><p>prefix + shift + j：視窗邊界往上移</p></li><li><p>prefix + shift + k：視窗邊界往下移</p></li><li><p>prefix + shift + l：視窗邊界往右移</p></li></ol><p><img src="https://cdn-images-1.medium.com/max/2000/1*lv0mJUFUVHmxCZMPuctZRg.gif"></p><h3 id="tmux-copycat"><a href="#tmux-copycat" class="headerlink" title="tmux copycat"></a><a href="https://github.com/tmux-plugins/tmux-copycat">tmux copycat</a></h3><p>tmux copycat 可以讓你不使用滑鼠就能夠複製文字。這個套件非常好用，礙於時間不夠無法錄製完整操作。殘念。</p><h3 id="tmux-resurrect"><a href="#tmux-resurrect" class="headerlink" title="tmux-resurrect"></a><a href="https://github.com/tmux-plugins/tmux-resurrect">tmux-resurrect</a></h3><p>讓系統重啟的時候保持 tmux 的設定。</p><h3 id="tmux-open"><a href="#tmux-open" class="headerlink" title="tmux-open"></a><a href="https://github.com/tmux-plugins/tmux-open">tmux-open</a></h3><p>能夠讓你快速的打開你選取到的文字對應的超連結或是檔案。</p><h3 id="tmux-prefix-highlight"><a href="#tmux-prefix-highlight" class="headerlink" title="tmux-prefix-highlight"></a><a href="https://github.com/tmux-plugins/tmux-prefix-highlight">tmux-prefix-highlight</a></h3><p>讓你知道你有沒有成功觸發 prefix，如果按成功了，在下方顯示列會有成功觸發的圖案。</p><h3 id="tmux-continuum"><a href="#tmux-continuum" class="headerlink" title="tmux-continuum"></a><a href="https://github.com/tmux-plugins/tmux-continuum">tmux-continuum</a></h3><p>持續幫你儲存 tmux 的設定。</p><h3 id="tmux-sensible"><a href="#tmux-sensible" class="headerlink" title="tmux-sensible"></a><a href="https://github.com/tmux-plugins/tmux-sensible">tmux-sensible</a></h3><p>讓 tmux 比較合乎邏輯，不然 tmux 有些預設的設定實在是有點難用，這是必備的 tmux 套件。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>有了 tpm 可以輕鬆安裝好用套件，這讓 tmux 平易進人多了，操作上不再需要記憶太多奇怪的快捷鍵。就可以讓生產力獲得大幅的提升，真滴好。</p><h2 id="參考資源"><a href="#參考資源" class="headerlink" title="參考資源"></a>參考資源</h2><ul><li><p><a href="https://www.hamvocke.com/blog/a-guide-to-customizing-your-tmux-conf/">Making tmux Pretty and Usable — A Guide to Customizing your tmux.conf</a></p></li><li><p><a href="https://medium.com/actualize-network/a-minimalist-guide-to-tmux-13675fb160fa">A minimalist guide to tmux</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近因為工作上需要用到開很多個視窗的情景，研究了一下如何把 tmux 變得更具有生產力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/0*wJrJdR3tFO84Tdsd.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;tmux-是什麼？&quot;&gt;&lt;a href=&quot;#tmux-是什麼？&quot; class=&quot;headerlink&quot; title=&quot;tmux 是什麼？&quot;&gt;&lt;/a&gt;tmux 是什麼？&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/tmux/tmux&quot;&gt;tmux&lt;/a&gt; 是一個很好用的遠端 session 管理套件，兼具效能與功能性，可以讓你在遠端伺服器中，輕易管理背景執行程式。&lt;/p&gt;
&lt;p&gt;Larry 在 **&lt;a href=&quot;https://larrylu.blog/tmux-33a24e595fbc&quot;&gt;終端機 session 管理神器 — tmux&lt;/a&gt; **文章中介紹了基本的概念、使用方式與經典的使用情景。如果沒有看過的話，請看文章了解一下。&lt;br&gt;&lt;a href=&quot;https://larrylu.blog/tmux-33a24e595fbc&quot;&gt;&lt;strong&gt;終端機 session 管理神器 — tmux&lt;/strong&gt;&lt;br&gt;&lt;em&gt;身為一名開發者對終端機應該不陌生，不管是要執行腳本、ssh 到遠端伺服器都會用到終端機。&lt;br&gt;這邊要介紹給大家一個工具 tmux，tmux 是個 terminal multiplexer，可以讓你的終端機更好用&lt;/em&gt;larrylu.blog&lt;/a&gt;&lt;a href=&quot;https://larrylu.blog/tmux-33a24e595fbc&quot;&gt;t&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Unit Test 中的替身：搞不清楚的Dummy 、Stub、Spy、Mock、Fake</title>
    <link href="https://luka.tw/2020/05/05/2020-05-05-unit-test/"/>
    <id>https://luka.tw/2020/05/05/2020-05-05-unit-test/</id>
    <published>2020-05-05T11:50:00.000Z</published>
    <updated>2021-10-04T14:00:59.255Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/2000/0*Xn1CY4WKjOu3AdhL.jpeg"></p><p>最近開始接觸單元測試，一堆名詞看不懂，來狠狠地 K 一下。而單元測試中的最佳男配角，就是替身 Double。藉由寫一篇文章的方式來讓自己更了解單元測試中的重要部分。一起來學寫測試，Go Go !!</p><blockquote><p> <em>註：接觸時間還很短，有錯還請不吝指正，如果之後發現我有理解錯誤再回來更正。</em></p></blockquote><h2 id="單元測試是什麼？"><a href="#單元測試是什麼？" class="headerlink" title="單元測試是什麼？"></a>單元測試是什麼？</h2><p>單元測試可以讓你快速驗證程式的行為。了解單元測的話首先來介紹一下 SUT 目標對象。</p><p>舉個例子：你想要測試一台車是不是可以開，那麼 SUT 目標對象就是這台車。</p><p>為了確保這台車可以開，那麼就可以寫一個「這台車應該要可以開」的測試。如果這台車發生了故障，測試就會告訴你，這台車是壞掉的。</p><p>單元測試讓你的程式更容易維護。原因在於你能夠對程式寫測試，代表你寫的程式的「使用說明書」清楚易懂。使用說明書很容易懂，就可以直接拿來用，減少重複的程式碼，符合 DRY (Don’t Repeat Yourself) 原則。</p><p>寫程式最大的成本在於維護，寫很簡單，但是要維護可就是個不容易的事情了。為了降低維護的成本，導入單元測試可以大大降低出錯的可能性，並且快樂地重構。</p><h2 id="替身是什麼？"><a href="#替身是什麼？" class="headerlink" title="替身是什麼？"></a>替身是什麼？</h2><p>下圖是火影忍者的替身之術，替身之術的原理是：當敵人對你發動攻擊時，你使用替身之術，就可以讓替身承受敵人的攻擊，而自己不會受到傷害。圖中的木頭就是呼叫替身之術後，用來承受敵人攻擊的替身。</p><p><img src="https://cdn-images-1.medium.com/max/2000/0*j4xWCtfCJnjEpjvR.png"></p><p>所以火影忍者替身之術跟 Unit Test 的替身有什麼關係？你在程式中使出替身之術的時候，替身 Double 就會出現在你的程式裡面了。</p><h2 id="為什麼要在程式中使用替身-Double-呢？"><a href="#為什麼要在程式中使用替身-Double-呢？" class="headerlink" title="為什麼要在程式中使用替身 Double 呢？"></a>為什麼要在程式中使用替身 Double 呢？</h2><p>原因在於你想要測試的 SUT 目標對象通常會有很多「依賴」DOC。一樣舉個例子：剛剛的 SUT 目標對象是「一台車」很容易寫測試，只要測試這台車可以開就好。</p><p>但是如果一台車停在停車場，然後又爆胎。或是一台車掉到海裡。這些情況，一台車的 DOC 依賴變多了，造成你的測試更加複雜，越多的 DOC 依賴會造成你的測試越難寫，也造成你的程式行為更加複雜，難以預測。</p><p>那麼就進入正題來介紹測試中的幾種替身吧</p><h2 id="測試中的五種替身"><a href="#測試中的五種替身" class="headerlink" title="測試中的五種替身"></a>測試中的五種替身</h2><p>測試中的 Double 替身分為五種：Dummy Object、Test Stub、Test Spy、Mock Object、Fake Object。先來介紹第一種 Dummy Object 冒牌貨</p><h2 id="Dummy-Object"><a href="#Dummy-Object" class="headerlink" title="Dummy Object"></a>Dummy Object</h2><p>Dummy Object 英文直譯冒牌貨，顧名思義就是個冒牌貨。他的用途是用來填充 SUT 目標測試對象中需要的物件。而 Dummy 不會對 SUT 測試目標造成任何的影響。純粹的填充物件，讓測試程式能夠運行。</p><h2 id="Test-Stub"><a href="#Test-Stub" class="headerlink" title="Test Stub"></a>Test Stub</h2><p>我們想要驗證的 SUT 回傳值，這時候 Stub 就可以派上用場啦。聽起來有點玄，一樣舉個例子：例如：現在我們的測試目標 SUT 是一個手電桶，我們想要驗證呼叫打開 on 方法的結果，而一個手電筒裡面需要裝電池，電池可能會沒電，但是我不想讓電池沒電這個因素影響我的測試。所以我做了一組替身電池 (Stub Object) 塞進這個手電筒裡面。讓我可以輕鬆驗證 SUT 的回傳值。</p><pre><code>class Flashlight  attr :battery    def initialize(battery)    @battery = battery  end    def on    battery.have_energy? ? &#39;flashlight is turn on!&#39; : &#39;no energy&#39;  endendFlashlight.new(StubBattery.new).on # 電池有沒有電不會影響結果。</code></pre><h2 id="Test-Spy"><a href="#Test-Spy" class="headerlink" title="Test Spy"></a>Test Spy</h2><p>Spy 用來驗證 SUT 與對其他 DOC 物件造成的效果，例如：今天阿牛去找朋友聊天的時候，朋友物件內部的聊天次數就會加一，而當我們想想要驗證朋友物件的聊天次數是不是如我們所預期的增長時，我們就可以派出間諜朋友，來驗證「 SUT 阿牛是否有跟朋友聊三次天」之類的期待。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> 阿牛  </span><br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(friend)</span></span><br>    <span class="hljs-variable">@friend</span> = friend<br>  <span class="hljs-keyword">end</span>  <br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">chat_to_friends</span></span><br>    friend.chat!<br>  <span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">end</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Friend</span> </span><br>  <span class="hljs-symbol">attr:</span> chat_count  <br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">chat</span></span><br>    <span class="hljs-variable">@chat_count</span> <span class="hljs-params">||</span>= <span class="hljs-number">0</span><br>    <span class="hljs-variable">@chat_count</span> += <span class="hljs-number">1</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br>cow = 阿牛.new(spy_friend)<br><br>cow.chat_to_friends<br>cow.chat_to_friends<br>cow.chat_to_friends<br><br>expect(spy_friend.chat_count).to eq(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h2 id="Mock-Object"><a href="#Mock-Object" class="headerlink" title="Mock Object"></a>Mock Object</h2><p>Mock 是一個能夠判斷 SUT 是不是有正確使用 DOC 的替身。Mock 跟 Spy 的最大差別是，Mock 用來驗證 SUT 的行為，而 Spy 用來驗證 SUT 對 DOC 狀態的改變。</p><h2 id="Fake-Object"><a href="#Fake-Object" class="headerlink" title="Fake Object"></a>Fake Object</h2><p>Fake Object 假物件是一個簡化的 DOC (依賴元件)，例如：一台真實的飛機有很多零件，但是我們其實只需要他有外殼，並且可以飛，可以降落 … 等等的行為。所以做一個簡單版的假物件。假物件不需要考慮跟 SUT 目標對象的間接互動(Indirect input , indirect output)。</p><h2 id="其他不錯的資源"><a href="#其他不錯的資源" class="headerlink" title="其他不錯的資源"></a>其他不錯的資源</h2><ul><li><p><a href="https://blog.pragmatists.com/test-doubles-fakes-mocks-and-stubs-1a7491dfa3da">Test Doubles — Fakes, Mocks and Stubs.</a></p></li><li><p><a href="https://julianchu.net/2018/08/16-test.html">測試中常見的名詞：Stub, Dummy, Mock..等等</a></p></li><li><p><a href="https://www.jyt0532.com/2018/01/04/test-double-spy/">測試替身(5) — Spy</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/0*Xn1CY4WKjOu3AdhL.jpeg&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近開始接觸單元測試，一堆名詞看不懂，來狠狠地 K 一下。而單元測試中的最佳男配角，就是替身 Double。藉由寫一篇文章的方式來讓自己更了解單元測試中的重要部分。一起來學寫測試，Go Go !!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; &lt;em&gt;註：接觸時間還很短，有錯還請不吝指正，如果之後發現我有理解錯誤再回來更正。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;單元測試是什麼？&quot;&gt;&lt;a href=&quot;#單元測試是什麼？&quot; class=&quot;headerlink&quot; title=&quot;單元測試是什麼？&quot;&gt;&lt;/a&gt;單元測試是什麼？&lt;/h2&gt;&lt;p&gt;單元測試可以讓你快速驗證程式的行為。了解單元測的話首先來介紹一下 SUT 目標對象。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Unit Test" scheme="https://luka.tw/tags/Unit-Test/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 教學 02 — 在 Minikube 上部屬 Python Flask 應用程式</title>
    <link href="https://luka.tw/2020/03/10/2020-03-20-running-flask-on-minikube/"/>
    <id>https://luka.tw/2020/03/10/2020-03-20-running-flask-on-minikube/</id>
    <published>2020-03-10T11:50:00.000Z</published>
    <updated>2021-10-04T14:40:55.156Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Minikube、kubectl 終於派上用場囉</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/2088/0*BVfI3gXXICtmPkCu.jpeg"></p><h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>在 <a href="https://medium.com/starbugs/954caa9b1558">前一篇</a> 中我們弄懂了 K8S Cluster、Node、Pod 與 Container 的關係，並且在文章末段介紹了能夠與 kubectl -「能夠與 K8S 溝通的命令列工具」。這次我們用實際的操作，來認識容器化的實際過程，並把它部屬到本地的 Kubernetes 上面。</p><h2 id="什麼是-Minikube-？"><a href="#什麼是-Minikube-？" class="headerlink" title="什麼是 Minikube ？"></a>什麼是 Minikube ？</h2><p>Minikube 是一個單節點的 Kubernetes Cluster，可以安裝在本機上，支援 Windows 與 Mac Minikube 只有一個 Node (節點)。</p><p>還記得 Node 是什麼嘛？來複習一下，Node 是一台實體機器，一個工作者 (worker)。上面可以搭載許多個 Pod，而 Pod 是 Kubernetes 的最小部屬單位。一個 Pod 由一個 Container 或是多個 Container 所組成。</p><p>看完之後應該還是覺得有點繞，不過沒關係，因為今天我們就要透過實作來了解 Pod 到底是什麼。</p><h3 id="安裝-Minikube"><a href="#安裝-Minikube" class="headerlink" title="安裝 Minikube"></a>安裝 Minikube</h3><p>首先安裝 Minikube，請到<a href="https://kubernetes.io/docs/tasks/tools/install-minikube/">官方網頁</a>下載安裝，Windows、Mac、Linux 都可以安裝。</p><p>Windows 需要先安裝 <a href="https://chocolatey.org/">Chocolatey</a> 套件管理工具，接著輸入指令</p><pre><code>choco install minikube</code></pre><p>即可完成安裝。而 Mac 則可以透過 homebrew 來完成安裝</p><pre><code>brew install minikube </code></pre><h2 id="起步走，開始使用-Minikube-與-kubectl"><a href="#起步走，開始使用-Minikube-與-kubectl" class="headerlink" title="起步走，開始使用 Minikube 與 kubectl"></a>起步走，開始使用 Minikube 與 kubectl</h2><p>安裝完 minikube 之後，第一步先啟動 Minikube，如果你是第一次啟動，Minikube 會幫你建立新的虛擬機器 (VM)。</p><pre><code>minikube start</code></pre><p>眼尖的你看到最後一行，啟動好 minikube 的同時，kubectl 也準備就緒了。來看看 minikube 的狀態。</p><pre><code>minikube status</code></pre><p>上一篇提到的 kubelet 與 api-server 已經成功跑起來。複習一下 api-server 是 Master 的元件，kubelet，則是 Node 上負責跟 Master 溝通的元件。因為 Minikube 只有單一個 Node，所以同時具備 Master 與 Node 的元件。</p><p><img src="https://cdn-images-1.medium.com/max/2000/0*g0EkSg37jwB0wHNb.png"><br><a href="https://kubernetes.io/docs/concepts/overview/components/">ref: https://kubernetes.io/docs/concepts/overview/components/</a></p><p>使用 kubectl 查看目前 Cluster 中的狀態</p><pre><code>kubectl get all</code></pre><p>裡面只有一個 kubernetes 的 service，因為我們的 Kubenetes Cluster 中還沒有安裝任何的東西。</p><h2 id="建立一個-Python-的-Flask-Web-應用程式"><a href="#建立一個-Python-的-Flask-Web-應用程式" class="headerlink" title="建立一個 Python 的 Flask Web 應用程式"></a>建立一個 Python 的 Flask Web 應用程式</h2><p>建立資料夾名稱為 flask_app</p><pre><code>mkdir flask_app</code></pre><p>建立一個子資料夾 app ，並在之中建立一個 app.py 檔案</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"> <span class="hljs-comment"># flask_app/app/app.py</span><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, World!&quot;</span><br><br><br><span class="hljs-keyword">if</span> __name == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run(debug=<span class="hljs-literal">True</span>, host=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>)<br></code></pre></td></tr></table></figure><p>建立 requirement.txt</p><pre><code># flask_app/app/requirement.txtFlask</code></pre><p>在本地端試跑，先安裝依賴的套件，目前只有一個就是 flask</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pip3 install -r requirements.txt<br></code></pre></td></tr></table></figure><p>接著執行看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">python main.py<br></code></pre></td></tr></table></figure><p>打開 <a href="http://0.0.0.0:5000/">0.0.0.0:5000</a> 即可看到以下訊息</p><pre><code>Hello from Python!</code></pre><h2 id="容器化-Flask-Web-應用程式"><a href="#容器化-Flask-Web-應用程式" class="headerlink" title="容器化 Flask Web 應用程式"></a>容器化 Flask Web 應用程式</h2><p>建立一個 Dockerfiile，意思是用 Python 3.7 作為基本的容器，並把專案中的程式碼放進去。並在最後執行 python main.py。</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.7</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> mkdir /app</span><br><span class="hljs-keyword">WORKDIR</span><span class="bash"> /app</span><br><span class="hljs-keyword">ADD</span><span class="bash"> ./app /app/</span><br><span class="hljs-keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">5000</span><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;/app/main.py&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>製作 docker image，並給他一個名稱flask_app</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">docker build . -t flask_app<br></code></pre></td></tr></table></figure><p>可以成功 build，沒有問題</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*bSSrv5vrsVqBO2xGZbs0qA.png"></p><p>用 docker images 查看剛剛製作的 image</p><p><img src="https://cdn-images-1.medium.com/max/2140/1*ta80syB_HoOKMwLmSLOdQA.png"></p><p>跑跑看剛剛製作好的 image</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">docker run -p 5001:5000 flask_app<br></code></pre></td></tr></table></figure><p>打開 <a href="http://0.0.0.0:5001/">http://0.0.0.0:5001/</a> 一樣會看到</p><pre><code>Hello from Python!</code></pre><p>到這邊我們已經製作完成 Docker image。接下來就要把它部屬到 Minikube 上。</p><h2 id="部屬-Python-Flask-應用程式到-Minikube-上"><a href="#部屬-Python-Flask-應用程式到-Minikube-上" class="headerlink" title="部屬 Python Flask 應用程式到 Minikube 上"></a><strong>部屬 Python Flask 應用程式到 Minikube 上</strong></h2><p>首先我們先來建立一個檔案 k8s.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">flask-app-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">flask-app</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">&quot;TCP&quot;</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5000</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">5000</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">LoadBalancer</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">flask-app</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">flask-app</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">flask-app</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">flask-app</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">flask_app:latest</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">Never</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure><p>命令列輸入，即可將 flask_app 部屬至 minikube</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">kubectl apply -f k8s.yaml<br></code></pre></td></tr></table></figure><p>部屬完的畫面</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*G45yB7h77nfGQ--OtDgG1A.png"></p><p>接著訪問</p><p>剛剛的 k8s.yaml 只有聲明 deployment 與 service 兩種物件，但卻產生了 3 個 pod，原因就在於，deployment 裡面聲明了需要 3 個 pod，所以會擴展出 3 個。</p><p>輸入以下指令查看暴露出來的 IP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">minikube service flask-app-service --url<br></code></pre></td></tr></table></figure><p>訪問 <a href="http://192.168.64.8:30914/">http://192.168.64.8:30914</a> 就可以看到 Kubernetes 上的 Flask 伺服器回傳的畫面。</p><pre><code>Hello from Python!</code></pre><p>剛剛我們撰寫 k8s.yaml 時，Service Type 使用的是 LoadBalancer，所以這可是具有負載均衡能力，並且擁有 3 個 Pod 作為支撐的服務。</p><p>是不是很神奇？今天我們做了三種 Hello from Python，分別是：</p><ul><li><p>在本地端運行 Flask 伺服器</p></li><li><p>在單個 Docker 容器運行 Flask 伺服器</p></li><li><p>在 Kubernetes 中的 Cluster 運行 Flask 伺服器</p></li></ul><p>一步一步的將應用程式，容器化，之後再用 K8S 打造成產品等級的服務。Kubernetes 就是這麼的有趣！</p><p>如果喜歡我寫的文章，歡迎追蹤 本人的帳號 <a href="https://medium.com/@LukaTw">@LukaTW</a> 與 <a href="https://medium.com/starbugs">StarBugs Weekly 星巴哥技術週刊</a> 🙂🙂🙂</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Minikube、kubectl 終於派上用場囉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2088/0*BVfI3gXXICtmPkCu.jpeg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;https://medium.com/starbugs/954caa9b1558&quot;&gt;前一篇&lt;/a&gt; 中我們弄懂了 K8S Cluster、Node、Pod 與 Container 的關係，並且在文章末段介紹了能夠與 kubectl -「能夠與 K8S 溝通的命令列工具」。這次我們用實際的操作，來認識容器化的實際過程，並把它部屬到本地的 Kubernetes 上面。&lt;/p&gt;
&lt;h2 id=&quot;什麼是-Minikube-？&quot;&gt;&lt;a href=&quot;#什麼是-Minikube-？&quot; class=&quot;headerlink&quot; title=&quot;什麼是 Minikube ？&quot;&gt;&lt;/a&gt;什麼是 Minikube ？&lt;/h2&gt;</summary>
    
    
    
    
    <category term="Kubernetes" scheme="https://luka.tw/tags/Kubernetes/"/>
    
    <category term="Minikube" scheme="https://luka.tw/tags/Minikube/"/>
    
    <category term="Python" scheme="https://luka.tw/tags/Python/"/>
    
    <category term="Flask" scheme="https://luka.tw/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 教學 01 - 概念與架構</title>
    <link href="https://luka.tw/2020/02/11/2020-02-11-kubernetes-tutorial-01/"/>
    <id>https://luka.tw/2020/02/11/2020-02-11-kubernetes-tutorial-01/</id>
    <published>2020-02-11T02:32:00.000Z</published>
    <updated>2021-10-04T14:00:28.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="為什麼該學-K8S-？-Pod、Node-是什麼？搞的我好亂呀！"><a href="#為什麼該學-K8S-？-Pod、Node-是什麼？搞的我好亂呀！" class="headerlink" title="為什麼該學 K8S ？ Pod、Node 是什麼？搞的我好亂呀！"></a>為什麼該學 K8S ？ Pod、Node 是什麼？搞的我好亂呀！</h2><p><img src="https://cdn-images-1.medium.com/max/3840/0*CmyuLdGdOQJLKS5t.png"></p><p>適合讀者：</p><ul><li><p>已經會使用 Docker，但是不知道 Kubernetes 是什麼。</p></li><li><p>想看看 Kubernetes 到底在幹嘛的人。</p></li></ul><h2 id="為什麼該用-Kubernetes"><a href="#為什麼該用-Kubernetes" class="headerlink" title="為什麼該用 Kubernetes?"></a>為什麼該用 Kubernetes?</h2><p>Kubernetes 中間共有八個字母有點長，所以大家就將他簡稱為 K8S。但使用 K8S 有什麼好處？</p><h3 id="1-可以更好的運用雲端或是實體資源"><a href="#1-可以更好的運用雲端或是實體資源" class="headerlink" title="1. 可以更好的運用雲端或是實體資源"></a>1. 可以更好的運用雲端或是實體資源</h3><p>所有的資源集中成了一個大平台，所以調度上更靈活，以往我們以實體機為單位的方式很沒有效率，要調度資源的時候需要開一台實體機器，或是虛擬機器，都很耗費 CPU、記憶體等等的資源。</p><p>而 K8S 內所有的東西都是容器，可以很快啟動，很快的刪除，並且靈活部屬在 Kubernetes 所擁有的資源上。</p><h3 id="2-讓一切的基礎設施都寫成程式碼"><a href="#2-讓一切的基礎設施都寫成程式碼" class="headerlink" title="2. 讓一切的基礎設施都寫成程式碼"></a>2. 讓一切的基礎設施都寫成程式碼</h3><p>應用程式容器化之後，所有需要安裝的套件都會寫成 Dockerfile。這樣在新增或修改的時候，不再像是以前的伺服器是個黑盒子，需要花大量的時間除錯。</p><p>部屬的資源則用 Kubernetes 的描述方式撰寫，要前端服務要開幾台，後端服務要開幾台，要自動擴展？ 沒問題，這些 K8S 都可以輕鬆幫你做到。所以你如果要了解整個基礎設施架構時，可以很快的藉由程式碼來認識。</p><h3 id="3-可以幫助開發者聚焦開發"><a href="#3-可以幫助開發者聚焦開發" class="headerlink" title="3. 可以幫助開發者聚焦開發"></a>3. 可以幫助開發者聚焦開發</h3><p>減少開發者在基礎設施上花的時間，將硬體統一看做一個大平台，開發者只需要寫應用的描述，其他的 K8S 幫你搞定。例如：有節點當機，會自動生成一個新的節點，以維持服務的穩定。</p><h2 id="一切從-Container-開始"><a href="#一切從-Container-開始" class="headerlink" title="一切從 Container 開始"></a>一切從 Container 開始</h2><p>使用 Kubernetes 之前，你需要把你的服務先容器化，或者用人家包好的 Image 建立。例如：你有一個 Node.js 的應用程式、一個 MySQL 的資料庫，都可以架設在 K8S 上面。</p><p>K8S 提供了豐富的、可以應用於產品環境的一切資源給你。例如：自動擴展、負載均衡、定時工作 … 等等一切你想得到的東西。</p><p>但是在開始使用 K8S 之前，你需要把你的服務先容器化。雖然一開始很痛苦，需要花很多時間做原本不必要做的事情，但是你容器化你的服務之後會發現，以前需要在不知道被做過什麼事情的機器上摸索的體力活，通通都自動化、或是很易於找到解法，因為在程式碼裡面都有跡可尋。</p><h2 id="理解-Node、Pod、Container-之間的關係"><a href="#理解-Node、Pod、Container-之間的關係" class="headerlink" title="理解 Node、Pod、Container 之間的關係"></a>理解 Node、Pod、Container 之間的關係</h2><p>Node 是 K8S 中的一台實體機器、或是雲端上的一台機器，又稱作是工作者。他有個別名叫做奴隸 (minion) ，挺有趣的。</p><p>Pod 是 K8S 中基本的單位，負責裝一個或多個多個 Container (容器)。</p><p>Container 中就是我們容器化好的應用程式，例如：Node.js 應用程式、MySQL 服務 … 等等</p><p>需要 Pod 來作為基本單位的原因是，如果每個 Container 都作為 K8S 的最小單位，那麼管理網路會變得非常的困難。以 Pod 來區隔，同一個 Pod 裡面的 Container 能夠在本地端互相的連線，只有需要提供給外部呼叫的 API 才需要暴露出來。</p><p>示意圖如下：</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*vJp5o7ABILiIapesES8j6g.png"></p><h2 id="理解-Kubernetes-Cluster"><a href="#理解-Kubernetes-Cluster" class="headerlink" title="理解 Kubernetes Cluster"></a>理解 Kubernetes Cluster</h2><p>Kubernetes 集群由控制面板 Control Panel 與節點 Node 所組成。控制面板又稱為是 Kubernetes Master。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*J4GBXcAOasRI0aPgd4-IYw.png"><br><a href="https://kubernetes.io/docs/concepts/overview/components/">https://kubernetes.io/docs/concepts/overview/components/</a></p><p>控制面板由幾個元件 (Component) 所組成：</p><h3 id="1-Kube-API-Server"><a href="#1-Kube-API-Server" class="headerlink" title="1. Kube API Server"></a>1. Kube API Server</h3><p>控制面板中用來暴露 Kubernetes API 的元件，讓其他服務可以讀寫 K8S 的資源物件 (Resouce Object)。</p><h3 id="2-Kube-Schedular"><a href="#2-Kube-Schedular" class="headerlink" title="2. Kube Schedular"></a>2. Kube Schedular</h3><p>調度器，需要調度軟體、硬體資源的時候就要靠調度器囉。例如：如果新建立的 pod 沒有 node 可以放的時候，調度器就會開啟一個新的 node，來放置剛剛需要建立的 pod。</p><h3 id="3-Kube-Controller-Manager"><a href="#3-Kube-Controller-Manager" class="headerlink" title="3. Kube Controller Manager"></a><strong>3. Kube Controller Manager</strong></h3><p>是一個在背景持續執行的程序 (daemon)，用來調節系統狀態，透過 api-server 可以監視 Cluster 共享的狀態。</p><p>需要變更目前狀態的時候 Kube Controller 就會將目前的狀態變更到想要變更的狀態，例如：本來 2 個副本 (Replica) 擴展到 4 個副本。</p><p>包含了副本控制器 (Replication Controller)，端點控制器 (Endpoint Controller)、命名空間控制器(Namepsace Controller)與服務帳號控制器</p><h3 id="4-Cloud-Controller-Manager"><a href="#4-Cloud-Controller-Manager" class="headerlink" title="4. Cloud Controller Manager"></a><strong>4. Cloud Controller Manager</strong></h3><p>基於 Kube Controller Manager，各個雲平台提供者（Provider）的實作。而每個 Node 則包含：</p><ul><li><p>kubelet — 用來跟 Master 溝通的元件。</p></li><li><p>kube-proxy — 網路代理，用來反應 K8S 各個 Node 上的網路服務</p></li></ul><h2 id="讀-Kubernetes-API-初探-K8S-的資源物件"><a href="#讀-Kubernetes-API-初探-K8S-的資源物件" class="headerlink" title="讀 Kubernetes API 初探 K8S 的資源物件"></a>讀 Kubernetes API 初探 K8S 的資源物件</h2><p>我們可以透過 Kubernetes API 讀寫 K8S 的資源物件 (Resource Object)，剛剛說的 Kubernetes Cluster 就分為 Kubernetes API 總共分為五大類，分別是：</p><ul><li><p>Workload 物件 — 用來「管理或是運行 Container」 在 Cluster 上。</p></li><li><p>服務發現與負載均衡物件 — 讓 Workload 可以「縫住」形成可被外部存取到的服務，或是有負載均衡能力的服務。</p></li><li><p>Config 與 Storage 物件 — Config 用來將配置注入你的應用程式中。Storage 讓 Container 的資料可以永久保存在 Container 之外。</p></li><li><p>Cluster 物件 — 用來定義集群本身的物件。</p></li><li><p>Meta 物件 — 用來配置資源之間的行為的物件。</p></li></ul><p>這種分類法較接近開發者，可以藉此看看開發者在想些什麼。</p><p><img src="https://cdn-images-1.medium.com/max/2880/1*bbG-QtOtZ17CflsIlS7mwA.png"><br><a href="https://kubernetes.io/docs/reference/#api-reference">https://kubernetes.io/docs/reference/#api-reference</a></p><p>還有精美的 kubectl 範例可以使用，很方便。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*_F_r0Wh9822ZWBc3w3jeLQ.png"></p><h2 id="kubectl-—-跟-K8S-Cluster-溝通的工具"><a href="#kubectl-—-跟-K8S-Cluster-溝通的工具" class="headerlink" title="kubectl — 跟 K8S Cluster 溝通的工具"></a>kubectl — 跟 K8S Cluster 溝通的工具</h2><p>我們絕大多數對 K8S 的操作都需要透過 kubectl，kubectl 的是什麼呢？DevOps 開發者用 kubectl 命令列工具，可以透過 Kubernetes Master 上的 api-server 對各個 Node 下達指令。而這些 API 即是上一小節說的 Kubernetes API。</p><p><img src="https://cdn-images-1.medium.com/max/2000/0*OhlD7-6XRajuS4QZ.png"><br><a href="https://www.redhat.com/zh/topics/containers/what-is-kubernetes">https://www.redhat.com/zh/topics/containers/what-is-kubernetes</a></p><p>to be continued …</p><p>下一部分會比較偏重實作， Minikube 的基本操作、Kubectl 的基本操作與重要的 資源物件的介紹。</p><p>如果喜歡我寫的文章，歡迎追蹤 本人的帳號 <a href="https://medium.com/@LukaTw">@LukaTW</a> 與 <a href="https://medium.com/starbugs">StarBugs Weekly 星巴哥技術週刊</a> 🙂🙂🙂</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;為什麼該學-K8S-？-Pod、Node-是什麼？搞的我好亂呀！&quot;&gt;&lt;a href=&quot;#為什麼該學-K8S-？-Pod、Node-是什麼？搞的我好亂呀！&quot; class=&quot;headerlink&quot; title=&quot;為什麼該學 K8S ？ Pod、Node 是什麼？搞的我好亂呀！&quot;&gt;&lt;/a&gt;為什麼該學 K8S ？ Pod、Node 是什麼？搞的我好亂呀！&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/3840/0*CmyuLdGdOQJLKS5t.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;適合讀者：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;已經會使用 Docker，但是不知道 Kubernetes 是什麼。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;想看看 Kubernetes 到底在幹嘛的人。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;為什麼該用-Kubernetes&quot;&gt;&lt;a href=&quot;#為什麼該用-Kubernetes&quot; class=&quot;headerlink&quot; title=&quot;為什麼該用 Kubernetes?&quot;&gt;&lt;/a&gt;為什麼該用 Kubernetes?&lt;/h2&gt;</summary>
    
    
    
    
    <category term="Kubernetes" scheme="https://luka.tw/tags/Kubernetes/"/>
    
    <category term="Minikube" scheme="https://luka.tw/tags/Minikube/"/>
    
  </entry>
  
  <entry>
    <title>從零開始學 DevOps — 那就選擇最簡單的 Drone CI 開始吧！</title>
    <link href="https://luka.tw/2020/01/14/2020-01-14-drone/"/>
    <id>https://luka.tw/2020/01/14/2020-01-14-drone/</id>
    <published>2020-01-14T02:32:00.000Z</published>
    <updated>2021-10-04T14:00:15.313Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/10340/0*JN9t3uzpnpf0KCnz" alt="Photo by [Ivan Diaz](https://unsplash.com/@mdi?utm_source=medium&amp;utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&amp;utm_medium=referral)"></p><p>目前 DevOps 已經是 Backend 或 Frontend 多多少少都會碰到的部份。而 Drone，正可以讓開發者專心開發自己的專案，每個專案獨立設定需要的 CI / CD 流程，解放前端、後端工程師的戰鬥力，將測試與部屬結合在開發流程中，降低手動測試需要的時間。話不多說，趕快開始架設第一個 Drone CI 伺服器吧。</p><p>本篇文章分為兩個部分，第一個部分來聊聊，為什麼從 Jenkins -&gt; CircleCI -&gt; Drone ，的過程。第二部分則是架設 Drone 的教學。</p><h2 id="為什麼從-Jenkins-gt-CircleCI-gt-Drone"><a href="#為什麼從-Jenkins-gt-CircleCI-gt-Drone" class="headerlink" title="為什麼從 Jenkins -&gt; CircleCI -&gt; Drone"></a>為什麼從 Jenkins -&gt; CircleCI -&gt; Drone</h2><p>第一次接觸 Drone 已經是兩年前，當時的 Drone 是 0.x 版，跟現在的 1.0 版本有不少的差異。那時候玩了一陣子 DroneCI，Docker 化了一些服務，但因為那時對 CI / CD 不甚熟悉，從 Jenkins、DroneCI 與 CircleCI 中選擇。</p><h3 id="簡單比較-Jenkins、DroneCI、CircleCI-三套工具"><a href="#簡單比較-Jenkins、DroneCI、CircleCI-三套工具" class="headerlink" title="簡單比較 Jenkins、DroneCI、CircleCI 三套工具"></a>簡單比較 Jenkins、DroneCI、CircleCI 三套工具</h3><p>Jenkins 複雜度高，可以操作的東西最多。DroneCI 每個步驟都是由 Docker 產生的環境，高度的容器化，讓每個步驟可以調用不同的 Docker Image 來實現各種測試。</p><p>例如：步驟一可以用 nodejs 的 Docker image 測前端的部分，步驟二可以用 golang 的 Docker image 測試後端的框架，然後接著用傳送訊息專用的 Image 傳送 CI / CD 測試結果到 Slack。</p><h3 id="重新採用-DroneCI-的原因"><a href="#重新採用-DroneCI-的原因" class="headerlink" title="重新採用 DroneCI 的原因"></a>重新採用 DroneCI 的原因</h3><p>這次重新採用 DroneCI 的原因是我們需要大量的 build image，用 CircleCI 來做實在很不划算，因為你用他的雲端空間就是要被吃豆腐。再者，這次已經對 Docker 有很多的熟悉度，也對 CI / CD 流程有更高的理解。</p><p>有一點需要特別說明的是，因為我是 Backend 工程師，所以比較喜歡更開發更貼近的工程師的 DroneCI，每個專案底下都有 .drone.yml，負責不同專案的開發者可以輕鬆設計自己需要的 CI/CD 流程。</p><p>而 Jenkins 還是 DevOps / SRE 的王者，功能性的強大，幾乎無所不能，不過因為我有圖型介面障礙，每次都會忘記在哪邊按，而且想要把任何東西都進版控，所以我當然是選 DroneCI 囉！</p><h3 id="用-DroneCI-就是要自己架"><a href="#用-DroneCI-就是要自己架" class="headerlink" title="用 DroneCI 就是要自己架"></a>用 DroneCI 就是要自己架</h3><p>DroneCI 經過 1.0 的改版後已經提供了雲端服務 <a href="https://cloud.drone.io/">drone cloud</a>。不過 … 既然都用 Drone 了當然是要自己架！第一種架設方式是開一台機器例如： EC2，在上面安裝好 Docker、Docker Compsoe、然後下載 Drone 的壓縮檔，接著解壓縮， cd 進入資料夾後輸入 docker-compose up，這樣就架設完成囉。</p><p>自己架設的好處是，自己開的機器便宜，不想用的時候還可關掉。如果你可以清晰知道需要的 CI / CD 流程的哪些環節，並且可以快速的實作出來，用 Drone 是完全沒有問題的。</p><h3 id="用-K8S-架設更好玩"><a href="#用-K8S-架設更好玩" class="headerlink" title="用 K8S 架設更好玩"></a>用 K8S 架設更好玩</h3><p>踏進 K8S 是個不小的門檻，不過 K8S 絕對是個值得投資的技術，各大雲端霸主不管是 AWS、GCP、Azure 紛紛支援 K8S，雖然乍看之下沒有顯著的好處，但是光是把所有架構的轉成程式碼 ( Infrastructure as Code ，Iac) 就是讓企業體質變好，無形中增加了許多未來的彈性與爆發力。</p><p>既然 K8S 是主流，那當然要用 K8S 來架設 Drone 囉。除了開一台機器以外，Drone 對 K8S 的整合度也是很高的，Helm 有著 <a href="https://hub.helm.sh/">Helm Hub</a> ，就像 Docker hub 一樣，你可以在上面找到各式各樣的 Helm Chart 來建置 Drone。建置完成後還可以進入 K8S 中查看 Drone 的各個工作執行的怎麼樣。</p><h2 id="該怎麼開始使用-Drone"><a href="#該怎麼開始使用-Drone" class="headerlink" title="該怎麼開始使用 Drone ?"></a>該怎麼開始使用 Drone ?</h2><p>還是回到最簡單的方法，在本機或是雲端機器上安裝 docker 與 docker-compose，我們用 Github 來做為說明的範例。</p><h3 id="Step-1-—-安裝-DroneCI"><a href="#Step-1-—-安裝-DroneCI" class="headerlink" title="Step 1 — 安裝 DroneCI"></a>Step 1 — 安裝 DroneCI</h3><p>進入<a href="https://drone.io/">官網</a>，點選 Get Started</p><p><img src="https://cdn-images-1.medium.com/max/2518/1*JeGCj0yZqFzICaBX3q2zqQ.png"></p><p>點選 install</p><p><img src="https://cdn-images-1.medium.com/max/2306/1*y-3jjXLAq18yioLt-8XQaA.png"></p><p>選擇 Github</p><p><img src="https://cdn-images-1.medium.com/max/2386/1*A_1WUlNDwtMcodmSNL4bCg.png"></p><p>進入之後開始學習安裝方式，第一個步驟可以跳過，從第二個步驟開始，輸入 docker pull drone/drone:1 拉下來最新的 docker image。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*oSWpHROfnuWr2wWGp7V5zg.png"></p><p>接著，根據官方的 docker 指令來撰寫 docker-compose 檔案，我已經幫大家寫好了，複製貼上即可，儲存成 docker-compose.yml。</p> <iframe src="https://medium.com/media/a91d32cb40f76295aba401d9e0e74e73" frameborder=0></iframe><p>接著輸入 docker-compose up 啟動 drone，此時可用 docker ps -a 看看 container 有沒有正常啟動</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*vUJFccLcZjhD--24pCRm4g.png"></p><h3 id="Step-2-—-用-ngrok-讓-Port-開放-IP-讓外界存取，並加上-https"><a href="#Step-2-—-用-ngrok-讓-Port-開放-IP-讓外界存取，並加上-https" class="headerlink" title="Step 2 — 用 ngrok 讓 Port 開放 IP 讓外界存取，並加上 https"></a>Step 2 — 用 ngrok 讓 Port 開放 IP 讓外界存取，並加上 https</h3><p>到 <a href="https://dashboard.ngrok.com/">ngrok 官網</a>註冊帳號，不註冊的話過一段時間就會被斷線</p><p><img src="https://cdn-images-1.medium.com/max/2084/1*RRyhzg7_hptFfU5RZfq1Jg.png"></p><p>註冊完之後會顯示以下畫面，mac 可以使用 brew install ngrok 安裝 ngrok。安裝完後使用下圖箭頭指示處的，複製貼上，在本機登入你的帳號。</p><p><img src="https://cdn-images-1.medium.com/max/2060/1*sJjAvifeYuOlNrxEnkdl4Q.png"></p><p>之後就可以開心的使用 ngrok 綁定端口囉！</p><p>例如在終端機中輸入 ngrok http 8081，就會把剛剛架設的 drone 伺服器 localhost 的 8081 端口綁定到特定的 ngrok 網址。這邊的網址等下需要複製貼上綁定到 Github OAuth App 上。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*PuxSJe60XUqpfDBBceZupQ.png"></p><h3 id="Step-3—-Github-設定-OAuth-App"><a href="#Step-3—-Github-設定-OAuth-App" class="headerlink" title="Step 3— Github 設定 OAuth App"></a>Step 3— Github 設定 OAuth App</h3><p>選擇螢幕右上方選單的 Settings</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*7CIiJZbvCKLb5lfsPxN7cg.png"></p><p>進入後選擇左下方的 Developer Settings</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*HdxclQS70dX4FbETCMVxhw.png"></p><p>點選 OAuth Apps</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*UrZn_vFgPmeIceIjjx-4lA.png"></p><p>新增 Oauth 應用程式</p><p><img src="https://cdn-images-1.medium.com/max/2574/1*Zsvs6JFoMdisHqahhb2ltw.png"></p><p>將剛剛建立好的 ngrok 網址填入，註冊 OAuth 應用程式。這邊雷的地方，Drone 0.8 的 callback 網址是 authorize，1.0 換成 login，文件上沒有特別著名。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*3JAoWcFx4BGsG19w6wkY2w.png"></p><p>當以上都設定好的時候代表你的 Drone CI 串接完成囉！訪問你的 ngrok 暫時網址，我的是 <a href="https://844f00ae.ngrok.io/">https://844f00ae.ngrok.io</a> 。還記得 ngrok 是做什麼用的嘛，ngrok 可以讓本地端的端口暴露到網際網路。所以可以在任何地方存取的到。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*UG6pbB8rFnKKctU5lvsnPg.png"></p><p>登入後 drone 已經建立成功囉，紅框的網址可以替代成任何你伺服器上的網址。</p><p><img src="https://cdn-images-1.medium.com/max/2118/1*08dTULm4YIx7v5LFwi_E0Q.png"></p><p>我們來開啟監控一個 drone 的 project，如果這專案有改變就會觸發 CI / CD 流程。大家想要一起玩可以到這邊 fork 專案 <a href="https://github.com/drone-demos/drone-with-nodejs">https://github.com/go-training/drone-nodejs-example</a>。</p><p><img src="https://cdn-images-1.medium.com/max/2144/1*TDNbj7nNu4OrTT5VXaaDig.png"></p><p>開啟後會顯示專案目前是開啟的狀態。只要有 commit push 即可觸發。</p><p><img src="https://cdn-images-1.medium.com/max/NaN/1*sC8f7JVfEJgKOHCHIqvKxg.png"></p><p>來試試看，加一個 commit 並 push，觸發 Drone CI</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*WhSeytz5KRnnZ8hXvra8nQ.png"></p><p>果然成功了！</p><p><img src="https://cdn-images-1.medium.com/max/2106/1*rSC_dLjMghPagl22PQHk6A.png"></p><p>完成之後</p><p><img src="https://cdn-images-1.medium.com/max/2040/1*trGae2DEva01LWxk7jxI8Q.png"></p><p>Great！我們做出了第一個 CI / CD 系統，好處有什麼呢？今天篇幅有點長，我們留著下次再講吧 :D 下一篇 Drone CI / CD 我們來聊聊 CI / CD 的常見流程！</p><p>如果喜歡我寫的文章，歡迎追蹤本人帳號 <a href="https://medium.com/@LukaTw">@LukaTw</a> 與 <a href="https://medium.com/starbugs">StarBugs Weekly 星巴哥技術週刊</a>🙂</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/10340/0*JN9t3uzpnpf0KCnz&quot; alt=&quot;Photo by [Ivan Diaz](https://unsplash.com/@mdi?utm_source=medium&amp;amp;utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&amp;amp;utm_medium=referral)&quot;&gt;&lt;/p&gt;
&lt;p&gt;目前 DevOps 已經是 Backend 或 Frontend 多多少少都會碰到的部份。而 Drone，正可以讓開發者專心開發自己的專案，每個專案獨立設定需要的 CI / CD 流程，解放前端、後端工程師的戰鬥力，將測試與部屬結合在開發流程中，降低手動測試需要的時間。話不多說，趕快開始架設第一個 Drone CI 伺服器吧。&lt;/p&gt;
&lt;p&gt;本篇文章分為兩個部分，第一個部分來聊聊，為什麼從 Jenkins -&amp;gt; CircleCI -&amp;gt; Drone ，的過程。第二部分則是架設 Drone 的教學。&lt;/p&gt;
&lt;h2 id=&quot;為什麼從-Jenkins-gt-CircleCI-gt-Drone&quot;&gt;&lt;a href=&quot;#為什麼從-Jenkins-gt-CircleCI-gt-Drone&quot; class=&quot;headerlink&quot; title=&quot;為什麼從 Jenkins -&amp;gt; CircleCI -&amp;gt; Drone&quot;&gt;&lt;/a&gt;為什麼從 Jenkins -&amp;gt; CircleCI -&amp;gt; Drone&lt;/h2&gt;&lt;p&gt;第一次接觸 Drone 已經是兩年前，當時的 Drone 是 0.x 版，跟現在的 1.0 版本有不少的差異。那時候玩了一陣子 DroneCI，Docker 化了一些服務，但因為那時對 CI / CD 不甚熟悉，從 Jenkins、DroneCI 與 CircleCI 中選擇。&lt;/p&gt;</summary>
    
    
    
    
    <category term="DevOps" scheme="https://luka.tw/tags/DevOps/"/>
    
    <category term="DroneCI" scheme="https://luka.tw/tags/DroneCI/"/>
    
  </entry>
  
  <entry>
    <title>用 Harbor 架設 Private Docker Registry</title>
    <link href="https://luka.tw/2019/12/17/2019-12-17-harbor/"/>
    <id>https://luka.tw/2019/12/17/2019-12-17-harbor/</id>
    <published>2019-12-17T02:32:00.000Z</published>
    <updated>2021-10-04T15:35:32.077Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn-images-1.medium.com/max/2000/1*zYNBpVXtxGID9rttcSYklQ.jpeg"></p><h2 id="什麼是-Docker-Registry？"><a href="#什麼是-Docker-Registry？" class="headerlink" title="什麼是 Docker Registry？"></a>什麼是 Docker Registry？</h2><p>顧名思義就是用來儲存鏡像檔 (Image) 的地方。例如：DockerHub 就是 Docker 官方提供的 Docker Registry，你可以把你自己編寫的 Dockerfile 編譯之後上傳到 Dockerhub ，讓網路上的其他人自由的下載，讓大家站在你的肩膀上寫程式。</p><p><img src="https://cdn-images-1.medium.com/max/2402/1*xCluFgOIs4GgoiAFkxIOJg.png" alt="Dockerhub 首頁"></p><p><img src="https://cdn-images-1.medium.com/max/2328/1*5V65KKaQS5QlDeSEMW6Crg.png" alt="在 dockerhub 上面可以搜尋到 ubuntu 官方釋出的 docker image"></p><h2 id="為什麼要架設私有的-Docker-Registry？"><a href="#為什麼要架設私有的-Docker-Registry？" class="headerlink" title="為什麼要架設私有的 Docker Registry？"></a>為什麼要架設私有的 Docker Registry？</h2><p>在這個容器化的時代， 要使用 Kubernetes 生態系，第一步是將原本的實體機器的配置轉換成程式碼，轉換完成後變成 Dockerfile，Dockerfile 編寫著這台機器上所有的配置。</p><p>我們需要找一個地方存放由這些 Dockerfile 建立 (build) 出來的 Docker 鏡像檔，這些鏡像檔總不能放在 Dockerhub 上給大家一覽無遺吧？因此我們需要一個私有的 Docker Registry 來放置建立的 Docker 鏡像檔。</p><h2 id="Harbor-是什麼？"><a href="#Harbor-是什麼？" class="headerlink" title="Harbor 是什麼？"></a>Harbor 是什麼？</h2><p>Harbor 是由 VMware 發行的鏡像檔儲存倉庫，就是你自行架設一個只有公司內部可以存取到的 Dockerhub，公司內部使用的鏡像檔都上傳到上面，要使用時也都從 Harbor 中拉下來 (pull image)。</p><p>Harbor 的管理介面如下</p><p><img src="https://cdn-images-1.medium.com/max/3052/1*pl2f1k9c_PdW_QWxRf1cAQ.png"></p><p>每一個專案可以有多個 Repository，而每個 Repository 可以上傳多個 Image</p><p><img src="https://cdn-images-1.medium.com/max/3078/1*l76NWolqE7O0t0rGAafk6A.png"></p><h2 id="Harbor-在-CI-CD-中扮演的角色"><a href="#Harbor-在-CI-CD-中扮演的角色" class="headerlink" title="Harbor 在 CI/CD 中扮演的角色"></a>Harbor 在 CI/CD 中扮演的角色</h2><p>用一張圖表來說明 Docker Registry 在 CI / CD 流程中扮演的角色：</p><p><img src="https://cdn-images-1.medium.com/max/2808/1*M69pOie1Kw6U1G36CC6sVA.png"></p><p>首先我們把程式碼推上 Github，觸發 CI / CD (以 Jenkins 為例) Pipeline，Pipeline 中包含跑測試、程式碼品質檢測 … 等等的步驟，依照需求自由定義。</p><p>跑完 CI / CD Pipeline 後便會把 Docker Image 推上 Harbor。接著如果 K8S 需要取用時便會從 Harbor 拉取 (pull) 需要的版本的 Image。</p><p>註：更安全的作法是 Github 用私有的程式碼儲存庫取代，這邊為了簡單示意，用 Github 作為程式碼儲存庫的代表。</p><h2 id="如何架設-Harbor？"><a href="#如何架設-Harbor？" class="headerlink" title="如何架設 Harbor？"></a>如何架設 Harbor？</h2><h3 id="Harbor-的安裝方式"><a href="#Harbor-的安裝方式" class="headerlink" title="Harbor 的安裝方式"></a>Harbor 的安裝方式</h3><p>在 Github 上面可以看到 Harbor 是 1 萬顆星星以上的大型開源專案</p><p><img src="https://cdn-images-1.medium.com/max/2260/1*CH1EH9Z67Zb1Ly-yLwq9Kg.png"></p><p>找到 Install &amp;&amp; Run 區域的說明，上面寫著先下載 binary 檔案，然後跟著安裝手冊操作。</p><p><img src="https://cdn-images-1.medium.com/max/2126/1*B-Q22EUDNzCgm0iMguOZOA.png"></p><p>我們就進入到 <a href="https://github.com/goharbor/harbor/releases">Harbor Release</a> 頁面</p><p><img src="https://cdn-images-1.medium.com/max/2264/1*ROVmxJmXqeKol5YLfjjN8w.png"></p><p>往下卷找到 Assets 區域</p><p><img src="https://cdn-images-1.medium.com/max/2014/1*lNDshHJA-X-ZyF6EG_e_3g.png"></p><p>這時我們點選 online installler 下載，如果在 linux 主機上可以用 wget 取得。</p><h3 id="安裝-Docker-與-Docker-Compose"><a href="#安裝-Docker-與-Docker-Compose" class="headerlink" title="安裝 Docker 與 Docker Compose"></a>安裝 Docker 與 Docker Compose</h3><p>接著到 <a href="https://github.com/goharbor/harbor/blob/master/docs/installation_guide.md">Harbor Installation and Configuration Guide</a> 觀看教學逐步完成安裝，安裝 Harbor 時需要安裝 Docker 與 Docker Compose。</p><p>首先我們需要安裝 Docker，用 Ubuntu 18.04 來演練：參考 <a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-18-04">How To Install and Use Docker on Ubuntu 18.04</a> 逐步完成 docker 安裝。</p><p>除了需要 Docker 以外，還需要 docker-compose，參考 <a href="https://www.digitalocean.com/community/tutorials/how-to-install-docker-compose-on-ubuntu-18-04">How To Install Docker Compose on Ubuntu 18.04</a>。</p><h3 id="繼續安裝-Harbor"><a href="#繼續安裝-Harbor" class="headerlink" title="繼續安裝 Harbor"></a>繼續安裝 Harbor</h3><p>取得剛剛 release 畫面獲得的安裝包位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">wget https://github.com/goharbor/harbor/releases/download/v1.10.0/harbor-online-installer-v1.10.0.tgz<br></code></pre></td></tr></table></figure><p>解壓縮之</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">tar xvf harbor-online-installer-v1.10.0.tgz<br></code></pre></td></tr></table></figure><p>現在你有 harbor 安裝檔資料夾</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*oucT344pLoZU6e0MUKr_Cg.png"></p><p>進入 harbor 資料夾，看到有幾個檔案，install.sh 就是安裝檔了，首先我們要先修改 harbor.yml</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*W2KPqrMFv2TC--85ciaIdw.png"></p><p>將 hostname 修改，否則直接運行 install.sh 是會發生錯誤的。除了修改 hostman 以外，修改 admin password 預設管理員密碼，可以增加安全性。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*jDUzW33Dqar1YOkZWwzgpg.png"></p><p>修改完成後執行 sudo ./install.sh，harbor 需要的服務就會依序被建立起來，就是這麼簡單。</p><p>此時訪問這台機器的 ip 位置，就會出現登入畫面囉！</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>現在你擁有了一個可以放在公司內網的 Docker Registry，你可以在上面自由的上傳自己建立的 Docker Image，不用怕被看光光，是不是很棒呢。</p><p>如果喜歡我寫的文章，歡迎追蹤本人帳號 <a href="https://medium.com/@LukaTw">@LukaTw</a> 與 <a href="https://medium.com/starbugs">StarBugs Weekly 星巴哥技術週刊</a> 🙂🙂🙂</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*zYNBpVXtxGID9rttcSYklQ.jpeg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;什麼是-Docker-Registry？&quot;&gt;&lt;a href=&quot;#什麼是-Docker-Registry？&quot; class=&quot;headerlink&quot; title=&quot;什麼是 Docker Registry？&quot;&gt;&lt;/a&gt;什麼是 Docker Registry？&lt;/h2&gt;&lt;p&gt;顧名思義就是用來儲存鏡像檔 (Image) 的地方。例如：DockerHub 就是 Docker 官方提供的 Docker Registry，你可以把你自己編寫的 Dockerfile 編譯之後上傳到 Dockerhub ，讓網路上的其他人自由的下載，讓大家站在你的肩膀上寫程式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2402/1*xCluFgOIs4GgoiAFkxIOJg.png&quot; alt=&quot;Dockerhub 首頁&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2328/1*5V65KKaQS5QlDeSEMW6Crg.png&quot; alt=&quot;在 dockerhub 上面可以搜尋到 ubuntu 官方釋出的 docker image&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Harbor" scheme="https://luka.tw/tags/Harbor/"/>
    
    <category term="Docker" scheme="https://luka.tw/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>駭客是怎麼思考的？｜從 Devcore Conf 學駭客思維</title>
    <link href="https://luka.tw/2019/11/19/2019-11-19/"/>
    <id>https://luka.tw/2019/11/19/2019-11-19/</id>
    <published>2019-11-19T02:32:00.000Z</published>
    <updated>2021-10-04T13:50:17.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="駭客是怎麼思考的？｜從-Devcore-Conf-學駭客思維"><a href="#駭客是怎麼思考的？｜從-Devcore-Conf-學駭客思維" class="headerlink" title="駭客是怎麼思考的？｜從 Devcore Conf 學駭客思維"></a>駭客是怎麼思考的？｜從 Devcore Conf 學駭客思維</h2><h3 id="媽阿，原來電影裡演的都是真的"><a href="#媽阿，原來電影裡演的都是真的" class="headerlink" title="媽阿，原來電影裡演的都是真的"></a>媽阿，原來電影裡演的都是真的</h3><p><img src="https://cdn-images-1.medium.com/max/12048/1*ge80giZjL7EGHSLU5v00eQ.jpeg" alt="Photo by [Clint Patterson](https://unsplash.com/@cbpsc1?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/hacker?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText)"></p><p>Hello 大家好，我是 Luka，一名喜歡追新技術並喜歡做些有趣嘗試的工程師。這次來的是分享參加 DEVCORE CONF 2019 的心得與收獲。</p><p>這篇以 Web 前端、後端工程師的角度來分享參加 DEVCORE CONF 2019 的心得。適合「 Web 工程師」或是「想要多了解一點資安觀念的人」閱讀。如果你本身已經是從事資安行業了，那麼這篇文章對你來說可能太淺，請到 <a href="https://devco.re/">DEVCORE 官網</a> 觀看專業的技術文章。</p><p>簡單介紹一下 DEVCORE 戴夫寇爾這家資安公司，在我參加 DEVCORE CONF 之前已耳聞 DEVCORE 的大名，但我一直搞不清楚資安公司的不同之處。</p><p>參加完 DEVCORE CONF 之後，我才知道原來 DEVCORE 這麼厲害，回報了非常多的 CVE 漏洞，在國際的駭客比賽中也常獲得獎項。和他們平常到底做些什麼事情。話不多說，趕快來進入正題。</p><h2 id="全部講者都是駭客的年會"><a href="#全部講者都是駭客的年會" class="headerlink" title="全部講者都是駭客的年會"></a>全部講者都是駭客的年會</h2><p>必須說這個體驗真的超狂的，一家公司獨自舉辦一個研討會，並且所有講者都是「駭客」。議程裡大概有一半是分享「如何攻陷別人的公司」的過程與方法，而且當講到攻陷時的那一刻時，你會感受到講者眼睛裡閃耀著光芒，展現出了純粹的喜悅（抖～～。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*3ZY1icmt6y_-2X3c0D6tlQ.png" alt="( 因為主辦單位提到勿公開與會者，因此用海苔條保護與會者隱私。)"></p><p>這是 DEVCORE CONFERENCE 2019 的主設計，在牆上貼著有著很大 Attack 字樣的海報，傳遞了一個訊息：</p><blockquote><h1 id="攻擊！攻擊！再攻擊！純攻擊導向的資安研討會"><a href="#攻擊！攻擊！再攻擊！純攻擊導向的資安研討會" class="headerlink" title="攻擊！攻擊！再攻擊！純攻擊導向的資安研討會"></a><strong>攻擊！攻擊！再攻擊！純攻擊導向的資安研討會</strong></h1></blockquote><p>這實在是太有趣了，一般資安大會大部分以防禦者的角度，為了防止某種攻擊方式，所以「要用怎麼樣的方式防守」或是「要安裝怎麼樣的硬體設備來防守」。</p><p>聽完之後往往會覺得疑惑 ： 「這真的是攻擊者會採用的策略？」或是「這樣防禦真的就防的著了嘛？」，這些問題就是 DEVCORE CONF 2019 整個研討會的主軸 「從攻擊者的角度制定防禦策略」要解決的問題。</p><blockquote><h1 id="了解駭客思維，你才能了解從哪邊下手會是有效的防禦策略。"><a href="#了解駭客思維，你才能了解從哪邊下手會是有效的防禦策略。" class="headerlink" title="了解駭客思維，你才能了解從哪邊下手會是有效的防禦策略。"></a>了解駭客思維，你才能了解從哪邊下手會是有效的防禦策略。</h1></blockquote><h2 id="進入駭客的思考領域"><a href="#進入駭客的思考領域" class="headerlink" title="進入駭客的思考領域"></a>進入駭客的思考領域</h2><p><img src="https://cdn-images-1.medium.com/max/2000/0*Gg0B6uJGOgbj-ovK.jpg"></p><h2 id="第一個思考點-—-我們如何防禦駭客入侵？"><a href="#第一個思考點-—-我們如何防禦駭客入侵？" class="headerlink" title="第一個思考點 — 我們如何防禦駭客入侵？"></a>第一個思考點 — 我們如何防禦駭客入侵？</h2><p>常見防守方式是「縱深防禦」，意思是用不同的資安設備、安全規範、服務，降低駭客入侵的可能性。</p><p>萬一不幸某個點被駭客入侵了，例如：檔案伺服器被攻陷了，讓損害局限於某處，控制損害範圍。</p><p>縱深防禦常見的被突破點：</p><ol><li><p>防禦邊界超出想像。眼前的防禦邊界不是駭客眼中防禦邊界，通常忽略的地方因為你沒有想到這裡會被打，所以更容易視為被攻擊的點。</p></li><li><p>真的了解資安設備嘛？資安設備的效果是不是如預期？有沒有正確操作，讓資安設備發揮效用？</p></li><li><p>管理不夠落實，例如：帳號、密碼用不安全的方式傳送，讓駭客可以輕易竊取，取得服務的存取權。</p></li><li><p>重兵防守了重要資產，但跟「重要資產的相關資產」卻沒有做好防禦，導致駭客可以選擇防禦較薄弱的相關資產作為中繼點作為入侵點，進而入侵重要資產。</p></li></ol><h2 id="第二個思考點—-駭客想要的是什麼？"><a href="#第二個思考點—-駭客想要的是什麼？" class="headerlink" title="第二個思考點— 駭客想要的是什麼？"></a>第二個思考點— 駭客想要的是什麼？</h2><p><img src="https://cdn-images-1.medium.com/max/2000/0*JzhU45_BUeQ4iOCc.png"></p><p>駭客在攻擊時想要取得的是「重要資產」，透過每一層的漏洞逐步的接近重要資產，進而拿下。</p><p>這邊介紹一個名詞叫做<strong>瑞士乳酪模型（Swiss Cheese Model）</strong>，這個模型是在描述的是當威脅透過層層防護層的失誤（乳酪的層數），最終造成危害。</p><p><img src="https://cdn-images-1.medium.com/max/2000/0*4fuHcwwH19-Xe_If.png"></p><p>而應用在資安領域上，指的是駭客透過層層防禦的漏洞或是疏私，鑽過了瑞士起司模型的空隙，最終拿下重要資產。</p><p>下圖名詞解釋：FW（Firewall 防火牆），IPS（ Intrusion Prevention System）入侵預防系統，WAF（Web Application Firewall），Antivirus 防毒軟體。</p><p><img src="https://cdn-images-1.medium.com/max/8064/1*ey5xW9SXZheUxK5pc48Baw.png"></p><p>雖然每一個漏洞個別來看風險價值都不高，但以駭客的戰略思維來說，目標是要取得重要資產。也就是說這些「弱點拆開來看價值不高，但結合起來卻可以讓駭客拿下極高價值的重要資產」。</p><p>也就是說，如果我們以駭客的思維來檢視我們的企業防禦機制，我們會更主動的去思考哪些點是重要的、是我們原本沒有注意到的。</p><h2 id="第三個思考點-—-駭客如何決定攻擊的手法"><a href="#第三個思考點-—-駭客如何決定攻擊的手法" class="headerlink" title="第三個思考點 — 駭客如何決定攻擊的手法"></a>第三個思考點 — 駭客如何決定攻擊的手法</h2><p>駭客的攻擊的已經越來越具有系統化的趨勢，美國非營利資安組織 MITRE 提出 <a href="https://attack.mitre.org/">ATT&amp;CK</a>，讓攻擊的流程變成簡單易懂模型，讓資安業者在討論網路攻擊手法時有統一的標準去依循，有共通的名詞來討論攻擊的手法。</p><p><img src="https://cdn-images-1.medium.com/max/2810/1*fOkwKeoDxDYdeLPL9Z3Tlg.png"></p><p>上方紅色框框是可以採用的攻擊策略，直的藍色框框標示的是可以使用的攻擊技巧。</p><p><img src="https://cdn-images-1.medium.com/max/2742/1*kCAjLU6W_NMzwTU3jmQ5Fw.png"></p><p>從這邊我們可以發現，攻擊的策略已經變得非常模組化，並且有很多種攻擊手法可以使用。如果我們想要防禦的話，我們必須知道更貼近駭客的思考方式，哪一種攻擊手法是最有可能被某種駭客組織採用。哪些攻擊手法耗費的時間成本較低，所以需要優先防禦。</p><h2 id="第四個思考點-—-到底駭客會怎麼打？"><a href="#第四個思考點-—-到底駭客會怎麼打？" class="headerlink" title="第四個思考點 — 到底駭客會怎麼打？"></a>第四個思考點 — 到底駭客會怎麼打？</h2><p>我們知道了駭客有一個大型的資料庫，可以決定策略與攻擊技巧，但是駭客到底會用哪一種方式來攻擊？</p><p><strong>「<a href="https://devco.re/services/red-team">紅隊演練</a>」</strong>就是解決這個問題的方法，資安人員模擬駭客全面性的攻擊，在不影響企業營運下，無所不用其極的模仿駭客攻擊企業，協助企業發掘弱點，讓企業面對攻擊時可以更好的應對。</p><p>而 <a href="https://devco.re/">Devcore</a> 就是這一方面的好手，這也是為什麼我說「一個講者都是駭客的研討會」，每位講者都具有頂級駭客的身手，因為他們有頂級的身手，所以他們可以在真實世界的駭客找到你的漏洞之前就先發掘到你的企業的漏洞。讓你更完善的做好防禦。</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>這次的參加體驗我覺得非常的棒，活動本身是免費的，業配的成份卻很低，議程的資安技術的分享和實戰攻防經驗的分享都是非常珍貴的，從來沒遇到一個研討會有如此系統化的規劃整個議程與帶給與會者完整的概念。</p><p>整個研討會環繞著同一主軸，從攻擊者的角度出發，來思考我們應該如何防禦，如何讓攻擊者覺得很難打，進而放棄。擺脫以往單點式防禦，防禦了一個點，駭客卻選擇其他容易攻陷的地方著手。</p><p>另外值得一提的是， DEVCORE 成員不僅實力非常高強，表現出來的感覺也都非常的有活力，讓我見識到「頂尖的人才如何兼顧技術能力與熱情」。感覺是真的覺得很好玩，所以非常快樂的研究如何攻破人家的防禦系統。</p><h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><p>這篇文章大部分資料出自「<a href="https://devco.re/blog/2019/10/09/def-strategy/">以攻擊者的角度制定防禦策略</a>」的學習心得。這些是官方釋出的文章，內容更加全面。</p><p>本篇文章因為想要用簡單通俗的語句讓更多人了解資安，所以省略了滿多細節，如果你是資安人員、想精進資安能力或是企業用戶想要了解更深入的話，請看 DEVCORE 的專業文章：</p><ul><li><p><a href="https://devco.re/blog/2019/10/09/def-strategy/">以攻擊者的角度制定防禦策略</a></p></li><li><p><a href="https://devco.re/blog/2019/10/24/evolution-of-DEVCORE-red-team-and-the-next/">DEVCORE 紅隊的進化，與下一步</a></p></li><li><p><a href="https://devco.re/blog/2019/11/11/HiNet-GPON-Modem-RCE/">你用它上網，我用它進你內網! 中華電信數據機遠端代碼執行漏洞</a></p></li></ul><p>感謝大家看到最後，如果喜歡我的文章，歡迎追蹤我。<br>如果覺得我寫的不錯，請幫我拍個手。<br>你的鼓勵是我的寫作的動力！</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*TXQ2bQyvK30J_-y7Y-Z7Lg.gif"></p><pre><code>用拍手表達你的心情～支持 = 10下不錯 = 20下可以 = 30下很棒 = 40下激推 = 50下*小秘技：按著拍手可以連拍呦！！*</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;駭客是怎麼思考的？｜從-Devcore-Conf-學駭客思維&quot;&gt;&lt;a href=&quot;#駭客是怎麼思考的？｜從-Devcore-Conf-學駭客思維&quot; class=&quot;headerlink&quot; title=&quot;駭客是怎麼思考的？｜從 Devcore Conf 學駭客思維&quot;&gt;&lt;/a&gt;駭客是怎麼思考的？｜從 Devcore Conf 學駭客思維&lt;/h2&gt;&lt;h3 id=&quot;媽阿，原來電影裡演的都是真的&quot;&gt;&lt;a href=&quot;#媽阿，原來電影裡演的都是真的&quot; class=&quot;headerlink&quot; title=&quot;媽阿，原來電影裡演的都是真的&quot;&gt;&lt;/a&gt;媽阿，原來電影裡演的都是真的&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/12048/1*ge80giZjL7EGHSLU5v00eQ.jpeg&quot; alt=&quot;Photo by [Clint Patterson](https://unsplash.com/@cbpsc1?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/hacker?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText)&quot;&gt;&lt;/p&gt;
&lt;p&gt;Hello 大家好，我是 Luka，一名喜歡追新技術並喜歡做些有趣嘗試的工程師。這次來的是分享參加 DEVCORE CONF 2019 的心得與收獲。&lt;/p&gt;
&lt;p&gt;這篇以 Web 前端、後端工程師的角度來分享參加 DEVCORE CONF 2019 的心得。適合「 Web 工程師」或是「想要多了解一點資安觀念的人」閱讀。如果你本身已經是從事資安行業了，那麼這篇文章對你來說可能太淺，請到 &lt;a href=&quot;https://devco.re/&quot;&gt;DEVCORE 官網&lt;/a&gt; 觀看專業的技術文章。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Harbor" scheme="https://luka.tw/tags/Harbor/"/>
    
    <category term="Docker" scheme="https://luka.tw/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Mysql - 如何修改 partition 並還原資料</title>
    <link href="https://luka.tw/2018/03/04/old%20posts/2018-03-04-modify-and-restore-mysql-partition/"/>
    <id>https://luka.tw/2018/03/04/old%20posts/2018-03-04-modify-and-restore-mysql-partition/</id>
    <published>2018-03-04T04:50:00.000Z</published>
    <updated>2021-10-03T17:05:35.175Z</updated>
    
    <content type="html"><![CDATA[<p>在測試環境中我們想要置換 partition 的分區方式，而我們不想要遺失測試資料，所以需要備份 partition table 的資料。因為要修改的資料欄位很多，我不想要直接使用 alter table 的方式來修改 partition 分區，取而代之的是，我想要用 Migration 的方式來管理，所以會採用先備份 -&gt; 修改 -&gt; 接著再還原的方式。</p><span id="more"></span><h2 id="深入了解-mysqldump"><a href="#深入了解-mysqldump" class="headerlink" title="深入了解 mysqldump"></a>深入了解 mysqldump</h2><p>一般我們在備份還原的時候會使用 Mysqldump，並使用還原指令來還原。但是因為這次我需要回復的資料已經經過 Partition 分區了。用一般的回復方式很可能會失敗。秉持的實驗精神，我就來看看 mysqldump 到底是怎麼運作的。輸入指令備份資料庫：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">mysqldump -u username -p your_database &gt; dump.sql<br></code></pre></td></tr></table></figure><p>產生出來的檔案我們打開來看:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs sql"># dump.sql<br><span class="hljs-comment">-- MySQL dump 10.13  Distrib 5.7.20, for osx10.11 (x86_64)</span><br><span class="hljs-comment">--</span><br><span class="hljs-comment">-- Host: localhost    Database: log_sharding</span><br><span class="hljs-comment">-- ------------------------------------------------------</span><br><span class="hljs-comment">-- Server version5.7.20</span><br><br><span class="hljs-comment">/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */</span>;<br><span class="hljs-comment">/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */</span>;<br><span class="hljs-comment">/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */</span>;<br><span class="hljs-comment">/*!40101 SET NAMES utf8 */</span>;<br><span class="hljs-comment">/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */</span>;<br><span class="hljs-comment">/*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */</span>;<br><span class="hljs-comment">/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */</span>;<br><span class="hljs-comment">/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */</span>;<br><span class="hljs-comment">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;NO_AUTO_VALUE_ON_ZERO&#x27; */</span>;<br><span class="hljs-comment">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */</span>;<br><br><span class="hljs-comment">--</span><br><span class="hljs-comment">-- Table structure for table `alert_logs`</span><br><span class="hljs-comment">--</span><br><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `alert_logs`;<br><span class="hljs-comment">/*!40101 SET @saved_cs_client     = @@character_set_client */</span>;<br><span class="hljs-comment">/*!40101 SET character_set_client = utf8 */</span>;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `alert_logs` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `alert_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `alert_code` <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `alert_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `alert_time` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `alert_status` tinyint(<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span>,<br>  `created_at` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;2055-06-01 00:00:00&#x27;</span>,<br>  `updated_at` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`,`created_at`),<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">4899</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_unicode_ci<br><span class="hljs-comment">/*!50500 PARTITION BY RANGE  COLUMNS(alert_time)</span><br><span class="hljs-comment">(PARTITION p001 VALUES LESS THAN (&#x27;2018-01-01 00:00:00&#x27;) ENGINE = InnoDB,</span><br><span class="hljs-comment"> PARTITION p002 VALUES LESS THAN (&#x27;2018-02-01 00:00:00&#x27;) ENGINE = InnoDB,</span><br><span class="hljs-comment"> PARTITION p003 VALUES LESS THAN (&#x27;2018-03-01 00:00:00&#x27;) ENGINE = InnoDB,</span><br><span class="hljs-comment"> PARTITION p004 VALUES LESS THAN (&#x27;2018-04-01 00:00:00&#x27;) ENGINE = InnoDB,</span><br><span class="hljs-comment"> .</span><br><span class="hljs-comment"> .</span><br><span class="hljs-comment"> .</span><br><span class="hljs-comment"> .</span><br><span class="hljs-comment"> PARTITION p451 VALUES LESS THAN (MAXVALUE) ENGINE = InnoDB) */</span>;<br><span class="hljs-comment">/*!40101 SET character_set_client = @saved_cs_client */</span>;<br><br><br><span class="hljs-comment">--</span><br><span class="hljs-comment">-- Dumping data for table `alert_logs`</span><br><span class="hljs-comment">--</span><br><br>LOCK TABLES `alert_logs` WRITE;<br><span class="hljs-comment">/*!40000 ALTER TABLE `alert_logs` DISABLE KEYS */</span>;<br># This <span class="hljs-keyword">is</span> fake data<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `alert_logs` <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">16</span>,<span class="hljs-number">4</span>),(<span class="hljs-number">49</span>,<span class="hljs-number">12</span>),(<span class="hljs-number">9</span>,<span class="hljs-number">14</span>),(<span class="hljs-number">21</span>,<span class="hljs-number">17</span>),(<span class="hljs-number">11</span>,<span class="hljs-number">57</span>),(<span class="hljs-number">71</span>,<span class="hljs-number">63</span>),(<span class="hljs-number">270</span>,<span class="hljs-number">91</span>),(<span class="hljs-number">86</span>,<span class="hljs-number">180</span>),(<span class="hljs-number">125</span>,<span class="hljs-number">193</span>),(<span class="hljs-number">99</span>,<span class="hljs-number">201</span>),(<span class="hljs-number">189</span>,<span class="hljs-number">385</span>),(<span class="hljs-number">271</span>,<span class="hljs-number">390</span>),(<span class="hljs-number">225</span>,<span class="hljs-number">415</span>),(<span class="hljs-number">305</span>,<span class="hljs-number">484</span>),(<span class="hljs-number">251</span>,<span class="hljs-number">543</span>),(<span class="hljs-number">309</span>,<span class="hljs-number">545</span>),(<span class="hljs-number">257</span>,<span class="hljs-number">579</span>),(<span class="hljs-number">258</span>,<span class="hljs-number">581</span>),(<span class="hljs-number">260</span>,<span class="hljs-number">585</span>),(<span class="hljs-number">261</span>,<span class="hljs-number">588</span>),(<span class="hljs-number">279</span>,<span class="hljs-number">667</span>);<br><span class="hljs-comment">/*!40000 ALTER TABLE `alert_logs` ENABLE KEYS */</span>;<br>UNLOCK TABLES;<br><br></code></pre></td></tr></table></figure><p>這不就是 SQL 的指令嘛？ 邏輯如下:</p><ol><li>如果 <code>alert_logs</code> table 已經存在，就刪除掉並使用 Dump File 內的備份指令重新建立 <code>alert_logs</code> table</li><li>lock 住整個 table 並加入資料。</li></ol><p>從這些步驟我們可以觀察到即使 db 內已經存在 alert_logs table 了，使用 dump.sql 還原時仍然會先刪除 alert_logs table，再使用 dump.sql 中的 schema 來重建 table。</p><p>知道這些情報之後 partition 的 backup 與 restore 有了頭緒。</p><h2 id="Partition-backup-and-restore"><a href="#Partition-backup-and-restore" class="headerlink" title="Partition backup and restore"></a>Partition backup and restore</h2><p>首先備份原先的 partition</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysqldump <span class="hljs-operator">-</span>h <span class="hljs-string">&#x27;your-my-sql-ip&#x27;</span> <span class="hljs-operator">-</span>u your_user_name <span class="hljs-operator">-</span>p your_database_name table_name_1 table_name_2 <span class="hljs-comment">--no-create-info  --ssl-ca=your_ssl.pem &gt; dump.sql</span><br></code></pre></td></tr></table></figure><p>關鍵在於: 需要加上 <code>--no-create-info</code> 產生的 dump.sql 不會把本來的 table 刪除，直接 insert 資料。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql"># dump.sql<br><span class="hljs-comment">-- MySQL dump 10.13  Distrib 5.7.20, for osx10.11 (x86_64)</span><br><span class="hljs-comment">--</span><br><span class="hljs-comment">-- Host: localhost    Database: pro_devel</span><br><span class="hljs-comment">-- ------------------------------------------------------</span><br><span class="hljs-comment">-- Server version5.7.20</span><br><br><span class="hljs-comment">/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */</span>;<br><span class="hljs-comment">/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */</span>;<br><span class="hljs-comment">/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */</span>;<br><span class="hljs-comment">/*!40101 SET NAMES utf8 */</span>;<br><span class="hljs-comment">/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */</span>;<br><span class="hljs-comment">/*!40103 SET TIME_ZONE=&#x27;+00:00&#x27; */</span>;<br><span class="hljs-comment">/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */</span>;<br><span class="hljs-comment">/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */</span>;<br><span class="hljs-comment">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;NO_AUTO_VALUE_ON_ZERO&#x27; */</span>;<br><span class="hljs-comment">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */</span>;<br><br><span class="hljs-comment">--alert_logs</span><br><span class="hljs-comment">-- Dumping data for table `alert_logs`</span><br><span class="hljs-comment">--</span><br><br>LOCK TABLES `alert_logs` WRITE;<br><span class="hljs-comment">/*!40000 ALTER TABLE `alert_logs` DISABLE KEYS */</span>;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `alert_logs` <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">16</span>,<span class="hljs-number">4</span>),(<span class="hljs-number">49</span>,<span class="hljs-number">12</span>),(<span class="hljs-number">9</span>,<span class="hljs-number">14</span>),(<span class="hljs-number">21</span>,<span class="hljs-number">17</span>),(<span class="hljs-number">11</span>,<span class="hljs-number">57</span>),(<span class="hljs-number">71</span>,<span class="hljs-number">63</span>),(<span class="hljs-number">270</span>,<span class="hljs-number">91</span>),(<span class="hljs-number">86</span>,<span class="hljs-number">180</span>),(<span class="hljs-number">125</span>,<span class="hljs-number">193</span>),(<span class="hljs-number">99</span>,<span class="hljs-number">201</span>),(<span class="hljs-number">189</span>,<span class="hljs-number">385</span>),(<span class="hljs-number">271</span>,<span class="hljs-number">390</span>),(<span class="hljs-number">225</span>,<span class="hljs-number">415</span>),(<span class="hljs-number">305</span>,<span class="hljs-number">484</span>),(<span class="hljs-number">251</span>,<span class="hljs-number">543</span>),(<span class="hljs-number">309</span>,<span class="hljs-number">545</span>),(<span class="hljs-number">257</span>,<span class="hljs-number">579</span>),(<span class="hljs-number">258</span>,<span class="hljs-number">581</span>),(<span class="hljs-number">260</span>,<span class="hljs-number">585</span>),(<span class="hljs-number">261</span>,<span class="hljs-number">588</span>),(<span class="hljs-number">279</span>,<span class="hljs-number">667</span>);<br><span class="hljs-comment">/*!40000 ALTER TABLE `alert_logs` ENABLE KEYS */</span>;<br>UNLOCK TABLES;<br></code></pre></td></tr></table></figure><p>備份完資料後我們將原有的 database 刪除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">DROP TABLE alert_logs;<br></code></pre></td></tr></table></figure><p>用新的 create partition 方法建立 table，將本來用 alert_time 做分區，改成用 created_at 做分區。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">CREATE TABLE `alert_logs` (<br>  `id` int(11) NOT NULL AUTO_INCREMENT,<br>  `alert_id` int(11) DEFAULT NULL,<br>  `alert_code` varchar(30) COLLATE utf8_unicode_ci DEFAULT NULL,<br>  `alert_name` varchar(64) COLLATE utf8_unicode_ci DEFAULT NULL,<br>  `alert_time` datetime DEFAULT NULL,<br>  `alert_status` tinyint(2) DEFAULT &#x27;0&#x27;,<br>  `created_at` datetime NOT NULL DEFAULT &#x27;2055-06-01 00:00:00&#x27;,<br>  `updated_at` datetime DEFAULT NULL,<br>  PRIMARY KEY (`id`,`created_at`),<br>) ENGINE=InnoDB AUTO_INCREMENT=4899 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci<br>/*!50500 PARTITION BY RANGE  COLUMNS(created_at)<br>(PARTITION p001 VALUES LESS THAN (&#x27;2018-01-01 00:00:00&#x27;) ENGINE = InnoDB,<br> PARTITION p002 VALUES LESS THAN (&#x27;2018-02-01 00:00:00&#x27;) ENGINE = InnoDB,<br> PARTITION p003 VALUES LESS THAN (&#x27;2018-03-01 00:00:00&#x27;) ENGINE = InnoDB,<br> PARTITION p004 VALUES LESS THAN (&#x27;2018-04-01 00:00:00&#x27;) ENGINE = InnoDB,<br> .<br> .<br> .<br> .<br> PARTITION p451 VALUES LESS THAN (MAXVALUE) ENGINE = InnoDB) */;<br>/*!40101 SET character_set_client = @saved_cs_client */;<br></code></pre></td></tr></table></figure><p>最後將資料還原</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">mysql -u username -p database_name &lt; dump.sql<br></code></pre></td></tr></table></figure><p>檢視一下目前的 table</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> alert_logs;<br></code></pre></td></tr></table></figure><p>確認結果是否正確<br>檢視一下目前的 table</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> alert_logs;<br></code></pre></td></tr></table></figure><p>輸出</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `alert_logs` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `alert_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `alert_code` <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `alert_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">COLLATE</span> utf8_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `alert_time` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `alert_status` tinyint(<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span>,<br>  `created_at` datetime <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `updated_at` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`,`created_at`),<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">4899</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8_unicode_ci<br><span class="hljs-comment">/*!50500 PARTITION BY RANGE  COLUMNS(created_at)</span><br><span class="hljs-comment">(PARTITION p001 VALUES LESS THAN (&#x27;2018-01-01 00:00:00&#x27;) ENGINE = InnoDB,</span><br><span class="hljs-comment"> PARTITION p002 VALUES LESS THAN (&#x27;2018-02-01 00:00:00&#x27;) ENGINE = InnoDB,</span><br><span class="hljs-comment"> PARTITION p003 VALUES LESS THAN (&#x27;2018-03-01 00:00:00&#x27;) ENGINE = InnoDB,</span><br><span class="hljs-comment"> PARTITION p004 VALUES LESS THAN (&#x27;2018-04-01 00:00:00&#x27;) ENGINE = InnoDB,</span><br><span class="hljs-comment"> .</span><br><span class="hljs-comment"> .</span><br><span class="hljs-comment"> .</span><br><span class="hljs-comment"> .</span><br><span class="hljs-comment"> PARTITION p451 VALUES LESS THAN (MAXVALUE) ENGINE = InnoDB) */</span>;<br><span class="hljs-comment">/*!40101 SET character_set_client = @saved_cs_client */</span>;<br></code></pre></td></tr></table></figure><p>確認建立 table 的資料無誤後，<br>進入 Rails console 試試看 AlertLog 是否可以正常存取，<br>這樣就完成了整個 partition 轉換並還原的流程。</p><h3 id="地雷-created-at"><a href="#地雷-created-at" class="headerlink" title="地雷 - created_at"></a>地雷 - created_at</h3><p>需要特別注意的是 - partition 中 為 key 的值一定必須是 <code>NOT NULL</code>，且<code>不要設 DEFAULT VALUE</code>，否則 Rails 不會幫你自動填入 created_at。</p><h2 id="Rails-Migration"><a href="#Rails-Migration" class="headerlink" title="Rails Migration"></a>Rails Migration</h2><p>如果你使用的是 Rails Migration，步驟是:</p><ol><li>backup entire database</li><li>dump the partition database</li><li>rake db:rollback</li><li>modify migration of partition</li><li>rake db:migrate</li><li>restore partition database</li></ol><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="http://www.dbastuff.net/2014/09/mysql-dump-and-partitions.html">DBAStuff: Mysql Dump and partitions</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在測試環境中我們想要置換 partition 的分區方式，而我們不想要遺失測試資料，所以需要備份 partition table 的資料。因為要修改的資料欄位很多，我不想要直接使用 alter table 的方式來修改 partition 分區，取而代之的是，我想要用 Migration 的方式來管理，所以會採用先備份 -&amp;gt; 修改 -&amp;gt; 接著再還原的方式。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Database" scheme="https://luka.tw/tags/Database/"/>
    
    <category term="Mysql" scheme="https://luka.tw/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>[譯] 使用 AWS Ruby SDK v2 更新 S3 物件 Metadata</title>
    <link href="https://luka.tw/2018/01/25/old%20posts/2018-01-25-use-aws-ruby-sdk-to-update-s3-metadata/"/>
    <id>https://luka.tw/2018/01/25/old%20posts/2018-01-25-use-aws-ruby-sdk-to-update-s3-metadata/</id>
    <published>2018-01-25T07:32:00.000Z</published>
    <updated>2021-10-03T17:05:35.173Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>From: <a href="https://mattboldt.com/updating-s3-object-metadata-in-ruby/">Updating S3 Object Metadata With the AWS Ruby SDK v2</a><br>Author: Matt<br>posted at: 2017/5/31</p></blockquote><p>今天我在 S3 就如同在玩火一樣 - 弄壞了一個網站. 我做了研究，徹底的測試了我的程式碼，接著按下了 enter. 之後沒多久，我的心掉落的和我的網站掛掉的速度一樣快。我決定寫下一篇速記來防止同樣的錯誤發生在其他人身上。</p><span id="more"></span><h2 id="S3-不是資料庫"><a href="#S3-不是資料庫" class="headerlink" title="S3 不是資料庫"></a>S3 不是資料庫</h2><p>不可能在 S3 中做到「更新」資料庫 - 在S3並沒有更新資料的方法。這在 Ruby SDK 與 AWS CLI 之中都是成立的。如果你項我一樣在找尋更新整個 Bucket 的物件來更新 metadata (舉例來說: 像是名為 <code>Cache-Control</code> 的 headers)，你將會需要使用 <code>copy_to</code> 方法。</p><p>讓我們開始認證和攫取我們的 bucket。</p><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rb"><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;aws-sdk&#x27;</span><br><br>Aws.config.update(&#123;<br>  <span class="hljs-symbol">region:</span> <span class="hljs-string">&#x27;us-east-1&#x27;</span>,<br>  <span class="hljs-symbol">credentials:</span> Aws::Credentials.new(&lt;AWS_ACCESS_KEY&gt;, &lt;AWS_SECRET_KEY&gt;)<br>&#125;)<br>s3 = Aws::S3::Resource.new<br>bucket = s3.bucket(<span class="hljs-string">&#x27;mattboldt-bucket&#x27;</span>)<br></code></pre></td></tr></table></figure><p>現在我們可以透過每一個物件和複製它自己並且帶上一些新的 metadata. 注意我們使用 option <code>metadata_directive: &#39;REPLACE&#39;</code> - 這個將會以新的 metadata <em>取代</em>物件原有的 metadata。如果缺少它，我們將無法複製任何新的，而且會得到錯誤訊息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">This copy request is illegal because it is trying to copy an object to itself without changing the object&#x27;s metadata, storage class, website redirect location or encryption attributes<br></code></pre></td></tr></table></figure><p>然而，取代 metadata 將會取代其它屬於這個物件的所有東西，例如: 權限(permission). 請勿執行以下的代碼。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># the WRONG way<br>bucket.objects.each do |object_summary|<br>  location = &quot;#&#123;bucket.name&#125;/#&#123;object_summary.key&#125;&quot;<br>  options = &#123;<br>    cache_control: &#x27;public, max-age=60&#x27;,<br>    metadata_directive: &#x27;REPLACE&#x27; # options: &#x27;COPY&#x27; or &#x27;REPLACE&#x27;<br>  &#125;<br>  object_summary.copy_to(location, options)<br>end<br></code></pre></td></tr></table></figure><p>這是我所搞砸的。我更新的所有的 S3 物件因為缺少了讀的權限(read permissions)，接著 CDN 不再可以存取這些資料。現在看起來是一個很蠢的錯誤，但當時我對出錯的狀況沒有任何頭緒。</p><h2 id="更新-複製物件並且保留原有的資訊"><a href="#更新-複製物件並且保留原有的資訊" class="headerlink" title="更新 / 複製物件並且保留原有的資訊"></a>更新 / 複製物件並且保留原有的資訊</h2><p>讓我們再試一次；這次我們確保 request 包含(include)所有物件的欄位。這邊是一個可能的選項清單( list of possible options)，用途是傳送到 <code>copy_to</code> 方法。</p><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rb">COPY_TO_OPTIONS = [<span class="hljs-symbol">:multipart_copy</span>, <span class="hljs-symbol">:content_length</span>, <span class="hljs-symbol">:copy_source_client</span>, <span class="hljs-symbol">:copy_source_region</span>, <span class="hljs-symbol">:acl</span>, <span class="hljs-symbol">:cache_control</span>, <span class="hljs-symbol">:content_disposition</span>, <span class="hljs-symbol">:content_encoding</span>, <span class="hljs-symbol">:content_language</span>, <span class="hljs-symbol">:content_type</span>, <span class="hljs-symbol">:copy_source_if_match</span>, <span class="hljs-symbol">:copy_source_if_modified_since</span>, <span class="hljs-symbol">:copy_source_if_none_match</span>, <span class="hljs-symbol">:copy_source_if_unmodified_since</span>, <span class="hljs-symbol">:expires</span>, <span class="hljs-symbol">:grant_full_control</span>, <span class="hljs-symbol">:grant_read</span>, <span class="hljs-symbol">:grant_read_acp</span>, <span class="hljs-symbol">:grant_write_acp</span>, <span class="hljs-symbol">:metadata</span>, <span class="hljs-symbol">:metadata_directive</span>, <span class="hljs-symbol">:tagging_directive</span>, <span class="hljs-symbol">:server_side_encryption</span>, <span class="hljs-symbol">:storage_class</span>, <span class="hljs-symbol">:website_redirect_location</span>, <span class="hljs-symbol">:sse_customer_algorithm</span>, <span class="hljs-symbol">:sse_customer_key</span>, <span class="hljs-symbol">:sse_customer_key_md5</span>, <span class="hljs-symbol">:ssekms_key_id</span>, <span class="hljs-symbol">:copy_source_sse_customer_algorithm</span>, <span class="hljs-symbol">:copy_source_sse_customer_key</span>, <span class="hljs-symbol">:copy_source_sse_customer_key_md5</span>, <span class="hljs-symbol">:request_payer</span>, <span class="hljs-symbol">:tagging</span>, <span class="hljs-symbol">:use_accelerate_endpoint</span>]<br></code></pre></td></tr></table></figure><p>用這個 List 武裝之後，我們抓取所有存在的資料並且 merge 到新的 option hash。我只想要加上驗證 (valid) 選項而不是使用 <code>get</code> 取得所有資訊，所以我使用 <code>Array#slice</code> 來對之前的清單做處理。</p><p>也需要注意的是，我使用在下面 <code>object_summary.get</code> - 這是因為物件的摘要並不包含 metadata, permission … 之類的東西。這會造成額外的開銷，但是此時我不確定還有其他任何方法可以達到同樣的目的。</p><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rb">bucket.objects.each <span class="hljs-keyword">do</span> <span class="hljs-params">|object_summary|</span><br>  object = object_summary.get<br>  location = <span class="hljs-string">&quot;<span class="hljs-subst">#&#123;bucket.name&#125;</span>/<span class="hljs-subst">#&#123;object_summary.key&#125;</span>&quot;</span><br><br>  <span class="hljs-comment"># Build a new options object</span><br>  options = &#123;&#125;<br><br>  <span class="hljs-comment"># Merge in the object&#x27;s existing properties</span><br>  existing_options = object.to_h.slice(*COPY_TO_OPTIONS)<br>  options.merge!(existing_options)<br><br>  <span class="hljs-comment"># Add our new updates</span><br>  <span class="hljs-comment"># The `acl` option here was very important in my case!</span><br>  options.merge!(&#123;<br>    <span class="hljs-symbol">acl:</span> <span class="hljs-string">&#x27;public-read&#x27;</span>, <span class="hljs-comment"># private, public-read, public-read-write, authenticated-read, aws-exec-read, bucket-owner-read, bucket-owner-full-control</span><br>    <span class="hljs-symbol">cache_control:</span> <span class="hljs-string">&#x27;public, max-age=60&#x27;</span>,<br>    <span class="hljs-symbol">metadata_directive:</span> <span class="hljs-string">&#x27;REPLACE&#x27;</span><br>  &#125;)<br><br>  <span class="hljs-comment"># multipart_copy is necessary if the object is 5GB+</span><br>  <span class="hljs-keyword">if</span> object.size &gt;= <span class="hljs-number">5_000_000_000</span><br>    options.merge!(&#123;<span class="hljs-symbol">multipart_copy:</span> <span class="hljs-literal">true</span>&#125;)<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-comment"># Only used if multipart_copy is true</span><br>    options.delete(<span class="hljs-symbol">:content_length</span>)<br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-comment"># Execute the copy!</span><br>  object_summary.copy_to(location, options)<br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>如果你的 bucket 的大小很大，這會用到一些時間。然而，你得知道 <code>copy_to</code> 方法發出請求至 S3 和不會從你的本地端上傳任何的資料。所以即使你複製到新的位置，你也不會重新上傳檔案。</p><p><a href="https://gist.githubusercontent.com/mattboldt/6052bac987c16b73563d4d6c56d7509b/raw/d317cde9653592d4553e7665e632937dffb327e8/s3-updater.rb">這邊</a>是完整的程式碼：</p><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs rb"><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;aws-sdk&#x27;</span><br><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;active_support&#x27;</span><br><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;active_support/core_ext&#x27;</span><br><br><span class="hljs-comment"># http://docs.aws.amazon.com/sdkforruby/api/Aws/S3/Object.html#copy_to-instance_method</span><br>COPY_TO_OPTIONS = [<span class="hljs-symbol">:multipart_copy</span>, <span class="hljs-symbol">:content_length</span>, <span class="hljs-symbol">:copy_source_client</span>, <span class="hljs-symbol">:copy_source_region</span>, <span class="hljs-symbol">:acl</span>, <span class="hljs-symbol">:cache_control</span>, <span class="hljs-symbol">:content_disposition</span>, <span class="hljs-symbol">:content_encoding</span>, <span class="hljs-symbol">:content_language</span>, <span class="hljs-symbol">:content_type</span>, <span class="hljs-symbol">:copy_source_if_match</span>, <span class="hljs-symbol">:copy_source_if_modified_since</span>, <span class="hljs-symbol">:copy_source_if_none_match</span>, <span class="hljs-symbol">:copy_source_if_unmodified_since</span>, <span class="hljs-symbol">:expires</span>, <span class="hljs-symbol">:grant_full_control</span>, <span class="hljs-symbol">:grant_read</span>, <span class="hljs-symbol">:grant_read_acp</span>, <span class="hljs-symbol">:grant_write_acp</span>, <span class="hljs-symbol">:metadata</span>, <span class="hljs-symbol">:metadata_directive</span>, <span class="hljs-symbol">:tagging_directive</span>, <span class="hljs-symbol">:server_side_encryption</span>, <span class="hljs-symbol">:storage_class</span>, <span class="hljs-symbol">:website_redirect_location</span>, <span class="hljs-symbol">:sse_customer_algorithm</span>, <span class="hljs-symbol">:sse_customer_key</span>, <span class="hljs-symbol">:sse_customer_key_md5</span>, <span class="hljs-symbol">:ssekms_key_id</span>, <span class="hljs-symbol">:copy_source_sse_customer_algorithm</span>, <span class="hljs-symbol">:copy_source_sse_customer_key</span>, <span class="hljs-symbol">:copy_source_sse_customer_key_md5</span>, <span class="hljs-symbol">:request_payer</span>, <span class="hljs-symbol">:tagging</span>, <span class="hljs-symbol">:use_accelerate_endpoint</span>]<br><br>Aws.config.update(&#123;<br>  <span class="hljs-symbol">region:</span> <span class="hljs-string">&#x27;us-east-1&#x27;</span>,<br>  <span class="hljs-symbol">credentials:</span> Aws::Credentials.new(AWS_ACCESS_KEY, AWS_SECRET_KEY)<br>&#125;)<br>s3 = Aws::S3::Resource.new<br>bucket = s3.bucket(<span class="hljs-string">&#x27;mattboldt-bucket&#x27;</span>)<br>objects_count = bucket.objects.count<br>current_object = <span class="hljs-number">0</span><br><br>bucket.objects.each <span class="hljs-keyword">do</span> <span class="hljs-params">|object_summary|</span><br><br>  <span class="hljs-comment"># Get the object and all its metadata, permissions, etc</span><br>  object = object_summary.get<br>  <span class="hljs-comment"># Copy to the same location</span><br>  location = <span class="hljs-string">&quot;<span class="hljs-subst">#&#123;bucket.name&#125;</span>/<span class="hljs-subst">#&#123;object_summary.key&#125;</span>&quot;</span><br><br>  <span class="hljs-comment"># Build a new options object</span><br>  options = &#123;&#125;<br><br>  <span class="hljs-comment"># Merge in the object&#x27;s existing properties, but only keeping valid attributes for the copy_to method</span><br>  existing_options = object.to_h.slice(*COPY_TO_OPTIONS)<br>  options.merge!(existing_options)<br><br>  <span class="hljs-comment"># Add our new updates</span><br>  options.merge!(&#123;<br>    <span class="hljs-symbol">acl:</span> <span class="hljs-string">&#x27;public-read&#x27;</span>, <span class="hljs-comment"># private, public-read, public-read-write, authenticated-read, aws-exec-read, bucket-owner-read, bucket-owner-full-control</span><br>    <span class="hljs-symbol">cache_control:</span> <span class="hljs-string">&#x27;public, max-age=60&#x27;</span>,<br>    <span class="hljs-symbol">metadata_directive:</span> <span class="hljs-string">&#x27;REPLACE&#x27;</span><br>  &#125;)<br><br>  <span class="hljs-comment"># multipart_copy is necessary if the object is 5GB+</span><br>  <span class="hljs-keyword">if</span> object.size &gt;= <span class="hljs-number">5_000_000_000</span><br>    options.merge!(&#123;<span class="hljs-symbol">multipart_copy:</span> <span class="hljs-literal">true</span>&#125;)<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-comment"># Only used if multipart_copy is true</span><br>    options.delete(<span class="hljs-symbol">:content_length</span>)<br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">begin</span><br>    object_summary.copy_to(location, options)<br>    current_object += <span class="hljs-number">1</span><br>    puts <span class="hljs-string">&quot;Copied <span class="hljs-subst">#&#123;current_object&#125;</span> of <span class="hljs-subst">#&#123;objects_count&#125;</span>&quot;</span><br>  <span class="hljs-keyword">rescue</span> =&gt; e<br>    puts <span class="hljs-string">&quot;Excption Raised: <span class="hljs-subst">#&#123;e&#125;</span>&quot;</span><br>  <span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="最後"><a href="#最後" class="headerlink" title="最後"></a>最後</h2><p>如果你覺得這對你有幫助, 請 <a href="https://twitter.com/atmattb">tweet @atMattb</a>。謝謝閱讀。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;From: &lt;a href=&quot;https://mattboldt.com/updating-s3-object-metadata-in-ruby/&quot;&gt;Updating S3 Object Metadata With the AWS Ruby SDK v2&lt;/a&gt;&lt;br&gt;Author: Matt&lt;br&gt;posted at: 2017/5/31&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我在 S3 就如同在玩火一樣 - 弄壞了一個網站. 我做了研究，徹底的測試了我的程式碼，接著按下了 enter. 之後沒多久，我的心掉落的和我的網站掛掉的速度一樣快。我決定寫下一篇速記來防止同樣的錯誤發生在其他人身上。&lt;/p&gt;</summary>
    
    
    
    
    <category term="AWS" scheme="https://luka.tw/tags/AWS/"/>
    
    <category term="S3" scheme="https://luka.tw/tags/S3/"/>
    
  </entry>
  
  <entry>
    <title>[譯] Amazon S3 Delimiter and Prefix</title>
    <link href="https://luka.tw/2018/01/03/old%20posts/2018-01-03-aws-s3-delimiter-and-prefix/"/>
    <id>https://luka.tw/2018/01/03/old%20posts/2018-01-03-aws-s3-delimiter-and-prefix/</id>
    <published>2018-01-03T04:50:00.000Z</published>
    <updated>2021-10-03T17:05:35.172Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>From: <a href="https://realguess.net/2014/05/24/amazon-s3-delimiter-and-prefix/">Amazon S3 Delimiter and Prefix - realguess</a><br>posted at 2014/05/24</p></blockquote><p><a href="https://aws.amazon.com/tw/s3/">AWS S3</a> 是一個不昂貴的線上檔案儲存服務，我們可以透過 <a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html">javascript SDK</a> 來使用 S3。當我使 SDK 的時候有以下幾件令人疑惑的事情:</p><span id="more"></span><ol><li>如何使用參數 <code>Delimiter</code> 和 <code>Prefix</code> ?</li><li><code>CommonPrefixes</code> 與 <code>Contents</code> 的差別是什麼?</li><li>如何透過 Javascript SDK 建立 folder / directory</li></ol><p>取回在 Amazon S3 Bucket 的物件得操作 (operation) 是 <code>listObject</code>. <code>listObjects</code> 不會回傳 (return) 物件的內容, 而會回傳 key 與 meta data 像是物件的大小 (size) 或是物件的擁有者。</p><p>使用指令呼叫以取得 bucket 中的物件清單:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">s3.listObjects(params, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><code>params</code> 可以設置以下的參數:</p><ul><li>Bucket</li><li>Delimiter</li><li>EncodingType</li><li>Marker</li><li>MaxKeys</li><li>Prefix</li></ul><p>但是什麼是 <code>Delimeter</code> 和 <code>Prefix</code>? 如何使用他們?</p><p>我們開始在 S3 中創建一些物件，格式如下方的檔案結構。這可以用 Aws Console 很快的完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.<br>├── directory<br>│   ├── directory<br>│   │   └── file<br>│   └── file<br>└── file<br>2 directories, 3 files<br></code></pre></td></tr></table></figure><p>在 Amazon S3 中，這些物件為:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">directory/<br>directory/directory/<br>directory/directory/file<br>directory/file<br>file<br></code></pre></td></tr></table></figure><p>一個需要留心的事情是 S3 不是檔案系統。S3 並沒有真正的檔案或是資料夾的概念。<br>從 Console 中看到的是 2 個資料夾和 3 個檔案。但是它們全部都是物件。這些物件<br>會用他們的 Key 值按照字母排序。</p><p>為了讓概念更清楚點，我們來調用 (invoke) 方法 <code>listObjects</code>。而這個操作只需要參數 <code>Bucket</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">params = &#123;<br>  Bucket: &#x27;example&#x27;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Response <code>data</code> 包含下列的 callback function:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123; Contents:<br>   [ &#123; Key: &#x27;directory/&#x27;,<br>       LastModified: ...,<br>       ETag: &#x27;<span class="hljs-string">&quot;d41d8cd98f00b204e9800998ecf8427e&quot;</span>&#x27;,<br>       Size: <span class="hljs-number">0</span>,<br>       Owner: [Object],<br>       StorageClass: &#x27;STANDARD&#x27; &#125;,<br>     &#123; Key: &#x27;directory/directory/&#x27;,<br>       LastModified: ...,<br>       ETag: &#x27;<span class="hljs-string">&quot;d41d8cd98f00b204e9800998ecf8427e&quot;</span>&#x27;,<br>       Size: <span class="hljs-number">0</span>,<br>       Owner: [Object],<br>       StorageClass: &#x27;STANDARD&#x27; &#125;,<br>     &#123; Key: &#x27;directory/directory/file&#x27;,<br>       LastModified: ...,<br>       ETag: &#x27;<span class="hljs-string">&quot;d41d8cd98f00b204e9800998ecf8427e&quot;</span>&#x27;,<br>       Size: <span class="hljs-number">0</span>,<br>       Owner: [Object],<br>       StorageClass: &#x27;STANDARD&#x27; &#125;,<br>     &#123; Key: &#x27;directory/file&#x27;,<br>       LastModified: ...,<br>       ETag: &#x27;<span class="hljs-string">&quot;d41d8cd98f00b204e9800998ecf8427e&quot;</span>&#x27;,<br>       Size: <span class="hljs-number">0</span>,<br>       Owner: [Object],<br>       StorageClass: &#x27;STANDARD&#x27; &#125;,<br>     &#123; Key: &#x27;file&#x27;,<br>       LastModified: ...,<br>       ETag: &#x27;<span class="hljs-string">&quot;d41d8cd98f00b204e9800998ecf8427e&quot;</span>&#x27;,<br>       Size: <span class="hljs-number">0</span>,<br>       Owner: [Object],<br>       StorageClass: &#x27;STANDARD&#x27; &#125; ],<br>  CommonPrefixes: [],<br>  Name: &#x27;example&#x27;,<br>  Prefix: &#x27;&#x27;,<br>  Marker: &#x27;&#x27;,<br>  MaxKeys: <span class="hljs-number">1000</span>,<br>  IsTruncated: <span class="hljs-literal">false</span> &#125;<br></code></pre></td></tr></table></figure><p>如果有檔案結構，你會期待是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">directory/<br>file<br></code></pre></td></tr></table></figure><p>但是並沒有，因為 bucket 運作的方式不像是 folder 或是 directory, 能夠顯示<br>directory 中的檔案。檔案在 bucket 中會全部攤開來並且照字母排列。</p><p>在 Unit 中, directory 是檔案, 但是在 Amazon S3 中, 所有的東西都是物件,<br>並且他們用 key 來識別。</p><p>所以，該如何讓 Amazon S3 表現的更像是 folder 或是 directory？ 或如何顯示 Bucket 中的第一層右邊的內容?</p><p>為了讓 S3 顯示的更像是 director, 你必須使用 <code>Delimiter</code> 和 <code>Prefix</code>. <code>Delimeter</code> 讓你可以為 key 分組 (use to group keys)。它必須是一個字元或者一個字串。<code>Prefix</code> 限制 response 開始於特別的 prefix。</p><h2 id="Delimiter"><a href="#Delimiter" class="headerlink" title="Delimiter"></a>Delimiter</h2><p>我們開始加入下列的 <code>delimiter</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">params = &#123;<br>  Bucket: &#x27;example&#x27;,<br>  Delimiter: &#x27;/&#x27;<br>&#125;;<br></code></pre></td></tr></table></figure><p>你會取得像是 directory 清單的一些資訊:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123; Contents:<br>   [ &#123; Key: &#x27;file&#x27; &#125; ],<br>  CommonPrefixes: [ &#123; Prefix: &#x27;directory/&#x27; &#125; ],<br>  Name: &#x27;example&#x27;,<br>  Prefix: &#x27;&#x27;,<br>  MaxKeys: 1000,<br>  Delimiter: &#x27;/&#x27;,<br>  IsTruncated: false &#125;<br></code></pre></td></tr></table></figure><p>有一個資料夾叫做 <code>directory/</code> 和一個檔案叫做 <code>file</code>. 發生的事情是下列的物件接受檔案被 delimeter <code>/</code> 分組。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">directory/<br>directory/directory/<br>directory/directory/file<br>directory/file<br>file<br></code></pre></td></tr></table></figure><p>所以，結果是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">directory/<br>file<br></code></pre></td></tr></table></figure><p>這感覺像是 <code>directory</code> 或是 <code>folder</code> 的清單。但如果我們把 <code>Delimeter</code> 改成 <code>i</code>, 接著你會取得空的 <code>Contents</code> 和 prefix。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123; Contents: [],<br>  CommonPrefixes: [ &#123; Prefix: &#x27;di&#x27; &#125;, &#123; Prefix: &#x27;fi&#x27; &#125; ],<br>  Name: &#x27;example&#x27;,<br>  Prefix: &#x27;&#x27;,<br>  MaxKeys: 1000,<br>  Delimiter: &#x27;i&#x27;,<br>  IsTruncated: false &#125;<br></code></pre></td></tr></table></figure><p>所有的 key 被 <code>di</code> 和 <code>fi</code> 這兩個 prefix 分組。因此，Amazon S3 不是檔案系統, 但是他們如果可以設定對的參數，那他們看起來就會像是檔案系統。</p><p>如之前提到的 <code>Delimeter</code> 不需要是單一的字元:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123; Contents:<br>   [ &#123; Key: &#x27;directory/&#x27; &#125;,<br>     &#123; Key: &#x27;directory/file&#x27; &#125;,<br>     &#123; Key: &#x27;file&#x27; &#125; ],<br>  CommonPrefixes: [ &#123; Prefix: &#x27;directory/directory&#x27; &#125; ],<br>  Name: &#x27;example&#x27;,<br>  Prefix: &#x27;&#x27;,<br>  MaxKeys: 1000,<br>  Delimiter: &#x27;/directory&#x27;,<br>  IsTruncated: false &#125;<br></code></pre></td></tr></table></figure><p>回想 bucket 的結構:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">directory/<br>directory/directory/<br>directory/directory/file<br>directory/file<br>file<br></code></pre></td></tr></table></figure><p>由於分組字串<code>/directory</code>，<code>directory/directory/</code> 和 <code>directory/directory/file</code> 被 prefix <code>directory/directory</code> 分組了。</p><p>我們來試試其他的 <code>Delimiter: &#39;directory&#39;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123; Contents:<br>   [ &#123; Key: &#x27;file&#x27; &#125; ],<br>  CommonPrefixes: [ &#123; Prefix: &#x27;directory&#x27; &#125; ],<br>  Name: &#x27;example&#x27;,<br>  Prefix: &#x27;&#x27;,<br>  MaxKeys: 1000,<br>  Delimiter: &#x27;directory&#x27;,<br>  IsTruncated: false &#125;<br></code></pre></td></tr></table></figure><p>好，接著來試試 <code>ry/fi</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123; Contents:<br>   [ &#123; Key: &#x27;directory/&#x27; &#125;,<br>     &#123; Key: &#x27;directory/directory/&#x27; &#125;,<br>     &#123; Key: &#x27;file&#x27; &#125; ],<br>  CommonPrefixes:<br>   [ &#123; Prefix: &#x27;directory/directory/fi&#x27; &#125;,<br>     &#123; Prefix: &#x27;directory/fi&#x27; &#125; ],<br>  Name: &#x27;example,<br>  Prefix: &#x27;&#x27;,<br>  MaxKeys: 1000,<br>  Delimiter: &#x27;ry/fi&#x27;,<br>  IsTruncated: false &#125;<br></code></pre></td></tr></table></figure><p>所以記得 <code>Delimeter</code> 只是提供將 key 分組的功能。如果你想要他們表現的像是<br>檔案系統，那麼使用 <code>Delimiter: &#39;/&#39;</code>。</p><h2 id="Prefix"><a href="#Prefix" class="headerlink" title="Prefix"></a>Prefix</h2><p><code>Prefix</code> 更易於理解。它利用前綴來過濾(filter) keys。</p><p>相同的結構:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">directory/<br>directory/directory/<br>directory/directory/file<br>directory/file<br>file<br></code></pre></td></tr></table></figure><p>我們來設定 <code>Prefix</code> 參數值為 <code>directory</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123; Contents:<br>   [ &#123; Key: &#x27;directory/&#x27; &#125;,<br>     &#123; Key: &#x27;directory/directory/&#x27; &#125;,<br>     &#123; Key: &#x27;directory/directory/file&#x27; &#125;,<br>     &#123; Key: &#x27;directory/file&#x27; &#125; ],<br>  CommonPrefixes: [],<br>  Name: &#x27;example&#x27;,<br>  Prefix: &#x27;directory&#x27;,<br>  MaxKeys: 1000,<br>  IsTruncated: false &#125;<br></code></pre></td></tr></table></figure><p>看看設定成 <code>directory/</code> 會怎麼樣:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123; Contents:<br>   [ &#123; Key: &#x27;directory/&#x27; &#125;,<br>     &#123; Key: &#x27;directory/directory/&#x27; &#125;,<br>     &#123; Key: &#x27;directory/directory/file&#x27; &#125;,<br>     &#123; Key: &#x27;directory/file&#x27; &#125; ],<br>  CommonPrefixes: [],<br>  Prefix: &#x27;directory/&#x27; &#125;<br></code></pre></td></tr></table></figure><p>prefix 設成 <code>directory</code> 和 <code>directory/</code> 是一樣的。<br>如果我們嘗試一些不一樣的, <code>Prefix: &#39;directory/d&#39;</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123; Contents:<br>   [ &#123; Key: &#x27;directory/directory/&#x27; &#125;,<br>     &#123; Key: &#x27;directory/directory/file&#x27; &#125; ],<br>  CommonPrefixes: [],<br>  Prefix: &#x27;directory/d&#x27; &#125;<br></code></pre></td></tr></table></figure><p>同時使用 <code>Delimiter: &#39;directory&#39;</code> and<code> Prefix: &#39;directory&#39;</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123; Contents:<br>   [ &#123; Key: &#x27;directory/&#x27; &#125;,<br>     &#123; Key: &#x27;directory/file&#x27; &#125; ],<br>  CommonPrefixes: [ &#123; Prefix: &#x27;directory/directory&#x27; &#125; ],<br>  Prefix: &#x27;directory&#x27;,<br>  Delimiter: &#x27;directory&#x27; &#125;<br></code></pre></td></tr></table></figure><p>第一步，列出 prefix 是 <code>directory</code> 的清單:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">directory/<br>directory/directory/<br>directory/directory/file<br>directory/file<br></code></pre></td></tr></table></figure><p>用 delimiter <code>directory</code> 與 prefix <code>directory</code> 來分組:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">directory/directory<br></code></pre></td></tr></table></figure><p>結果的 <code>Contents</code> 會是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">directory/<br>directory/file<br></code></pre></td></tr></table></figure><p><code>CommonPrefixes</code> 會是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">directory/directory<br></code></pre></td></tr></table></figure><p>也許改變 <code>Delimeter</code> 成 <code>i</code> 可以更好的理解:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123; Contents:<br>   [ &#123; Key: &#x27;directory/&#x27; &#125; ],<br>  CommonPrefixes: [ &#123; Prefix: &#x27;directory/di&#x27; &#125;, &#123; Prefix: &#x27;directory/fi&#x27; &#125; ],<br>  Prefix: &#x27;directory&#x27;,<br>  Delimiter: &#x27;i&#x27; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">directory/               # key to show<br>directory/directory/     # group to &#x27;directory/di&#x27;<br>directory/directory/file # group to &#x27;directory/di&#x27;<br>directory/file           # Group to &#x27;directory/fi&#x27;<br>file                     # ignored due to prefix<br></code></pre></td></tr></table></figure><p>一個使用 Amazon S3 來列出 directory 的好處是你不需要顧慮巢狀的資料夾結構，<br>所有東西都是扁平化的。所以你可以藉由特定的 <code>Prefix</code> 來 <code>loop</code> 出你要的資料。</p><h2 id="Directory-Folder"><a href="#Directory-Folder" class="headerlink" title="Directory / Folder"></a>Directory / Folder</h2><p>如果你使用 Amazon AWS console 來 <code>Create Folder</code>，你可以建立資料夾或是<br>上傳檔案在該資料夾中。實際上，你使用了下列的 key 建立了兩個物件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">directory/<br>directory/file<br></code></pre></td></tr></table></figure><p>如果你使用下列指令來上傳檔案，資料夾不會被建立:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">aws s3 cp file s3://example/directory/file<br></code></pre></td></tr></table></figure><p>因為，Amazon S3 不是檔案系統，而是 key/value 的儲存空間。如果你使用 <code>listObjects</code> 方法，你可以看到一個物件。<br>同理，你無法複製本地的資料夾：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">$ aws s3 cp directory s3://example/directory<br>upload failed: aws/ to s3://example/directory [Errno 21] Is a directory: u&#x27;/home/chao/tmp/directory/&#x27;<br></code></pre></td></tr></table></figure><p>但我們可以用 JavaScript SDK 來創建 <code>directory/folder</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">s3.putObject(&#123; Bucket: &#x27;example&#x27;, Key: &#x27;directory/&#x27; &#125;, function (err, data) &#123;<br>  if (err) &#123; return console.error(err); &#125;<br>  console.log(data);<br>&#125;);<br></code></pre></td></tr></table></figure><p>需要筆記的地方是: 你必須使用 <code>directory/</code>，結尾必須是斜線。此外，這只是一個檔案而不是資料夾。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;From: &lt;a href=&quot;https://realguess.net/2014/05/24/amazon-s3-delimiter-and-prefix/&quot;&gt;Amazon S3 Delimiter and Prefix - realguess&lt;/a&gt;&lt;br&gt;posted at 2014/05/24&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/tw/s3/&quot;&gt;AWS S3&lt;/a&gt; 是一個不昂貴的線上檔案儲存服務，我們可以透過 &lt;a href=&quot;https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html&quot;&gt;javascript SDK&lt;/a&gt; 來使用 S3。當我使 SDK 的時候有以下幾件令人疑惑的事情:&lt;/p&gt;</summary>
    
    
    
    
    <category term="AWS" scheme="https://luka.tw/tags/AWS/"/>
    
    <category term="S3" scheme="https://luka.tw/tags/S3/"/>
    
  </entry>
  
  <entry>
    <title>Web 基本功 - Cookie 與 Session</title>
    <link href="https://luka.tw/2017/12/22/old%20posts/2017-12-22-web-foundation-the-different-of-cookie-and-session/"/>
    <id>https://luka.tw/2017/12/22/old%20posts/2017-12-22-web-foundation-the-different-of-cookie-and-session/</id>
    <published>2017-12-22T06:11:00.000Z</published>
    <updated>2021-10-03T17:05:35.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="1-1-什麼是-Cookie"><a href="#1-1-什麼是-Cookie" class="headerlink" title="1.1 什麼是 Cookie ?"></a>1.1 什麼是 Cookie ?</h3><p>Cookie 在使用者第一次進入網站的時候產生。Browser 記錄一些隱私性較低的資料。<br>例如: 使用者第一次進入網站的時候會跳出教學視窗。當使用者點擊[關閉]後，Cookie<br>內記錄使用者已經看過教學了。使用者在下次登入的時候因為 Cookie 內記錄著使用者<br>已經看過教學，所以就不會跳出教學視窗。</p><h3 id="1-2-Cookie-的特性"><a href="#1-2-Cookie-的特性" class="headerlink" title="1.2 Cookie 的特性"></a>1.2 Cookie 的特性</h3><ul><li>每個網站的 Cookie 是分開的, 例如: <a href="http://www.google.com/">www.google.com</a> 無法取得 <a href="http://www.yahoo.com/">www.yahoo.com</a> 的 cookie。</li><li>能夠設定失效的時間。比如說過一段時間你就需要重新登入，就是由設定 Cookie Expired Time 來完成。有時候為了方便，也可能將 Cookie 設定為永久不失效。</li></ul><h3 id="1-3-Server-端如何讓-Browser-儲存-Cookie"><a href="#1-3-Server-端如何讓-Browser-儲存-Cookie" class="headerlink" title="1.3 Server 端如何讓 Browser 儲存 Cookie"></a>1.3 Server 端如何讓 Browser 儲存 Cookie</h3><ol><li>Client 請求 Server 給予頁面</li><li>Server 回 Response 給 Browser 的時候，HTTP Header 帶上 <code>Set-Cookie</code>。Browser 接收到 Set-Cookie 指令時，會將 Cookie 的名稱和值儲存在 Browser 的 Cookie。</li></ol><p><img src="https://lh3.googleusercontent.com/-ivTQRwbrQzs/WjyiAfiRepI/AAAAAAAAK7Y/8pjRBORXGEIKxyP7bjFTiEHjPYroooXQwCHMYCw/I/15139142578413.jpg"></p><h3 id="1-4-Browser-在每次-Request-的時候會帶上-Cookie"><a href="#1-4-Browser-在每次-Request-的時候會帶上-Cookie" class="headerlink" title="1.4 Browser 在每次 Request 的時候會帶上 Cookie"></a>1.4 Browser 在每次 Request 的時候會帶上 Cookie</h3><p>Browser 在每次對 Server 發出 Request 的時候會帶上 <code>Cookie</code> 的 Header，讓 Server 能夠正確的存取當前 Cookie。</p><p><img src="https://lh3.googleusercontent.com/-316qWgn_JFg/WjyiAwnYu4I/AAAAAAAAK7c/jUqct0G-OeIYDDq5DxyM_rR1azOAClRnwCHMYCw/I/15139133853587.jpg"></p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="2-1-什麼是-Session"><a href="#2-1-什麼是-Session" class="headerlink" title="2.1 什麼是 Session"></a>2.1 什麼是 Session</h3><p>Session 就像你進入一個遊樂園，手上先蓋個章，下次進入的時候就知道你是誰。<br>遊樂園就好比是 Server，你就好比是 Client (Browser)。<br>Client 要怎麼儲存這個章呢? 有兩種方法:</p><ol><li>使用 Cookie (set cookie)</li><li>使用 html 儲存，例如: hidden input。</li></ol><p>拿章去 Server 換資料也有兩種方法:</p><ol><li>使用 Cookie</li><li>Query string/POST</li></ol><p>因為實作上的方便程度與效能考量，大部分的網站採用 Cookie 來完成 Session 的實作。</p><h3 id="2-2-Cookie-based-Session-與-Session-Storage"><a href="#2-2-Cookie-based-Session-與-Session-Storage" class="headerlink" title="2.2 Cookie-based Session 與 Session Storage"></a>2.2 Cookie-based Session 與 Session Storage</h3><p>Cookie-based Session 指的 Session 儲存的方式不同，而不是拿章去 Server 換資料的時候有沒有使用 Cookie。</p><p>常見的 Session Storage 有這幾種:</p><ol><li>Database</li><li>Memcached</li><li>Cookie</li></ol><h3 id="2-3-比較-Cookie-based-Session-與-Memcached-Store-Session"><a href="#2-3-比較-Cookie-based-Session-與-Memcached-Store-Session" class="headerlink" title="2.3 比較 Cookie-based Session 與 Memcached Store Session"></a>2.3 比較 Cookie-based Session 與 Memcached Store Session</h3><p>來比較一下這兩者的優缺點。 Cookie-based Session 的優點:</p><ul><li>對伺服器的效能負擔很低</li><li>方便使用</li></ul><p>缺點:</p><ul><li>大小最多存4Kb。</li><li>資料存放在瀏覽器上如果 <code>config/secrets.yml</code> 外流可能存在被破解的風險 (詳見 <a href="http://tech.shaolin.tw/posts/2013/12/17/security-issue-of-rails-cookiestore-mechanism/">Rails CookieStore 的安全議題</a>)。</li></ul><p>Memcached Store Session 的優點:</p><ol><li>memcached 使用記憶體來儲存，讀取速度快。</li><li>可以實現集中式管理。</li><li>不會受到 cookie 4kb 大小的限制。</li></ol><p>缺點：</p><ol><li>儲存方式用記憶體，持久化有疑慮。</li><li>在追求高性能高併發的情景下，cookies 的表現更好，因此很多大網站採用 cookies 作為 session store.</li></ol><h3 id="2-4-Session-傳值"><a href="#2-4-Session-傳值" class="headerlink" title="2.4 Session 傳值"></a>2.4 Session 傳值</h3><p>Session 傳值指的是利用 Session 儲存資料的機制，讓不同頁面間可以互相傳遞資料。</p><ol><li>使用 Query String 或是 POST 把資料往 Server 傳</li><li>Server 將收到的資料存到 Session 中。</li><li>在不同頁面的時候因為你的章是同一個，可以讀取 Session 中儲存的資料也是同一份，達到傳值的目的。</li></ol><h2 id="Rails-中的-Cookie-based-Session-安全性問題"><a href="#Rails-中的-Cookie-based-Session-安全性問題" class="headerlink" title="Rails 中的 Cookie-based Session 安全性問題"></a>Rails 中的 Cookie-based Session 安全性問題</h2><p>Rails 3 以前 cookie-based session 如果不特別設定，可以輕易的被解開:</p><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rb"><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;base64&#x27;</span><br>session_cookie = <span class="hljs-string">&#x27;your session cookie&#x27;</span><br>Marshal.load(Base64.decode64(sesson_cookie.split(<span class="hljs-string">&#x27;--&#x27;</span>).first))<br></code></pre></td></tr></table></figure><p>解開後會像這個樣子</p><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rb">&#123;<br>        <span class="hljs-string">&quot;session_id&quot;</span> =&gt; <span class="hljs-string">&quot;3223668cb4b04296c006e190ce2b1a17&quot;</span>,<br>    <span class="hljs-string">&quot;user_return_to&quot;</span> =&gt; <span class="hljs-string">&quot;/&quot;</span>,<br>             <span class="hljs-string">&quot;flash&quot;</span> =&gt; #&lt;ActionDispatch::Flash::FlashHash:0x007f80d1090250 @used=#&lt;Set: &#123;:alert&#125;&gt;, <span class="hljs-variable">@closed</span>=<span class="hljs-literal">false</span>, <span class="hljs-variable">@flashes</span>=&#123;<span class="hljs-symbol">:alert=&gt;<span class="hljs-string">&quot;You need to sign in or sign up before continuing.&quot;</span></span>, <span class="hljs-symbol">:warning=&gt;nil</span>, <span class="hljs-symbol">:error=&gt;nil</span>, <span class="hljs-symbol">:notice=&gt;nil</span>&#125;, <span class="hljs-variable">@now</span>=<span class="hljs-literal">nil</span>&gt;,<br>       <span class="hljs-string">&quot;_csrf_token&quot;</span> =&gt; <span class="hljs-string">&quot;BxX8rLulhq2v2YSKrLxIIkYeV4IYNTNceT2ib1BrO08=&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Rails 4 以後的 Cookie-based Session 會經過 Secret 加密。好好保護你的 <code>config/secret.yml</code> 能夠讓 Session 中的隱密資料不會被解開，從下面 code 可以看出要解開的話需要不少的麻煩:</p><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rb"><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;rubygems&#x27;</span><br><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;cgi&#x27;</span><br><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;active_support&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decrypt_session_cookie</span><span class="hljs-params">(cookie, key)</span></span><br>  cookie = CGI::unescape(cookie)<br><br>  <span class="hljs-comment"># Default values for Rails 4 apps</span><br>  key_iter_num = <span class="hljs-number">1000</span><br>  key_size     = <span class="hljs-number">64</span><br>  salt         = <span class="hljs-string">&quot;encrypted cookie&quot;</span><br>  signed_salt  = <span class="hljs-string">&quot;signed encrypted cookie&quot;</span><br><br>  key_generator = ActiveSupport::KeyGenerator.new(key, <span class="hljs-symbol">iterations:</span> key_iter_num)<br>  secret = key_generator.generate_key(salt)<br>  sign_secret = key_generator.generate_key(signed_salt)<br><br>  encryptor = ActiveSupport::MessageEncryptor.new(secret, sign_secret)<br>  puts encryptor.decrypt_and_verify(cookie)<br><span class="hljs-keyword">end</span><br><br><br><span class="hljs-comment"># Time to test ... (With data from Arbeit327)</span><br>cookie = <span class="hljs-string">&#x27;WVFQVTFtbmNxWWJPODZNb3NUMVZzZGtDVjZQNXpMYStFMWdiZlJPMkdjRFRBOGZ5T3pOTzBPKzk3NWxvQUJvTlRRU2t4MXZmdG8rT0I0R2M3Ulh0YXpxRVhNMll5UW1xUHhvVXBLbXozZ3ZyNjB4VDU4dWRIUkxBWjBXbDJhci93YkYrZWswUHdFL0hUNDJaUHo2cEpxbXFvdlFZMjJWVU9KTWhHb3NyalFwTkphd0pUQVZSTXRHbkVqRlFnSGpNVTNFQlVxYlRmT3pWbXNjK0JuQ3FydzQvODRhbmtuU29haGNRbXQ4T3o1ZjhqMk53WTRMa0pVd1hPb2NHTVFQY3dvanE2ZElqUk1Mc21HS0k2SHVuZEZ3OWhjdzZPQnRSMEdVVkQwL2IxSVh5QzNSWVlJZms5c1JJV0lzUE1Zb1NHbEtqYm5nTGRKd1ZSdGpOQ1RZZWthR1A2anRFMEluaTcyWTNaNHJBR1N0dklzMkg1RjVmVmY4azEzV3o0N2Z2LS1wQlowRUZ6cjI3SVFQU0F5bGlYSDNnPT0%3D--19650cc5c3e2599fb43b7235ab4de5a1ce8a46ac&#x27;</span><br>key = <span class="hljs-string">&#x27;aeb977de013ade650b97e0aa5246813591104017871a7753fe186e9634c9129b367306606878985c759ca4fddd17d955207011bb855ef01ed414398b4ac8317b&#x27;</span><br><br>decrypt_session_cookie(cookie, key)<br></code></pre></td></tr></table></figure><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><p><a href="http://blog.hellojcc.tw/2016/01/12/introduce-session-and-cookie/">介紹 Session 及 Cookie 兩者的差別說明</a></p><p><a href="http://fred-zone.blogspot.tw/2014/01/web-session.html">FRED - Web 技術中的 Session 是什麼？</a></p><p><a href="http://tech.shaolin.tw/posts/2013/12/17/security-issue-of-rails-cookiestore-mechanism/">Rails CookieStore 的安全議題 - Shaolin.TW</a></p><p><a href="https://blog.miniasp.com/post/2008/02/22/Explain-HTTP-Cookie-in-Detail.aspx">The Will Will Web - 解釋 Cookie 的特性</a></p><p><a href="https://gist.github.com/profh/e36e5dd0bec124fef04c">A simple script to decode Rails 4 session cookies</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;Cookie&quot;&gt;&lt;/a&gt;Cookie&lt;/h2&gt;&lt;h3 id=&quot;1-1-什麼是-Cookie&quot;&gt;&lt;a href=&quot;#1-1-什麼是-Cookie&quot; class=&quot;headerlink&quot; title=&quot;1.1 什麼是 Cookie ?&quot;&gt;&lt;/a&gt;1.1 什麼是 Cookie ?&lt;/h3&gt;&lt;p&gt;Cookie 在使用者第一次進入網站的時候產生。Browser 記錄一些隱私性較低的資料。&lt;br&gt;例如: 使用者第一次進入網站的時候會跳出教學視窗。當使用者點擊[關閉]後，Cookie&lt;br&gt;內記錄使用者已經看過教學了。使用者在下次登入的時候因為 Cookie 內記錄著使用者&lt;br&gt;已經看過教學，所以就不會跳出教學視窗。&lt;/p&gt;
&lt;h3 id=&quot;1-2-Cookie-的特性&quot;&gt;&lt;a href=&quot;#1-2-Cookie-的特性&quot; class=&quot;headerlink&quot; title=&quot;1.2 Cookie 的特性&quot;&gt;&lt;/a&gt;1.2 Cookie 的特性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;每個網站的 Cookie 是分開的, 例如: &lt;a href=&quot;http://www.google.com/&quot;&gt;www.google.com&lt;/a&gt; 無法取得 &lt;a href=&quot;http://www.yahoo.com/&quot;&gt;www.yahoo.com&lt;/a&gt; 的 cookie。&lt;/li&gt;
&lt;li&gt;能夠設定失效的時間。比如說過一段時間你就需要重新登入，就是由設定 Cookie Expired Time 來完成。有時候為了方便，也可能將 Cookie 設定為永久不失效。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Web Foundation" scheme="https://luka.tw/tags/Web-Foundation/"/>
    
    <category term="Coockie" scheme="https://luka.tw/tags/Coockie/"/>
    
    <category term="Session" scheme="https://luka.tw/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>OLTP 與 OLAP</title>
    <link href="https://luka.tw/2017/12/22/old%20posts/2017-12-29-oltp-vs-olap/"/>
    <id>https://luka.tw/2017/12/22/old%20posts/2017-12-29-oltp-vs-olap/</id>
    <published>2017-12-22T06:11:00.000Z</published>
    <updated>2021-10-03T17:05:35.170Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什麼是-OLTP"><a href="#什麼是-OLTP" class="headerlink" title="什麼是 OLTP?"></a>什麼是 OLTP?</h2><p>最近在讀資料庫文件的時候接觸到 <code>OLTP</code> 這個名詞，大致上理解並比記下來。<br>數據處理大致可以分成兩類: OLTP 與 OLAP。OLTP (Online Analytical Processing)指的就是傳統式關聯式資料庫。用在日常的的事物處理，比如說資料庫的增、刪、查、改。有以下特性:</p><span id="more"></span><ul><li>並發性高</li><li>嚴格要求事務的種安全性</li><li>Realtime 要求高</li></ul><h2 id="什麼是-OLAP"><a href="#什麼是-OLAP" class="headerlink" title="什麼是 OLAP?"></a>什麼是 OLAP?</h2><p>OLAP (On-Line Analytical Processing) - 數據分析處理。是一個以決策為導向的數據處理方式，針對你想要做的決策，動態處理資料，用多種維度來解讀資料，讓高階主管可以做出更好的決策。</p><p>OLAP支援的分析包刮下列幾點:</p><ul><li>階層式維度與資料的模組化</li><li>趨勢分析</li><li>解讀深層資訊</li><li>於視覺範圍內轉換於另一維度以作比較</li></ul><p>個人覺得認為 OLAP 更像一種分析方法論，與現今的資料視覺概念相似，將資料經過加工處理後，由萃取出來的數據來幫助做決策。</p><h2 id="比較表"><a href="#比較表" class="headerlink" title="比較表"></a>比較表</h2><p><img src="https://lh3.googleusercontent.com/-_3M8urfGsMo/Wl8lC5-jcoI/AAAAAAAALBE/YIn4itw9oDAxRkQX0GOwY45PwU-dt4PEgCHMYCw/I/15142609010075.jpg"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://courses.cs.washington.edu/courses/cse592/01sp/lectures/class1/sld025.htm">OLTP vs. OLAP</a><br><a href="http://info.csvs.chc.edu.tw/bbhuang/homework%5C8716ds03.htm">OLAP example</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什麼是-OLTP&quot;&gt;&lt;a href=&quot;#什麼是-OLTP&quot; class=&quot;headerlink&quot; title=&quot;什麼是 OLTP?&quot;&gt;&lt;/a&gt;什麼是 OLTP?&lt;/h2&gt;&lt;p&gt;最近在讀資料庫文件的時候接觸到 &lt;code&gt;OLTP&lt;/code&gt; 這個名詞，大致上理解並比記下來。&lt;br&gt;數據處理大致可以分成兩類: OLTP 與 OLAP。OLTP (Online Analytical Processing)指的就是傳統式關聯式資料庫。用在日常的的事物處理，比如說資料庫的增、刪、查、改。有以下特性:&lt;/p&gt;</summary>
    
    
    
    
    <category term="Database" scheme="https://luka.tw/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>使用 GIT Precommit hooks 防止 Binding.pry 進入 Commit</title>
    <link href="https://luka.tw/2017/12/06/old%20posts/2017-12-06-git-precommit-hooks-copy/"/>
    <id>https://luka.tw/2017/12/06/old%20posts/2017-12-06-git-precommit-hooks-copy/</id>
    <published>2017-12-06T14:34:00.000Z</published>
    <updated>2021-10-03T17:05:35.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>如果不小心把 <code>binding.pry</code> commit 進 git 而且不幸的 push 的話, 勢必要使用另一個 commit 來修正。如果要讓這個 commit 不見可能就需要用 <code>git push -f</code> 來修改。這樣做很醜，不優雅。根治的方法是 - <code>根本不應該將 debug code 進入 commit</code> 。但是人總是會有不小心的時候。最近發現一個工具可以做到這件事情: GIT Precommit hooks。</p><h2 id="What-is-GIT-Precommit-hooks"><a href="#What-is-GIT-Precommit-hooks" class="headerlink" title="What is GIT Precommit hooks?"></a>What is GIT Precommit hooks?</h2><p>GIT Precommit hooks 是一種可以在你每次 Commit 之前的 Callback。每次 Commit 前都會執行。我們利用這個特性，可以用來檢查，防止如 <code>Binding.pry</code> 的 Debug Code    進入 Git 中。</p><h2 id="Solution-1-Use-Script"><a href="#Solution-1-Use-Script" class="headerlink" title="Solution 1 - Use Script"></a>Solution 1 - Use Script</h2><p>在你的 git 專案底下，<code>.git/hooks/pre-commit.sample</code> 這是 Precommit hook 編寫的範本。將 <code>.sample</code> 結尾去除掉，就可以真正作用在當前的 Git 專案目錄上。不過因為我們想作用的是在 Rails 專案上，所以需要客製化腳本。</p><p>這邊已經有寫好的腳本: <a href="https://raw.githubusercontent.com/Luka/githooks/master/pre-commit">Source Code</a></p><h3 id="1-1-How-to-Use"><a href="#1-1-How-to-Use" class="headerlink" title="1.1 How to Use"></a>1.1 How to Use</h3><p>切換到專案底下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">cd project_name<br></code></pre></td></tr></table></figure><p>下載腳本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">curl https://raw.githubusercontent.com/Luka/githooks/master/pre-commit &gt; .git/hooks/pre-commit<br></code></pre></td></tr></table></figure><p>讓腳本擁有執行的權限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">chmod +x .git/hooks/pre-commit<br></code></pre></td></tr></table></figure><p>做完這些已經具有自動檢查的功能了</p><h3 id="1-2-Demo"><a href="#1-2-Demo" class="headerlink" title="1.2 Demo"></a>1.2 Demo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">git commit -m &quot;hello world&quot;<br>File: app/views/company/jobs/new.html.slim:9<br>9:binding.pry<br><br>There are some occurrences of console.log|debugger|binding.pry at your modification.<br>Are you sure want to continue? (y/n)<br></code></pre></td></tr></table></figure><p>looks great!</p><h3 id="1-3-reference"><a href="#1-3-reference" class="headerlink" title="1.3 reference"></a>1.3 reference</h3><p><a href="https://cbabhusal.wordpress.com/2014/10/21/ruby-on-rails-githooks-basics/">GIT Precommit hooks Basics : Block debug command from commit</a></p><h2 id="Solution-2-Use-Gem"><a href="#Solution-2-Use-Gem" class="headerlink" title="Solution 2 - Use Gem"></a>Solution 2 - Use Gem</h2><p>如果嫌上述方法麻煩，不好管理。也可以考慮使用 Gem 來管理 Precommit Hook<br><code>Gem &#39;pre-commit&#39;</code> 可以做到這件事情。把 <code>pre-commit</code> 加入你的開發環境。</p><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><figure class="highlight rb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rb">group <span class="hljs-symbol">:development</span> <span class="hljs-keyword">do</span><br>  gem <span class="hljs-string">&quot;pre-commit&quot;</span>, <span class="hljs-symbol">require:</span> <span class="hljs-literal">false</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>接著輸入 bundle 更新 Gem Set</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">bundle<br></code></pre></td></tr></table></figure><p>設定需要的 check</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">git config pre-commit.checks &quot;[pry, debugger,yaml]&quot;<br></code></pre></td></tr></table></figure><p>要取消某個設定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">git config pre-commit.checks &quot;[pry, debugger]&quot;<br></code></pre></td></tr></table></figure><p>可檢查的項目可到 github 查詢</p><p><a href="https://github.com/jish/pre-commit">jish/pre-commit: A slightly improved pre-commit hook for git</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;p&gt;如果不小心把 &lt;code&gt;binding.pry&lt;/code&gt; commit 進 git 而且不幸的 push 的話, 勢必要使用另一個 commit 來修正。如果要讓這個 commit 不見可能就需要用 &lt;code&gt;git push -f&lt;/code&gt; 來修改。這樣做很醜，不優雅。根治的方法是 - &lt;code&gt;根本不應該將 debug code 進入 commit&lt;/code&gt; 。但是人總是會有不小心的時候。最近發現一個工具可以做到這件事情: GIT Precommit hooks。&lt;/p&gt;
&lt;h2 id=&quot;What-is-GIT-Precommit-hooks&quot;&gt;&lt;a href=&quot;#What-is-GIT-Precommit-hooks&quot; class=&quot;headerlink&quot; title=&quot;What is GIT Precommit hooks?&quot;&gt;&lt;/a&gt;What is GIT Precommit hooks?&lt;/h2&gt;&lt;p&gt;GIT Precommit hooks 是一種可以在你每次 Commit 之前的 Callback。每次 Commit 前都會執行。我們利用這個特性，可以用來檢查，防止如 &lt;code&gt;Binding.pry&lt;/code&gt; 的 Debug Code    進入 Git 中。&lt;/p&gt;
&lt;h2 id=&quot;Solution-1-Use-Script&quot;&gt;&lt;a href=&quot;#Solution-1-Use-Script&quot; class=&quot;headerlink&quot; title=&quot;Solution 1 - Use Script&quot;&gt;&lt;/a&gt;Solution 1 - Use Script&lt;/h2&gt;</summary>
    
    
    
    
    <category term="Rails" scheme="https://luka.tw/tags/Rails/"/>
    
    <category term="Time" scheme="https://luka.tw/tags/Time/"/>
    
  </entry>
  
</feed>
