{"pages":[],"posts":[{"title":"駭客是怎麼思考的？｜從 Devcore Conf 學駭客思維","text":"駭客是怎麼思考的？｜從 Devcore Conf 學駭客思維媽阿，原來電影裡演的都是真的 Hello 大家好，我是 Luka，一名喜歡追新技術並喜歡做些有趣嘗試的工程師。這次來的是分享參加 DEVCORE CONF 2019 的心得與收獲。 這篇以 Web 前端、後端工程師的角度來分享參加 DEVCORE CONF 2019 的心得。適合「 Web 工程師」或是「想要多了解一點資安觀念的人」閱讀。如果你本身已經是從事資安行業了，那麼這篇文章對你來說可能太淺，請到 DEVCORE 官網 觀看專業的技術文章。 簡單介紹一下 DEVCORE 戴夫寇爾這家資安公司，在我參加 DEVCORE CONF 之前已耳聞 DEVCORE 的大名，但我一直搞不清楚資安公司的不同之處。 參加完 DEVCORE CONF 之後，我才知道原來 DEVCORE 這麼厲害，回報了非常多的 CVE 漏洞，在國際的駭客比賽中也常獲得獎項。和他們平常到底做些什麼事情。話不多說，趕快來進入正題。 全部講者都是駭客的年會必須說這個體驗真的超狂的，一家公司獨自舉辦一個研討會，並且所有講者都是「駭客」。議程裡大概有一半是分享「如何攻陷別人的公司」的過程與方法，而且當講到攻陷時的那一刻時，你會感受到講者眼睛裡閃耀著光芒，展現出了純粹的喜悅（抖～～。 這是 DEVCORE CONFERENCE 2019 的主設計，在牆上貼著有著很大 Attack 字樣的海報，傳遞了一個訊息： 攻擊！攻擊！再攻擊！純攻擊導向的資安研討會 這實在是太有趣了，一般資安大會大部分以防禦者的角度，為了防止某種攻擊方式，所以「要用怎麼樣的方式防守」或是「要安裝怎麼樣的硬體設備來防守」。 聽完之後往往會覺得疑惑 ： 「這真的是攻擊者會採用的策略？」或是「這樣防禦真的就防的著了嘛？」，這些問題就是 DEVCORE CONF 2019 整個研討會的主軸 「從攻擊者的角度制定防禦策略」要解決的問題。 了解駭客思維，你才能了解從哪邊下手會是有效的防禦策略。 進入駭客的思考領域 第一個思考點 — 我們如何防禦駭客入侵？常見防守方式是「縱深防禦」，意思是用不同的資安設備、安全規範、服務，降低駭客入侵的可能性。 萬一不幸某個點被駭客入侵了，例如：檔案伺服器被攻陷了，讓損害局限於某處，控制損害範圍。 縱深防禦常見的被突破點： 防禦邊界超出想像。眼前的防禦邊界不是駭客眼中防禦邊界，通常忽略的地方因為你沒有想到這裡會被打，所以更容易視為被攻擊的點。 真的了解資安設備嘛？資安設備的效果是不是如預期？有沒有正確操作，讓資安設備發揮效用？ 管理不夠落實，例如：帳號、密碼用不安全的方式傳送，讓駭客可以輕易竊取，取得服務的存取權。 重兵防守了重要資產，但跟「重要資產的相關資產」卻沒有做好防禦，導致駭客可以選擇防禦較薄弱的相關資產作為中繼點作為入侵點，進而入侵重要資產。 第二個思考點— 駭客想要的是什麼？ 駭客在攻擊時想要取得的是「重要資產」，透過每一層的漏洞逐步的接近重要資產，進而拿下。 這邊介紹一個名詞叫做瑞士乳酪模型（Swiss Cheese Model），這個模型是在描述的是當威脅透過層層防護層的失誤（乳酪的層數），最終造成危害。 而應用在資安領域上，指的是駭客透過層層防禦的漏洞或是疏私，鑽過了瑞士起司模型的空隙，最終拿下重要資產。 下圖名詞解釋：FW（Firewall 防火牆），IPS（ Intrusion Prevention System）入侵預防系統，WAF（Web Application Firewall），Antivirus 防毒軟體。 雖然每一個漏洞個別來看風險價值都不高，但以駭客的戰略思維來說，目標是要取得重要資產。也就是說這些「弱點拆開來看價值不高，但結合起來卻可以讓駭客拿下極高價值的重要資產」。 也就是說，如果我們以駭客的思維來檢視我們的企業防禦機制，我們會更主動的去思考哪些點是重要的、是我們原本沒有注意到的。 第三個思考點 — 駭客如何決定攻擊的手法駭客的攻擊的已經越來越具有系統化的趨勢，美國非營利資安組織 MITRE 提出 ATT&amp;CK，讓攻擊的流程變成簡單易懂模型，讓資安業者在討論網路攻擊手法時有統一的標準去依循，有共通的名詞來討論攻擊的手法。 上方紅色框框是可以採用的攻擊策略，直的藍色框框標示的是可以使用的攻擊技巧。 從這邊我們可以發現，攻擊的策略已經變得非常模組化，並且有很多種攻擊手法可以使用。如果我們想要防禦的話，我們必須知道更貼近駭客的思考方式，哪一種攻擊手法是最有可能被某種駭客組織採用。哪些攻擊手法耗費的時間成本較低，所以需要優先防禦。 第四個思考點 — 到底駭客會怎麼打？我們知道了駭客有一個大型的資料庫，可以決定策略與攻擊技巧，但是駭客到底會用哪一種方式來攻擊？ 「紅隊演練」就是解決這個問題的方法，資安人員模擬駭客全面性的攻擊，在不影響企業營運下，無所不用其極的模仿駭客攻擊企業，協助企業發掘弱點，讓企業面對攻擊時可以更好的應對。 而 Devcore 就是這一方面的好手，這也是為什麼我說「一個講者都是駭客的研討會」，每位講者都具有頂級駭客的身手，因為他們有頂級的身手，所以他們可以在真實世界的駭客找到你的漏洞之前就先發掘到你的企業的漏洞。讓你更完善的做好防禦。 後記這次的參加體驗我覺得非常的棒，活動本身是免費的，業配的成份卻很低，議程的資安技術的分享和實戰攻防經驗的分享都是非常珍貴的，從來沒遇到一個研討會有如此系統化的規劃整個議程與帶給與會者完整的概念。 整個研討會環繞著同一主軸，從攻擊者的角度出發，來思考我們應該如何防禦，如何讓攻擊者覺得很難打，進而放棄。擺脫以往單點式防禦，防禦了一個點，駭客卻選擇其他容易攻陷的地方著手。 另外值得一提的是， DEVCORE 成員不僅實力非常高強，表現出來的感覺也都非常的有活力，讓我見識到「頂尖的人才如何兼顧技術能力與熱情」。感覺是真的覺得很好玩，所以非常快樂的研究如何攻破人家的防禦系統。 延伸閱讀這篇文章大部分資料出自「以攻擊者的角度制定防禦策略」的學習心得。這些是官方釋出的文章，內容更加全面。 本篇文章因為想要用簡單通俗的語句讓更多人了解資安，所以省略了滿多細節，如果你是資安人員、想精進資安能力或是企業用戶想要了解更深入的話，請看 DEVCORE 的專業文章： 以攻擊者的角度制定防禦策略 DEVCORE 紅隊的進化，與下一步 你用它上網，我用它進你內網! 中華電信數據機遠端代碼執行漏洞 感謝大家看到最後，如果喜歡我的文章，歡迎追蹤我。如果覺得我寫的不錯，請幫我拍個手。你的鼓勵是我的寫作的動力！ 用拍手表達你的心情～ 支持 = 10下 不錯 = 20下 可以 = 30下 很棒 = 40下 激推 = 50下 *小秘技：按著拍手可以連拍呦！！*","link":"/2019/11/19/2019-11-19/"},{"title":"用 Harbor 架設 Private Docker Registry","text":"什麼是 Docker Registry？顧名思義就是用來儲存鏡像檔 (Image) 的地方。例如：DockerHub 就是 Docker 官方提供的 Docker Registry，你可以把你自己編寫的 Dockerfile 編譯之後上傳到 Dockerhub ，讓網路上的其他人自由的下載，讓大家站在你的肩膀上寫程式。 為什麼要架設私有的 Docker Registry？在這個容器化的時代， 要使用 Kubernetes 生態系，第一步是將原本的實體機器的配置轉換成程式碼，轉換完成後變成 Dockerfile，Dockerfile 編寫著這台機器上所有的配置。 我們需要找一個地方存放由這些 Dockerfile 建立 (build) 出來的 Docker 鏡像檔，這些鏡像檔總不能放在 Dockerhub 上給大家一覽無遺吧？因此我們需要一個私有的 Docker Registry 來放置建立的 Docker 鏡像檔。 Harbor 是什麼？Harbor 是由 VMware 發行的鏡像檔儲存倉庫，就是你自行架設一個只有公司內部可以存取到的 Dockerhub，公司內部使用的鏡像檔都上傳到上面，要使用時也都從 Harbor 中拉下來 (pull image)。 Harbor 的管理介面如下 每一個專案可以有多個 Repository，而每個 Repository 可以上傳多個 Image Harbor 在 CI/CD 中扮演的角色用一張圖表來說明 Docker Registry 在 CI / CD 流程中扮演的角色： 首先我們把程式碼推上 Github，觸發 CI / CD (以 Jenkins 為例) Pipeline，Pipeline 中包含跑測試、程式碼品質檢測 … 等等的步驟，依照需求自由定義。 跑完 CI / CD Pipeline 後便會把 Docker Image 推上 Harbor。接著如果 K8S 需要取用時便會從 Harbor 拉取 (pull) 需要的版本的 Image。 註：更安全的作法是 Github 用私有的程式碼儲存庫取代，這邊為了簡單示意，用 Github 作為程式碼儲存庫的代表。 如何架設 Harbor？Harbor 的安裝方式在 Github 上面可以看到 Harbor 是 1 萬顆星星以上的大型開源專案 找到 Install &amp;&amp; Run 區域的說明，上面寫著先下載 binary 檔案，然後跟著安裝手冊操作。 我們就進入到 Harbor Release 頁面 往下卷找到 Assets 區域 這時我們點選 online installler 下載，如果在 linux 主機上可以用 wget 取得。 安裝 Docker 與 Docker Compose接著到 Harbor Installation and Configuration Guide 觀看教學逐步完成安裝，安裝 Harbor 時需要安裝 Docker 與 Docker Compose。 首先我們需要安裝 Docker，用 Ubuntu 18.04 來演練：參考 How To Install and Use Docker on Ubuntu 18.04 逐步完成 docker 安裝。 除了需要 Docker 以外，還需要 docker-compose，參考 How To Install Docker Compose on Ubuntu 18.04。 繼續安裝 Harbor取得剛剛 release 畫面獲得的安裝包位置 1wget https://github.com/goharbor/harbor/releases/download/v1.10.0/harbor-online-installer-v1.10.0.tgz 解壓縮之 1tar xvf harbor-online-installer-v1.10.0.tgz 現在你有 harbor 安裝檔資料夾 進入 harbor 資料夾，看到有幾個檔案，install.sh 就是安裝檔了，首先我們要先修改 harbor.yml 將 hostname 修改，否則直接運行 install.sh 是會發生錯誤的。除了修改 hostman 以外，修改 admin password 預設管理員密碼，可以增加安全性。 修改完成後執行 sudo ./install.sh，harbor 需要的服務就會依序被建立起來，就是這麼簡單。 此時訪問這台機器的 ip 位置，就會出現登入畫面囉！ 結語現在你擁有了一個可以放在公司內網的 Docker Registry，你可以在上面自由的上傳自己建立的 Docker Image，不用怕被看光光，是不是很棒呢。 如果喜歡我寫的文章，歡迎追蹤本人帳號 @LukaTw 與 StarBugs Weekly 星巴哥技術週刊 🙂🙂🙂","link":"/2019/12/17/2019-12-17-harbor/"},{"title":"從零開始學 DevOps — 那就選擇最簡單的 Drone CI 開始吧！","text":"目前 DevOps 已經是 Backend 或 Frontend 多多少少都會碰到的部份。而 Drone，正可以讓開發者專心開發自己的專案，每個專案獨立設定需要的 CI / CD 流程，解放前端、後端工程師的戰鬥力，將測試與部屬結合在開發流程中，降低手動測試需要的時間。話不多說，趕快開始架設第一個 Drone CI 伺服器吧。 本篇文章分為兩個部分，第一個部分來聊聊，為什麼從 Jenkins -&gt; CircleCI -&gt; Drone ，的過程。第二部分則是架設 Drone 的教學。 為什麼從 Jenkins -&gt; CircleCI -&gt; Drone第一次接觸 Drone 已經是兩年前，當時的 Drone 是 0.x 版，跟現在的 1.0 版本有不少的差異。那時候玩了一陣子 DroneCI，Docker 化了一些服務，但因為那時對 CI / CD 不甚熟悉，從 Jenkins、DroneCI 與 CircleCI 中選擇。 簡單比較 Jenkins、DroneCI、CircleCI 三套工具Jenkins 複雜度高，可以操作的東西最多。DroneCI 每個步驟都是由 Docker 產生的環境，高度的容器化，讓每個步驟可以調用不同的 Docker Image 來實現各種測試。 例如：步驟一可以用 nodejs 的 Docker image 測前端的部分，步驟二可以用 golang 的 Docker image 測試後端的框架，然後接著用傳送訊息專用的 Image 傳送 CI / CD 測試結果到 Slack。 重新採用 DroneCI 的原因這次重新採用 DroneCI 的原因是我們需要大量的 build image，用 CircleCI 來做實在很不划算，因為你用他的雲端空間就是要被吃豆腐。再者，這次已經對 Docker 有很多的熟悉度，也對 CI / CD 流程有更高的理解。 有一點需要特別說明的是，因為我是 Backend 工程師，所以比較喜歡更開發更貼近的工程師的 DroneCI，每個專案底下都有 .drone.yml，負責不同專案的開發者可以輕鬆設計自己需要的 CI/CD 流程。 而 Jenkins 還是 DevOps / SRE 的王者，功能性的強大，幾乎無所不能，不過因為我有圖型介面障礙，每次都會忘記在哪邊按，而且想要把任何東西都進版控，所以我當然是選 DroneCI 囉！ 用 DroneCI 就是要自己架DroneCI 經過 1.0 的改版後已經提供了雲端服務 drone cloud。不過 … 既然都用 Drone 了當然是要自己架！第一種架設方式是開一台機器例如： EC2，在上面安裝好 Docker、Docker Compsoe、然後下載 Drone 的壓縮檔，接著解壓縮， cd 進入資料夾後輸入 docker-compose up，這樣就架設完成囉。 自己架設的好處是，自己開的機器便宜，不想用的時候還可關掉。如果你可以清晰知道需要的 CI / CD 流程的哪些環節，並且可以快速的實作出來，用 Drone 是完全沒有問題的。 用 K8S 架設更好玩踏進 K8S 是個不小的門檻，不過 K8S 絕對是個值得投資的技術，各大雲端霸主不管是 AWS、GCP、Azure 紛紛支援 K8S，雖然乍看之下沒有顯著的好處，但是光是把所有架構的轉成程式碼 ( Infrastructure as Code ，Iac) 就是讓企業體質變好，無形中增加了許多未來的彈性與爆發力。 既然 K8S 是主流，那當然要用 K8S 來架設 Drone 囉。除了開一台機器以外，Drone 對 K8S 的整合度也是很高的，Helm 有著 Helm Hub ，就像 Docker hub 一樣，你可以在上面找到各式各樣的 Helm Chart 來建置 Drone。建置完成後還可以進入 K8S 中查看 Drone 的各個工作執行的怎麼樣。 該怎麼開始使用 Drone ?還是回到最簡單的方法，在本機或是雲端機器上安裝 docker 與 docker-compose，我們用 Github 來做為說明的範例。 Step 1 — 安裝 DroneCI進入官網，點選 Get Started 點選 install 選擇 Github 進入之後開始學習安裝方式，第一個步驟可以跳過，從第二個步驟開始，輸入 docker pull drone/drone:1 拉下來最新的 docker image。 接著，根據官方的 docker 指令來撰寫 docker-compose 檔案，我已經幫大家寫好了，複製貼上即可，儲存成 docker-compose.yml。 接著輸入 docker-compose up 啟動 drone，此時可用 docker ps -a 看看 container 有沒有正常啟動 Step 2 — 用 ngrok 讓 Port 開放 IP 讓外界存取，並加上 https到 ngrok 官網註冊帳號，不註冊的話過一段時間就會被斷線 註冊完之後會顯示以下畫面，mac 可以使用 brew install ngrok 安裝 ngrok。安裝完後使用下圖箭頭指示處的，複製貼上，在本機登入你的帳號。 之後就可以開心的使用 ngrok 綁定端口囉！ 例如在終端機中輸入 ngrok http 8081，就會把剛剛架設的 drone 伺服器 localhost 的 8081 端口綁定到特定的 ngrok 網址。這邊的網址等下需要複製貼上綁定到 Github OAuth App 上。 Step 3— Github 設定 OAuth App選擇螢幕右上方選單的 Settings 進入後選擇左下方的 Developer Settings 點選 OAuth Apps 新增 Oauth 應用程式 將剛剛建立好的 ngrok 網址填入，註冊 OAuth 應用程式。這邊雷的地方，Drone 0.8 的 callback 網址是 authorize，1.0 換成 login，文件上沒有特別著名。 當以上都設定好的時候代表你的 Drone CI 串接完成囉！訪問你的 ngrok 暫時網址，我的是 https://844f00ae.ngrok.io 。還記得 ngrok 是做什麼用的嘛，ngrok 可以讓本地端的端口暴露到網際網路。所以可以在任何地方存取的到。 登入後 drone 已經建立成功囉，紅框的網址可以替代成任何你伺服器上的網址。 我們來開啟監控一個 drone 的 project，如果這專案有改變就會觸發 CI / CD 流程。大家想要一起玩可以到這邊 fork 專案 https://github.com/go-training/drone-nodejs-example。 開啟後會顯示專案目前是開啟的狀態。只要有 commit push 即可觸發。 來試試看，加一個 commit 並 push，觸發 Drone CI 果然成功了！ 完成之後 Great！我們做出了第一個 CI / CD 系統，好處有什麼呢？今天篇幅有點長，我們留著下次再講吧 :D 下一篇 Drone CI / CD 我們來聊聊 CI / CD 的常見流程！ 如果喜歡我寫的文章，歡迎追蹤本人帳號 @LukaTw 與 StarBugs Weekly 星巴哥技術週刊🙂","link":"/2020/01/14/2020-01-14-drone/"},{"title":"Kubernetes 教學 02 — 在 Minikube 上部屬 Python Flask 應用程式","text":"Minikube、kubectl 終於派上用場囉 前情提要在 前一篇 中我們弄懂了 K8S Cluster、Node、Pod 與 Container 的關係，並且在文章末段介紹了能夠與 kubectl -「能夠與 K8S 溝通的命令列工具」。這次我們用實際的操作，來認識容器化的實際過程，並把它部屬到本地的 Kubernetes 上面。 什麼是 Minikube ？Minikube 是一個單節點的 Kubernetes Cluster，可以安裝在本機上，支援 Windows 與 Mac Minikube 只有一個 Node (節點)。 還記得 Node 是什麼嘛？來複習一下，Node 是一台實體機器，一個工作者 (worker)。上面可以搭載許多個 Pod，而 Pod 是 Kubernetes 的最小部屬單位。一個 Pod 由一個 Container 或是多個 Container 所組成。 看完之後應該還是覺得有點繞，不過沒關係，因為今天我們就要透過實作來了解 Pod 到底是什麼。 安裝 Minikube首先安裝 Minikube，請到官方網頁下載安裝，Windows、Mac、Linux 都可以安裝。 Windows 需要先安裝 Chocolatey 套件管理工具，接著輸入指令 choco install minikube 即可完成安裝。而 Mac 則可以透過 homebrew 來完成安裝 brew install minikube 起步走，開始使用 Minikube 與 kubectl安裝完 minikube 之後，第一步先啟動 Minikube，如果你是第一次啟動，Minikube 會幫你建立新的虛擬機器 (VM)。 minikube start 眼尖的你看到最後一行，啟動好 minikube 的同時，kubectl 也準備就緒了。來看看 minikube 的狀態。 minikube status 上一篇提到的 kubelet 與 api-server 已經成功跑起來。複習一下 api-server 是 Master 的元件，kubelet，則是 Node 上負責跟 Master 溝通的元件。因為 Minikube 只有單一個 Node，所以同時具備 Master 與 Node 的元件。 ref: https://kubernetes.io/docs/concepts/overview/components/ 使用 kubectl 查看目前 Cluster 中的狀態 kubectl get all 裡面只有一個 kubernetes 的 service，因為我們的 Kubenetes Cluster 中還沒有安裝任何的東西。 建立一個 Python 的 Flask Web 應用程式建立資料夾名稱為 flask_app mkdir flask_app 建立一個子資料夾 app ，並在之中建立一個 app.py 檔案 123456789101112 # flask_app/app/app.pyfrom flask import Flaskapp = Flask(__name__)@app.route(&quot;/&quot;)def hello(): return &quot;Hello, World!&quot;if __name == '__main__': app.run(debug=True, host='0.0.0.0') 建立 requirement.txt # flask_app/app/requirement.txt Flask 在本地端試跑，先安裝依賴的套件，目前只有一個就是 flask 1pip3 install -r requirements.txt 接著執行看看 1python main.py 打開 0.0.0.0:5000 即可看到以下訊息 Hello from Python! 容器化 Flask Web 應用程式建立一個 Dockerfiile，意思是用 Python 3.7 作為基本的容器，並把專案中的程式碼放進去。並在最後執行 python main.py。 123456789FROM python:3.7RUN mkdir /appWORKDIR /appADD ./app /app/RUN pip install -r requirements.txtEXPOSE 5000CMD [&quot;python&quot;, &quot;/app/main.py&quot;] 製作 docker image，並給他一個名稱flask_app 1docker build . -t flask_app 可以成功 build，沒有問題 用 docker images 查看剛剛製作的 image 跑跑看剛剛製作好的 image 1docker run -p 5001:5000 flask_app 打開 http://0.0.0.0:5001/ 一樣會看到 Hello from Python! 到這邊我們已經製作完成 Docker image。接下來就要把它部屬到 Minikube 上。 部屬 Python Flask 應用程式到 Minikube 上首先我們先來建立一個檔案 k8s.yaml 1234567891011121314151617181920212223242526272829303132333435apiVersion: v1kind: Servicemetadata: name: flask-app-servicespec: selector: app: flask-app ports: - protocol: &quot;TCP&quot; port: 5000 targetPort: 5000 type: LoadBalancer---apiVersion: apps/v1kind: Deploymentmetadata: name: flask-appspec: selector: matchLabels: app: flask-app replicas: 3 template: metadata: labels: app: flask-app spec: containers: - name: flask-app image: flask_app:latest imagePullPolicy: Never ports: - containerPort: 5000 命令列輸入，即可將 flask_app 部屬至 minikube 1kubectl apply -f k8s.yaml 部屬完的畫面 接著訪問 剛剛的 k8s.yaml 只有聲明 deployment 與 service 兩種物件，但卻產生了 3 個 pod，原因就在於，deployment 裡面聲明了需要 3 個 pod，所以會擴展出 3 個。 輸入以下指令查看暴露出來的 IP 1minikube service flask-app-service --url 訪問 http://192.168.64.8:30914 就可以看到 Kubernetes 上的 Flask 伺服器回傳的畫面。 Hello from Python! 剛剛我們撰寫 k8s.yaml 時，Service Type 使用的是 LoadBalancer，所以這可是具有負載均衡能力，並且擁有 3 個 Pod 作為支撐的服務。 是不是很神奇？今天我們做了三種 Hello from Python，分別是： 在本地端運行 Flask 伺服器 在單個 Docker 容器運行 Flask 伺服器 在 Kubernetes 中的 Cluster 運行 Flask 伺服器 一步一步的將應用程式，容器化，之後再用 K8S 打造成產品等級的服務。Kubernetes 就是這麼的有趣！ 如果喜歡我寫的文章，歡迎追蹤 本人的帳號 @LukaTW 與 StarBugs Weekly 星巴哥技術週刊 🙂🙂🙂","link":"/2020/03/10/2020-03-20-running-flask-on-minikube/"},{"title":"Kubernetes 教學 01 - 概念與架構","text":"為什麼該學 K8S ？ Pod、Node 是什麼？搞的我好亂呀！ 適合讀者： 已經會使用 Docker，但是不知道 Kubernetes 是什麼。 想看看 Kubernetes 到底在幹嘛的人。 為什麼該用 Kubernetes?Kubernetes 中間共有八個字母有點長，所以大家就將他簡稱為 K8S。但使用 K8S 有什麼好處？ 1. 可以更好的運用雲端或是實體資源所有的資源集中成了一個大平台，所以調度上更靈活，以往我們以實體機為單位的方式很沒有效率，要調度資源的時候需要開一台實體機器，或是虛擬機器，都很耗費 CPU、記憶體等等的資源。 而 K8S 內所有的東西都是容器，可以很快啟動，很快的刪除，並且靈活部屬在 Kubernetes 所擁有的資源上。 2. 讓一切的基礎設施都寫成程式碼應用程式容器化之後，所有需要安裝的套件都會寫成 Dockerfile。這樣在新增或修改的時候，不再像是以前的伺服器是個黑盒子，需要花大量的時間除錯。 部屬的資源則用 Kubernetes 的描述方式撰寫，要前端服務要開幾台，後端服務要開幾台，要自動擴展？ 沒問題，這些 K8S 都可以輕鬆幫你做到。所以你如果要了解整個基礎設施架構時，可以很快的藉由程式碼來認識。 3. 可以幫助開發者聚焦開發減少開發者在基礎設施上花的時間，將硬體統一看做一個大平台，開發者只需要寫應用的描述，其他的 K8S 幫你搞定。例如：有節點當機，會自動生成一個新的節點，以維持服務的穩定。 一切從 Container 開始使用 Kubernetes 之前，你需要把你的服務先容器化，或者用人家包好的 Image 建立。例如：你有一個 Node.js 的應用程式、一個 MySQL 的資料庫，都可以架設在 K8S 上面。 K8S 提供了豐富的、可以應用於產品環境的一切資源給你。例如：自動擴展、負載均衡、定時工作 … 等等一切你想得到的東西。 但是在開始使用 K8S 之前，你需要把你的服務先容器化。雖然一開始很痛苦，需要花很多時間做原本不必要做的事情，但是你容器化你的服務之後會發現，以前需要在不知道被做過什麼事情的機器上摸索的體力活，通通都自動化、或是很易於找到解法，因為在程式碼裡面都有跡可尋。 理解 Node、Pod、Container 之間的關係Node 是 K8S 中的一台實體機器、或是雲端上的一台機器，又稱作是工作者。他有個別名叫做奴隸 (minion) ，挺有趣的。 Pod 是 K8S 中基本的單位，負責裝一個或多個多個 Container (容器)。 Container 中就是我們容器化好的應用程式，例如：Node.js 應用程式、MySQL 服務 … 等等 需要 Pod 來作為基本單位的原因是，如果每個 Container 都作為 K8S 的最小單位，那麼管理網路會變得非常的困難。以 Pod 來區隔，同一個 Pod 裡面的 Container 能夠在本地端互相的連線，只有需要提供給外部呼叫的 API 才需要暴露出來。 示意圖如下： 理解 Kubernetes ClusterKubernetes 集群由控制面板 Control Panel 與節點 Node 所組成。控制面板又稱為是 Kubernetes Master。 https://kubernetes.io/docs/concepts/overview/components/ 控制面板由幾個元件 (Component) 所組成： 1. Kube API Server控制面板中用來暴露 Kubernetes API 的元件，讓其他服務可以讀寫 K8S 的資源物件 (Resouce Object)。 2. Kube Schedular調度器，需要調度軟體、硬體資源的時候就要靠調度器囉。例如：如果新建立的 pod 沒有 node 可以放的時候，調度器就會開啟一個新的 node，來放置剛剛需要建立的 pod。 3. Kube Controller Manager是一個在背景持續執行的程序 (daemon)，用來調節系統狀態，透過 api-server 可以監視 Cluster 共享的狀態。 需要變更目前狀態的時候 Kube Controller 就會將目前的狀態變更到想要變更的狀態，例如：本來 2 個副本 (Replica) 擴展到 4 個副本。 包含了副本控制器 (Replication Controller)，端點控制器 (Endpoint Controller)、命名空間控制器(Namepsace Controller)與服務帳號控制器 4. Cloud Controller Manager基於 Kube Controller Manager，各個雲平台提供者（Provider）的實作。而每個 Node 則包含： kubelet — 用來跟 Master 溝通的元件。 kube-proxy — 網路代理，用來反應 K8S 各個 Node 上的網路服務 讀 Kubernetes API 初探 K8S 的資源物件我們可以透過 Kubernetes API 讀寫 K8S 的資源物件 (Resource Object)，剛剛說的 Kubernetes Cluster 就分為 Kubernetes API 總共分為五大類，分別是： Workload 物件 — 用來「管理或是運行 Container」 在 Cluster 上。 服務發現與負載均衡物件 — 讓 Workload 可以「縫住」形成可被外部存取到的服務，或是有負載均衡能力的服務。 Config 與 Storage 物件 — Config 用來將配置注入你的應用程式中。Storage 讓 Container 的資料可以永久保存在 Container 之外。 Cluster 物件 — 用來定義集群本身的物件。 Meta 物件 — 用來配置資源之間的行為的物件。 這種分類法較接近開發者，可以藉此看看開發者在想些什麼。 https://kubernetes.io/docs/reference/#api-reference 還有精美的 kubectl 範例可以使用，很方便。 kubectl — 跟 K8S Cluster 溝通的工具我們絕大多數對 K8S 的操作都需要透過 kubectl，kubectl 的是什麼呢？DevOps 開發者用 kubectl 命令列工具，可以透過 Kubernetes Master 上的 api-server 對各個 Node 下達指令。而這些 API 即是上一小節說的 Kubernetes API。 https://www.redhat.com/zh/topics/containers/what-is-kubernetes to be continued … 下一部分會比較偏重實作， Minikube 的基本操作、Kubectl 的基本操作與重要的 資源物件的介紹。 如果喜歡我寫的文章，歡迎追蹤 本人的帳號 @LukaTW 與 StarBugs Weekly 星巴哥技術週刊 🙂🙂🙂","link":"/2020/02/11/2020-02-11-kubernetes-tutorial-01/"},{"title":"Unit Test 中的替身：搞不清楚的Dummy 、Stub、Spy、Mock、Fake","text":"最近開始接觸單元測試，一堆名詞看不懂，來狠狠地 K 一下。而單元測試中的最佳男配角，就是替身 Double。藉由寫一篇文章的方式來讓自己更了解單元測試中的重要部分。一起來學寫測試，Go Go !! 註：接觸時間還很短，有錯還請不吝指正，如果之後發現我有理解錯誤再回來更正。 單元測試是什麼？單元測試可以讓你快速驗證程式的行為。了解單元測的話首先來介紹一下 SUT 目標對象。 舉個例子：你想要測試一台車是不是可以開，那麼 SUT 目標對象就是這台車。 為了確保這台車可以開，那麼就可以寫一個「這台車應該要可以開」的測試。如果這台車發生了故障，測試就會告訴你，這台車是壞掉的。 單元測試讓你的程式更容易維護。原因在於你能夠對程式寫測試，代表你寫的程式的「使用說明書」清楚易懂。使用說明書很容易懂，就可以直接拿來用，減少重複的程式碼，符合 DRY (Don’t Repeat Yourself) 原則。 寫程式最大的成本在於維護，寫很簡單，但是要維護可就是個不容易的事情了。為了降低維護的成本，導入單元測試可以大大降低出錯的可能性，並且快樂地重構。 替身是什麼？下圖是火影忍者的替身之術，替身之術的原理是：當敵人對你發動攻擊時，你使用替身之術，就可以讓替身承受敵人的攻擊，而自己不會受到傷害。圖中的木頭就是呼叫替身之術後，用來承受敵人攻擊的替身。 所以火影忍者替身之術跟 Unit Test 的替身有什麼關係？你在程式中使出替身之術的時候，替身 Double 就會出現在你的程式裡面了。 為什麼要在程式中使用替身 Double 呢？原因在於你想要測試的 SUT 目標對象通常會有很多「依賴」DOC。一樣舉個例子：剛剛的 SUT 目標對象是「一台車」很容易寫測試，只要測試這台車可以開就好。 但是如果一台車停在停車場，然後又爆胎。或是一台車掉到海裡。這些情況，一台車的 DOC 依賴變多了，造成你的測試更加複雜，越多的 DOC 依賴會造成你的測試越難寫，也造成你的程式行為更加複雜，難以預測。 那麼就進入正題來介紹測試中的幾種替身吧 測試中的五種替身測試中的 Double 替身分為五種：Dummy Object、Test Stub、Test Spy、Mock Object、Fake Object。先來介紹第一種 Dummy Object 冒牌貨 Dummy ObjectDummy Object 英文直譯冒牌貨，顧名思義就是個冒牌貨。他的用途是用來填充 SUT 目標測試對象中需要的物件。而 Dummy 不會對 SUT 測試目標造成任何的影響。純粹的填充物件，讓測試程式能夠運行。 Test Stub我們想要驗證的 SUT 回傳值，這時候 Stub 就可以派上用場啦。聽起來有點玄，一樣舉個例子：例如：現在我們的測試目標 SUT 是一個手電桶，我們想要驗證呼叫打開 on 方法的結果，而一個手電筒裡面需要裝電池，電池可能會沒電，但是我不想讓電池沒電這個因素影響我的測試。所以我做了一組替身電池 (Stub Object) 塞進這個手電筒裡面。讓我可以輕鬆驗證 SUT 的回傳值。 class Flashlight attr :battery def initialize(battery) @battery = battery end def on battery.have_energy? ? 'flashlight is turn on!' : 'no energy' end end Flashlight.new(StubBattery.new).on # 電池有沒有電不會影響結果。 Test SpySpy 用來驗證 SUT 與對其他 DOC 物件造成的效果，例如：今天阿牛去找朋友聊天的時候，朋友物件內部的聊天次數就會加一，而當我們想想要驗證朋友物件的聊天次數是不是如我們所預期的增長時，我們就可以派出間諜朋友，來驗證「 SUT 阿牛是否有跟朋友聊三次天」之類的期待。 12345678910111213141516171819202122232425262728class 阿牛 def initialize(friend) @friend = friend end def chat_to_friends friend.chat! endendclass Friend attr: chat_count def chat @chat_count ||= 0 @chat_count += 1 endendcow = 阿牛.new(spy_friend)cow.chat_to_friendscow.chat_to_friendscow.chat_to_friendsexpect(spy_friend.chat_count).to eq(3) Mock ObjectMock 是一個能夠判斷 SUT 是不是有正確使用 DOC 的替身。Mock 跟 Spy 的最大差別是，Mock 用來驗證 SUT 的行為，而 Spy 用來驗證 SUT 對 DOC 狀態的改變。 Fake ObjectFake Object 假物件是一個簡化的 DOC (依賴元件)，例如：一台真實的飛機有很多零件，但是我們其實只需要他有外殼，並且可以飛，可以降落 … 等等的行為。所以做一個簡單版的假物件。假物件不需要考慮跟 SUT 目標對象的間接互動(Indirect input , indirect output)。 其他不錯的資源 Test Doubles — Fakes, Mocks and Stubs. 測試中常見的名詞：Stub, Dummy, Mock..等等 測試替身(5) — Spy","link":"/2020/05/05/2020-05-05-unit-test/"},{"title":"TPM — 套件管理工具 ，讓你的 TMUX 更好用","text":"最近因為工作上需要用到開很多個視窗的情景，研究了一下如何把 tmux 變得更具有生產力。 tmux 是什麼？tmux 是一個很好用的遠端 session 管理套件，兼具效能與功能性，可以讓你在遠端伺服器中，輕易管理背景執行程式。 Larry 在 **終端機 session 管理神器 — tmux **文章中介紹了基本的概念、使用方式與經典的使用情景。如果沒有看過的話，請看文章了解一下。終端機 session 管理神器 — tmux身為一名開發者對終端機應該不陌生，不管是要執行腳本、ssh 到遠端伺服器都會用到終端機。這邊要介紹給大家一個工具 tmux，tmux 是個 terminal multiplexer，可以讓你的終端機更好用larrylu.blogt 不過其實不看也沒什麼關係啦，看我寫得就好。 Hello, tpmtpm 是 tmux 的套件管理工具，英文是 Tmux Plugin Manager。tmux 之於 tpm 就如同是 nodejs 之於 npm。是一個在 github 上面有 6100 顆星星的開源專案。 今天我的重點放在 tpm 的介紹上，如果還沒安裝 tmux，請按照 **終端機 session 管理神器 — tmux **文章中的教學逐步安裝並學習使用方法。 回過頭來，我們想要用 tpm 來安裝一些好用的套件，先安裝好 tpm。 首先 git clone tpm 至本機。 git clone [https://github.com/tmux-plugins/tpm](https://github.com/tmux-plugins/tpm) ~/.tmux/plugins/tpm 接著修改 ~/.tmux.conf 檔案的內容，將下列內容複製貼上至檔案中。 1234567891011# List of pluginsset -g @plugin 'tmux-plugins/tpm'set -g @plugin 'tmux-plugins/tmux-sensible'# Other examples:# set -g @plugin 'github_username/plugin_name'# set -g @plugin 'git@github.com/user/plugin'# set -g @plugin 'git@bitbucket.com/user/plugin'# Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)run -b '~/.tmux/plugins/tpm/tpm' 安裝完成後在終端機中輸入下列指令或是重開終端機即可載入完成。 tmux source ~/.tmux.conf 要怎麼使用 tpm 安裝 tmux 套件安裝 tpm 套件可能跟你想的不太一樣，直接修改 ~/.tmux.conf 檔案的內容，並且重啟。例如你想要安裝 tmux-copycat。 vim ~/.tmux.conf 加入這一行 1set -g @plugin 'tmux-plugins/tmux-copycat' 接著，重開 tmux session 或是在 tmux 中輸入 prefix (ctrl+b) + I 即可。 ctrl+b 有點遠，修改 prefix 為 ctrl + atmux 大部分的指令是由組合鍵 prefix + 某某鍵所構成。 prefix 預設是 ctrl + b，外國鄉民大多是將 prefix 修改成 ctrl + a ，你也可以設成你喜歡的樣子，設定方法很簡單。在 .tmux.conf 中加上以下內容即可將 prefix 變成ctrl + a。 1234# remap prefix from 'C-b' to 'C-a'unbind C-bset-option -g prefix C-abind-key C-a send-prefix 介紹幾個好用的套件tmux-yank讓你的 tmux 可以用系統的剪貼簿，支援 osx, linux, WSL(Windows Subsystem for Linux) … 等等的環境。 tmux-pain-control這個套件有三大功能，第一是切割視窗，第二是在視窗中跳躍，第三是縮放視窗大小。 讓切割視窗變得更加簡單這兩個是 tmux 預設的切割視窗快捷鍵 prefix + “：進行水平分割 prefix + %：進行垂直分割 這兩個符號我一直記不起來😭，但是在使用tmux-pain-control 之後： prefix + |：進行水平分割 prefix + -：進行垂直分割 圖型記憶法，真是太好記了。連續技用起來會有這樣的效果： 用 vim 的方向鍵跳轉視窗 prefix + h：往左跳 prefix + j：往上跳 prefix + k：往下跳 prefix + l：往右跳 用 vim 的方向鍵縮放視窗 prefix + shift + h：視窗邊界往左移 prefix + shift + j：視窗邊界往上移 prefix + shift + k：視窗邊界往下移 prefix + shift + l：視窗邊界往右移 tmux copycattmux copycat 可以讓你不使用滑鼠就能夠複製文字。這個套件非常好用，礙於時間不夠無法錄製完整操作。殘念。 tmux-resurrect讓系統重啟的時候保持 tmux 的設定。 tmux-open能夠讓你快速的打開你選取到的文字對應的超連結或是檔案。 tmux-prefix-highlight讓你知道你有沒有成功觸發 prefix，如果按成功了，在下方顯示列會有成功觸發的圖案。 tmux-continuum持續幫你儲存 tmux 的設定。 tmux-sensible讓 tmux 比較合乎邏輯，不然 tmux 有些預設的設定實在是有點難用，這是必備的 tmux 套件。 小結有了 tpm 可以輕鬆安裝好用套件，這讓 tmux 平易進人多了，操作上不再需要記憶太多奇怪的快捷鍵。就可以讓生產力獲得大幅的提升，真滴好。 參考資源 Making tmux Pretty and Usable — A Guide to Customizing your tmux.conf A minimalist guide to tmux","link":"/2020/06/02/2020-06-02-tmp-let-your-tmux-better/"},{"title":"Kubernetes IDE | Lens 用圖形化介面管理 K8S","text":"以往我們在管理 Kubernetes 集群的時候，需要大量的命令列操作，需要去四處找尋需要的資訊，例如你想看 Node 的狀態你可能需要在 AWS Console 上面看，如果你用的是 GKE 的話你就需要到的 GCP 的後台上看。你想要進入 Pod 你需要先下 kubectl get pods取得 pod 列表，接著再下 kubectl exec -it pod/xxxpod – bash 進入。 這些功能現在 Lens 全部幫你整合進去了。它能夠讓你快速的瀏覽你的 K8S 集群狀況，並且即時反應 K8S 集群的狀態讓你可以做相對應的反應。我們就來看看 Lens 有哪些殺手級的功能吧！ Lens 有哪些殺手級功能1. 實時監控 pod 的狀態 (realtime monitoring)可以實時監控 pod 的狀態，不需要手動刷新，這個功能我覺得滿方便的。一般來說你想要重複獲取 pod 的狀態需要在終端機中輸入 kubectl get pods，用終端機下指令的方式只能知道下指令的「當下的狀態」，如果你想要獲得你想要的狀態，你必須不斷下指令。而現在使用 Lens 你只需要瞄一下螢幕，就可以知道 pod 就緒了沒，因為 Lens 會告訴你最即時的 Pod 狀態。 2. 快速查看 Pod 的 CPU 、記憶體用量我覺得這是令人滿驚艷的功能，Newrelic 針對 K8S 推出的監控工具操作起來都沒有那麼直覺。因此目前的監控方案用 Newrelic 來看吞吐量與 request 的消耗時間，方便做一些效能調校。而觀看 Kubernetes 整體的狀態則是使用 Lens 為主。能夠快速找到想要的資訊並能夠反應實時(realtime)的狀態真的挺重要。 3. 快速觀看 Node 的狀態Pod 是 Kubernetes 中的最小單位，但最後他還是會跑在某一台實體機器，也就是 Node 上面，所以我們可以快速的看到 Node 的狀態也是很重要的。 沒錯，Lens 就是那麼的威，可以快速的看到 K8S 中 Node 的 CPU、記憶體用量，還有 Node 上跑了哪些 Pod，運行了哪些資源。 我覺得根本整合度極高。偏愛用終端機的我，目前也離不開 Lens 的方便。 4. Event 列表，能夠即時知道 K8S 集群發生了什麼事例如：一個 pod 中的 readiness probe 告訴你：你的 pod 還沒有準備好啦！Lens 就有這個功能，可以即時知道 K8S Cluster 的事件。不然很有可能 Kubernetes 發生了一些事情，但是你沒有察覺。 5. Pod -&gt; Terminal 一鍵搞定平常要進入某 Pod 的時候先 k get pods，然後複製貼上 pod 的名稱，輸入 k exec -it pod/your-pod-name – /bin/bash 每次做真的有點煩。Lens 直接列出所有 Pod，你只需要點選有問題的 Pod，或是你想要進去的 Pod，點擊終端機鍵，即可連進 Pod 裡面。真～是～太～方～便～啦～！ 為什麼 Kubernetes 能夠有一款 IDE？最後來聊一聊為什麼 Kubernetes 能夠出一款 IDE？一般來說 IDE 是基於語言設計出的 IDE，例如：java 有 Eclipse，c# 有 visual studio，Python 有 Pycharm，PHP 有 Phpstorm… 等等。 這些以語言為基礎的 IDE 可以提供語言為基礎的一些好用方法。例如方法的自動完成、原始碼的快速查找，或是提取方法、提取參數 … 等等重構的功能。基於每個語言的特性，IDE 提供不同的特性。 Kubernetes 的 IDE 是怎麼回事呢？各家提供雲服務的平台紛紛推出相對應 K8S 的服務。例如：Google 有 GKE，AWS 有 EKS，或是也可以自行架設 Kubernetes 集群。 這些 Kubernetes 服務都遵循著相同的 Kubernetes 規範，聽起來好像有點繞，如果不是因為有 Kubernetes 這樣明確的規範，就不可能有 IDE 產生。 例如：Google 的雲端平台 GCP 上如果你想要開機器，跟 AWS 平台上你想要開機器，那麼你是無法用一套 IDE 來監控或是控制兩者的機器狀態的。因為 Google 和 AWS 機器呼叫的規格各自有各自的定義，無法共通。 而 Kubernetes 大家都是透過 kubectl 來跟 Kubenetes Control Panel 溝通。Kubenetes 中的元件，例如：Pod、Service、Deployment … 等等，在各家雲服務商也都是遵照相同規範實作，因此可以使用一款 IDE，就能夠監控各家的 Kubernetes 集群。 結語Lens 的出現讓我用最少的力氣就可以快速的看到想看的資訊。而 Newrelic 的方式比較像是以往的 APM 的監控法。跟以前只有機器的時代，多了一層 Kubernetes 多了滿多思考點。另外警報(Alert)又是另一套系統了。如何在問題出現的時候，快速定位問題，在使用者察覺前解決掉，是一個有趣的挑戰。 最後不免俗的感謝大家觀看，喜歡我的文章請訂閱 Starbugs 星巴哥技術專欄，每週推送原創好文😀😀😀","link":"/2020/06/30/2020-06-30-lens-the-ide-for-kubernetes/"},{"title":"TLDR 命令列神兵｜Linux 入門必裝","text":"TL;DR 的意思是：哩供蝦？講重點好嘛？ TLDR 能夠讓初學程式的新手 ，輕鬆了解命令列工具的各種 Linux 指令，並且自由運用。本篇文章分成幾個兩個部分： 命令列工具 Command line tool 到底是什麼東西？ TLDR 是什麼東西？它如何幫助我們快速適應 Linux 命令列工具？ 話不多說，我們開始吧。 命令列工具 Command line tool 到底是什麼？命令列工具的英文是 Command Line Tool。下圖就是常見的命令列工具。那麼他的作用是什麼呢？ 命令列工具的作用是「透過下指令的方式來做到你想做的事情」 這是什麼意思？為什麼要透過下指令的方式讓做事？原因是： 用命令列工具的來做事情非常有效率。 試想如果你想要安裝一個知名影音播放軟體 VLC，你會做些什麼事情？首先你會 Google，開幾個網頁，看看哪個載點比較值得信賴，然後選一個覺得不錯的下載，等到下載完成之後再安裝。 哪麼換成命令列工具呢，只要下一行指令即可 brew cask install vlc 來看看會發生什麼事情？ VLC 已經裝好了，終端機顯示 VLC 安裝在 /Applications/VLC.app。接著我們打開 /Application 資料夾，VLC 已經安裝好了。 也許你覺得用手動點擊也可以幫你做到同樣的事情，但是當這種有效率的小動作逐步累積的時候，就會造成效率上的極大差異。別人用 15 分鐘做好的事情你可能需要花一個小時。隨著做的事情越複雜效率的差異會越大。 命令列工具那麼好用？ 那到底要怎麼用？tldr 就是告訴我們各種 Linux 指令怎麼用的工具。 TLDR 登場，看看它如何大發神威這下子就輪到我們的主角登場啦，TLDR！TLDR 能夠用最簡短的方式告訴你各種指令的用法。 TL;DR 是 too long; didn’t read 的縮寫，初學 Linux 的時候一堆指令的縮寫有夠難懂，什麼 ls、pwd、mv … 諸如此類的指令。當你不懂的時候怎麼辦？用 TLDR 就對了！ 來示範一下怎麼用，假設我們不知道 ls 指令怎麼使用。想破頭也不知道 ls 指令到底用來幹嘛的？ 輸入 tldr ls 立刻了解 ls 如何使用。 從上圖中的第一行就告訴你，ls 的功用是列出目前資料夾的內容。如果你需要更多的用法，可以參照 tldr 幫你精選出來的各種常用指令。TLDR 絕對不完整，但是很容易上手！ 另一種對比的 Linux 完整文件的指令是 man，在終端機輸入 man ls ，呈現的樣子如下圖，落落長，跟 TLDR 完全相反，保證完整，但要看很久。我們常常只是要用 Linux 指令做一些簡單的事情，所以並不需要看的那麼仔細。 再來試試看 pwd，可以很清楚的看到 pwd的功用是印出目前工作的目錄。 然後你再輸入一次 pwd，就可以很清楚的知道「顯示出來的內容是目前的工作目錄」 TLDR 如何安裝？既然是新手教學文，最後我們就來講一下怎麼安裝 npm install -g tldr 一行指令搞定，就是這麼輕鬆寫意。 小結TLDR 的出現，讓我除了鳥哥的Linux 私房菜以外多了一個認識 Linux 指令的管道。更有趣的它是一個開源專案，如果用 tldr 某某指令 找不到結果，你還可以自行貢獻自己的小抄，讓世界上的其他人用得到。對於新手來講是一個滿好入門的工具。 如果覺得我的文章對你有幫助 ，來 follow 我吧！最近我會常寫文的呦。也別忘了 follow 星巴哥技術週刊，每週推送優質原創文章！","link":"/2020/07/28/2020-07-28-tldr/"},{"title":"從 Github 開源指南｜學習如何貢獻開源專案","text":"本週我們來讀一下「如何為開源做貢獻」。這份文件是 Github 的 Open Source Guide 開源指南，約莫兩年前剛出的時候全部是英文版的，已經三年了，拖到現在才讀（汗）。 （這篇是閱讀開源指南的筆記，原創內容偏少，原文在下方連結）如何為開源做貢獻？透過為開源貢獻力量，能從中學習、幫助他人並且從中累積相關技能的經驗 - 任何你能想像得到的技能。 為什麼會有人為開源做出貢獻？有數不清的原因！…opensource.guide 是 Github 7000 顆星星的開源專案github/opensource.guideOpen Source Guides ( https://opensource.guide/) are a collection of resources for individuals, communities, and…github.com 為何要貢獻開源專案？ 原文寫的很好，我用我的話說出來。 1. 打磨你的專業技能專案中包含了撰寫程式碼、平面設計、使用者體驗設計、撰寫文章 … 等等的工作。只要你想，你就可以在開源專案中找到你的位置。 2. 認識與你有相似興趣的人我覺得這真的滿重要，在現實生活中要找到相同興趣的人就很困難了，但是透過貢獻開源，你可以無遠弗屆的認識世界各地與你有相似興趣的人。 3. 鍛鍊溝通能力因為開源專案是一個「共同協做」的專案。你需要向他人解釋自己是用什麼方法實作，也會需要其他人的幫助。 4. 建立名聲你在開源專案中實作的成果一切都是看的到的，這也意味開源專案是一個能好好火力展示的地方。 5. 學習人際關係的能力開源為練習領導及管理的能力提供了很好的機會。例如如何解決衝突、組織團隊以及如何為工作的優先順序排列。 小訣竅：走進開源專案，就像你走進一群陌生人中，想要嘗試融入。這群人討論的非常深入了，你突然打岔肯定會讓人覺得奇怪。 與其盲目地在社群中拋出你自己的看法，不如先觀察一下社群的氛圍後再提出，這樣你的想法被注意到的機會才會增加。 找尋專案開始貢獻如果你還未貢獻任何一個開源專案的話，可以想想，你能夠為開源專案做些什麼？ 可以從你有使用過的開源專案開始著手，跟你比較有關係的開源專案，或是你比較感興趣的開源專案，你才會積極的參加。 平均一個專案有 28% 的貢獻是隨意且偶然的，像是 Readme、改錯字、失效連結 … 等等的小地方。 找到專案時，先確保專案是否接受貢獻可以從幾個地方，看出專案是否活躍，樂於接受貢獻： 從 Master 分支上看看觀察 最近一次的 Commit 是什麼時候？ Commit 的次數頻繁嘛？ 專案目前有多少貢獻者？ 從 Issue 觀察 目前有多少個 issue\u001e 維護者回覆 issue 是否迅速 是否有討論熱絡的 issue issue 是否已經大量累積 最近 close 的 issue 是多久以前 從 PR 觀察 有多少處於進行中的 PR 提交 PR 後維護者回覆是否迅速 最近有多少 PR 被 Merge 觀察專案的友善程度 維護者的回應是否有幫助 討論過程是否親切 會不會審查 PR 如何將成果貢獻至開源專案最重要的是「有效的溝通」，把握幾個要點： 1. 交代來龍去脈讓他人快速的理解。如果是 Bug 交代清楚你想做的事情是什麼，你當實作了哪些步驟，以便重現錯誤。如果你想要發起一個新的想法，你要解釋為什麼你要這樣做，為什麼你覺得這樣會對專案有幫助。 2. 做好準備工作在尋求幫助之前，先確保你看過文件、相關 Issue 的討論，當你表達出強烈的意願時，人們會很樂意幫助你的。 3. 溝通時力求精簡明瞭開源專案每次提交都是需要他人檢閱的，如果你能夠精準的表達你的看法，那麼你得到別人幫助的機會就會大幅提昇。 4. 大膽的提問（但是要有耐心！）每個人都有新手的時候，不要怕提問。需要注意的是長期維護的人不一定熟悉專案的每一個部分。協作時表現出你的耐心，你會得到相同回報。 5. 尊重社群的決定有時候你的看法跟社群的看法不一定相同。他們可能不接受你的建議。可能社群最後不接納你的建議。這時你可以試試看討論出折衷方案，或者將專案 fork 另起爐灶。 提交之後😭有可能沒有人理你因為大家都很忙，尤其是熱門的開源專案。Issue 很多，維護者的人手不夠，此時就先耐心的等待。 千萬不要私下聯絡，在開源專案中，一切的溝通都應該是公開的。 🚧有人希望你修改你的貢獻這是好的開始，溝通、改進直到符合維護者得期待。 👎你的貢獻沒有被採納你的工作最後沒有被採納，這時你可以問問維護者，為什麼沒有被採納。需要注意的是別花時間在爭論上，這會讓你樹立更多敵人。 🎉 你的貢獻被接受。太棒了！你完成了一次開源貢獻！ 延伸閱讀 發起一個開源專案 維護者最佳實踐 領導與治理 建立一套行為準則 找尋專案的使用者","link":"/2020/08/15/2020-08-05-introduction-to-open-source-guild/"},{"title":"ArgoCD — 透過 ArgoCD 認識 GitOps","text":"什麼是 GitOps ?兩年前初次聽到 GitOps 的時候，我想說是不是只要 Git tag 觸發一些部屬相關的事情，像是下了某個 tag，就會觸發某 Ansible 的工作，部屬某一台伺服器。很遺憾，完全不是我想的那樣。 在最近實際將 GitOps 整合進開發流程的過程中，深入研究了一下 GitOps。對 GitOps 有了多一點的了解，趁這個機會來跟大家分享一下。 GitOps 是 Weaveworks 提出的一種持續交付(CD)的概念，透過 Git 來聲明基礎設施(infrastructure)希望的狀態。什麼是聲明基礎設施希望的狀態？ 從聲明基礎設施希望的狀態談到 K8S說到聲明希望的狀態，這就要來了解一下屬於 Cloud Native 體系的 Kubernetes 了。 因為 Kubernetes 是使用 yaml 檔來建立或是修改所擁有的 K8S 元件。例如你想把某個服務擴展從 3 個 pod 擴展到 5 個 pod。那麼你就會修改 yaml 檔裡面的數字。並使用 kubectl 來應用 yaml 檔案至所對應的 K8S 集群。 簡單說就是 yaml 等於你目前的 K8S 系統狀態。歡迎來到 yaml 的世界！ GitOps 解決了哪些痛點？當我們想要對 K8S 集群做出改變的時候，我們可以做什麼事情？可以直接下 kubectl apply 直接對 K8S 集群進行修改。可是這樣就出現了一個問題，當有許多人都想要對同一個 K8S 進行修改的時候。A 怎麼知道 B 做了什麼修改？如果 B 修改過後，A 並不知道 B 修改了什麼，也進行了一次修改。那麼很有造成系統全面癱瘓。 Kubernetes 就像一個終極兵器，你可以讓他輕鬆的做到你想做的事情，例如：在幾分鐘內長出具有負載均衡能力的服務。但是也因此如果操作不當，後果會比傳統架構還要嚴重很多。 這就是 GitOps 出現的原因！ GitOps 的原則 Weaveworks 提出 GitOps 的概念，並使用 Flux (不是前端的Flux) 來實作之。其中有幾個比較重要的原則： 整個系統必須是聲名式的 希望的狀態必須用 Git 做版控 在 Git 中獲准(appoved)的改變可以自動應用到系統上 軟體代理(Agent)必須確保系統正確性，如果不正確的話需要有警報通知使用者。 核心觀念其實就是讓你的系統具有「可觀測性」，你可以看到系統目前的狀態。並將所有對 K8S 做的操作，都透過 Git 來操作，這樣的話所有的操作過程都會是一個一個的 Commit。 下圖左邊是希望的狀態，也就是 Git 中定義的狀態。而實際的狀態，則是右邊。 如果我們使用的是 ArgoCD 可以輕鬆看到希望狀態與實際狀態的不同。 用 Argo CD 來了解 GitOps ArogCD 是一款 GitOps 的實現。我們來看看上述說的 GitOps 原則到底是怎麼回事。 這是 Argo CD 的圖案，一支外太空章魚(還是什麼生物？)，他提供了強大的觀測介面。可以很好的觀測目前 Kubernetes 集群的狀態。 來動手做做看！做一個小改變 Argo CD 顯示 Out of sync 透過 ArgoCD 可以看到到底對 K8S 集群做了哪些改變。 手動按下 Sync 看看到底發生了什麼事 並且部屬也有版控，萬一不幸弄壞，也可以即時回到上一版本。 用起來是不是很輕鬆寫意！ 心得GitOps 提供 K8S 集群良好可觀測性，並且把開發或是運維對集群的操作記錄在 Git 中，讓任何人可以清楚看到集群做了哪些改變。並且提供了單一的出口，讓開發者和運惟人員不會私自的對集群改變。萬一被改變了，也提供了警報功能來通知主要運維人員。這樣的方式對於 K8S 日常維護來說，無疑是提供了一個非常實用且可靠的方案。 同場加映2021/5/11 update，本篇是 ArgoCD 入門，如果想要看看 ArgoCD 進階運用，請參閱小城老師的文章：Argo CD ApplicationSet Controller: 世界為我而轉動！新推出的 Argo CD ApplicationSet Controller 讓使用者在單個 YAML 檔案內像是寫 For Loop 程式，隨需求一次性地建立大量的 Application CRD，就讓我們使用實際範例來看它如何解放…medium.com 參考資料 Guide To GitOps 淺談 GitOps 的概念","link":"/2020/09/21/2020-09-21-introduction-to-gitops-via-argocd/"},{"title":"WSL - 在 Windows 上打造 Linux 的開發體驗","text":"在 Windows 上打造 Linux 的開發體驗 WSL是關鍵 延續上一篇，打造舒適的 Windows ＋ Mac 雙系統開發環境，打算用一系列的文章，一一來介紹開發各種環境。打造舒適的雙系統開發環境 Windows + Mac 雙刀流 重度 Mac / Linux 開發者，嘗試 Windows 開發先來說說我是個怎麼樣的人，我是個 Mac / Linux 重度使用者，學生時期使用 Windows 開發實在雷，光是搞環境平均就要花一個禮拜以上。再換成一台二手的 Macbook 之後就一路大順暢，從此只用 Mac / Linux 環境開發。 直到最近看到強者我朋友用 Windows 用得滿順的，不僅 Web 這些比較通用的東西跑得順，連 Linux 套件和 Docker 甚至 K8S 都可以順利執行。於是我就買了一台 Windows 電腦，那就來打造出能夠媲美 Linux 開發環境的舒適 Windows 開發體驗吧！ 對 Window 敬而遠之的時期過去幾年我的主力開發環境以 Mac 或是 Linux 為主要開發環境，主要的原因是，有許多 Linux 的套件在 Windows 上不太穩定，安裝時發生的錯誤，10 台有 7 台會發生不一樣的情況。可能是軟體發生問題，也有可能是硬體導致，雖然說最終還是可以找到解決方案，可是每台電腦或是重灌都要重複花費大量時間的時間在處理環境。讓我這個 Windows 使用者毅然決然使用 Macbook 做為開發工具，這一用下去，也用了 7 年以上了。 長年使用 Mac 的我，為什麼想要使用 Windows 開發？第一個原因是，看到強者我朋友 Windows 上跑各種環境跑的很順，滿讓我訝異的，因為以往雷到爆的 Windows，好像突然間不雷了？ 但現在的 Windows 滿穩定的，我觀察了一些現象，在安裝了一些套件之後，沒有發生以前動不動就爆炸，卻又非常難排除的情形。 Cmder — 類似 Linux 的開發體驗 Cmder 安裝很簡單，去官方網站下載即可使用，選擇完全安裝的話，可以連 git 一起安裝起來。可以說是懶人最快建置好環境的方式。 不過由於 Cmder 只是提供一些「類似」Linux 的體驗。並且他是一種「終端機」，所以並不能解鎖好用的 Linux 開發環境。因此接著介紹下一個好冰友 WSL。 WSL — 如果想要一勞永逸，選他WSL 讓 Windows 使用者，不必透過虛擬機，就能直接使用 Linux 環境。現在，Windows 變得對 Linux 開發者更友善。 可以使用 Linux 指令來操作 Windows 系統，令我感到驚豔。以前裝 Linux 套件用一堆奇怪的方法，最後還是裝不好，現在可以直接在 Windows 無縫銜接 Linux，真滴棒！ WSL 讓我們可以在 Windows 上體驗到 Linux 的開發流暢感。 附上 WSL 的架構圖，簡單的說 Linux 的指令會被轉成 NTCore 的 system call，來達到期待的效果。例如：ls 可以列出檔案， ps: 想要深入了解 WSL 原理請看這篇 ：**WSL 原理介紹** WSL 的安裝按照下面網頁逐一步驟安裝即可，下面連結中有幾個步驟，依序跑完，即可安裝完成。建議不要參加實驗計畫當白老鼠，跑幾個 如果沒有加入微軟的實驗計畫，那下面連結中有幾個步驟，依序跑完，即可安裝完成。我自己是沒有參加實驗計畫當白老鼠，指令貼一貼比較省事。在 Windows 10 上安裝適用於 Linux 的 Windows 子系統 (WSL)Windows 子系統 Linux 版有兩個不同的版本，可在安裝過程中進行選擇。 Windows Subsystem for Linux has two different versions to choose between…docs.microsoft.com 有了 WSL 之後，來個終端機吧！安裝好 WSL 以後，你就可以在 Windows 上面使用 Linux 指令，該怎麼使用終端機呢？ 打開終端機，輸入 wsl 即會進入 WSL 的環境，並且會將路徑綁定到 Windows 的檔案系統上。下面使用的終端機為 Windows Terminal。 Terminal 終端機的選擇終端機有幾個選擇，如果你是 Windows 慣用的使用者，你可使用 Cmder 來開啟 WSL，因為你已經習慣了 Cmder 帶來的整合度與習慣。Cmder 也滿漂亮的，只是有些地方，還是需要設定和調教，才能符合自己的使用習慣，例如：$ 的取代 … 等等瑣碎的小事。 如果你是輕量使用者 ，對終端機不是很熟悉，可以用用看 Windows Terminal。微軟推出了一款 Terminal，簡單素雅的頁面，可以輕鬆切換 Powershell 與 WSL 環境，好像也有很多主題可以客製，算是一個簡單好上手的組合。 順帶一提，來看看 Powershell 原始的終端機有多恐怖！！藍色的底，加上進入 WSL 的藍色字體，根本是眼睛殺手，哎呀～我的眼睛業障重！ 最後一個選項是使用 VS Code 來整合 WSL，方便大家開發的時候順便使用 VSCode 直接下指令。我覺得這也不失為一個理想的開發環境解決方案。 小結讓 Windows 上也可以擁有舒適的開發環境是突破自己舒適圈的一小步，現在微軟越來越邁向開源，給他一次機會，雖然因為 Windows 的更新非常的奇葩，你不更新還要給你強制更新，根本使用者體驗殺手，這個情形讓我不會想要轉移主要開發環境過去，但，現在 Windows 是否已經是一個「還可以」的開發環境了呢？我覺得是 ok 的。 希望這篇有幫助到 Windows 使用者的你😃","link":"/2020/11/15/2020-11-15-wsl/"},{"title":"Python 到底是 Call by Value, Call by Reference, 還是 Call by Sharing？","text":"常見的語言的求值策略(Evaluation strategy)大概離不開這幾個，例如：JavaScript (Call by Value, Call by Sharing)、Java (Call by Value)、C (Call by Value)、C++ (Call by Value, Call by Reference) 這次使用使用淺顯易懂的語言，並搭配圖片來說明到底 Python 中是 Pass by Value, Pass by Reference, 還是 Pass Sharing？ 本篇目錄： 用 C++ 理解 Pass by Value 用 C++ 理解 Pass by Reference 來看看 Python 是不是 Pass by Value 來看看 Python 是不是 Pass by Reference 來看看 Python 是不是 Pass By Sharing Python 到底是 Pass by Value, Pass Value 還是 Pass Sharing 呢？ 1. 用 C++ 理解 Pass by ValueC++ 是探討 Pass by Value 與 Pass by Reference 的最佳選擇。我們先來理解 Pass by Value。 Pass by Value (Output) 執行結果 1234Before: number is 7 Before: the num is 7 After: the num is 3 After: number is 7 Pass by Value (Address)可以看到函式內部的數並不會受到影響，遵守作用域( Scope)範圍。我們再執行另一個程式，查看記憶體位址的改變。 執行結果: 1234The Address of number is 0x7ffd0abe7b74 The Address of num is 0x7ffd0abe7b5c The Address of num is 0x7ffd0abe7b5c The Address of number is 0x7ffd0abe7b74 可以發現 num 的位址遵守作用域 (Scope)，經過這兩個程式之後，可以理解到 Pass by Value 是在呼叫函式的時候，複製一份引數(number)給函式使用。 Step 1：宣告 number 為 7 Step 2：呼叫函式時，複製一份給 number 的值複製一份給 num。 step 3：修改 num 的值時，修改的是複製出來的那一份。因此原本的 number 不受影響。 2. 用 C++ 理解 Pass by ReferencePass by Reference 執行結果： 1234Before: number is 7 Before: the num is 7 After: the num is 3 After: number is 3 Pass by Reference (Address)跟剛剛不同的是，因為 Pass by Reference 傳的是參照，也就是地址，所以裡外等同於是一個變數。接著我們一樣把記憶體位址印出來。看看是不是真的是同樣的記憶體位址。 執行結果： 1234The Address of number is 0x7ffd45470b64 The Address of num is 0x7ffd45470b64 The Address of num is 0x7ffd45470b64 The Address of number is 0x7ffd45470b64 發現結果如我們推測的，從頭到尾記憶體位址都是 0x7ffd45470b64 。因為我們傳的是記憶體位址嘛。 Step 1：宣告 number Step 2：呼叫 passByReference 時不會複製一份 number 的值，也就是「共用」同一份的值。 Step 3：因為共用一份資料，num 更新時，也更新到了 number。 Step 4: 看所以最後得到的結果是 After: number is 3 ，因為 number 已經被改變 3. 來看看 Python 是不是 Pass by Value接著我們來看看 Python 是否是 Pass by Value。 執行結果 1234Before the function starts, the number is 7 Before the function starts, the number is 7 After the function ends, the number is 1 After the function ends, the number is 7 執行完 function_1 後，發現原本的 number，並沒有因為在函式中重新指派而改變成 1，還是維持原本的 7。 看起來跟 C++ 的 Pass Value 很像，接著我們再做一個實驗，把記憶體位置印出來。 執行結果： 1234Before the function starts, the id is 4321770416 Before assigning, the num is %d 4321770416 After assigning, the num is %d 4321770224 After the function ends, the id is 4321770416 可以發現，行為雖然像是 Pass by Value，但是記憶體位址變化的時候，並不是執行 function_1 函式的當下，而是在指派 num = 1 之後。這是為什麼呢？ Step 1：將 7 指派給變數 number，此時 7 存到記憶體中。 Step 2：呼叫函式 pass_by_value() 的時候，將 7 傳了進去。此時函式並不會複製一份值進去。 Step 3：當執行到 num=1時， num 是整數型別，是 Imuttable Object 不可變物件，值無法改變，因此會新增一塊記憶體來儲存 num。 Step 4 : 所以最後印出時，不會是 1，而是 7 ，因為 number 與 num 已經沒有共用記憶體位置 結論：Python 的 function_1 跟 C++的 Call by Value 最後的結果都有分開的記憶體位址。但是從記憶體位址變化的時機可以看得出來，讓 Python 有此現象的，是 Imuttable Object 不可變的特性，而非 Call by Value。 4. 來看看 Python 是不是Pass By Reference接著我們來看看 Python 是否是 Pass by Reference。 執行結果 1234before the function starts, the object is `{‘name’: ‘Leo’, ‘age’: 25}` before the variable assign, the obj is `{‘name’: ‘Leo’, ‘age’: 25}` after the variable assign, the obj is `{‘name’: ‘9m88’, ‘age’: 20}` after the function ends, the object is `{‘name’: ‘9m88’, ‘age’: 20}` 哇，外面 object 的內容居然被改變了，跟剛剛的 number 行為完全不一樣，這是怎麼回事？難道這是 Call by Reference？ 可是我們沒有傳地址進去呀。 一樣，我們先把記憶體位址印出來試試看。 執行結果： 1234Before variable assign, the object id is 4508274560 Before variable assign, the obj id is 4508274560 After variable assign, the obj id is 4508274560 After variable assign, the object id is 4508274560 記憶體位址完全沒有改變，這是為什麼呢？因為剛剛我們使用字典 (dict) 這種資料型別，是屬於可變物件 (Mutable Object)，內容可以改變 深入資料型別字典(dict) 的記憶體調用我們來看看這段程式記憶體的調用。這次的圖表將記憶體更精確的分為儲存空間所儲存的「資料 Data」與儲存空間的「地址 Address」。 因為字典這種物件是 mutable 可變的，代表這種物件的值是可以改變的，所以想要來看看到底是記憶體怎麼儲存，才是可以改變的 如果不了解 Imuttable 的人可以參考我寫的另外一篇文章。Python — Mutable vs Immutable。裡面講解了 Python 中可變與不可變的概念。 宣告 object 物件的時候，變數 Variable: object，指向一個記憶體位址為 x8 資料為 x7。變數本身不直接儲存資料的，只會儲存資料的記憶體位址。而真正的資料儲存在地址為 x7 資料為 {‘name’: ‘Leo’, ‘age’: 25} 。 是呼叫function_2 函式的時候，object 的參照傳進去函式裡面，變數名稱變為 obj 。 變數 obj 將內容的地址，儲存在 x9 記憶體位址，資料為 x7。告訴變數 obj 可以去地址 x7 拿資料，這樣就會找到原本物件內容了。 接著實際執行 pass_by_reference() 函式，因為之前變數 obj 將資料指向跟變數 dict_object 相同的物件，所以實際修改到的資料，是原本的資料。最後印出來的時候發現，原始的物件內容已經被改變。 回顧一下 function_2 的執行結果，函式內部的改變會改變 object 外部的內容。 執行結果： 1234before the function starts, the object is {‘name’: ‘Leo’, ‘age’: 25} before the variable assign, the obj is {‘name’: ‘Leo’, ‘age’: 25} after the variable assign, the obj is {‘name’: ‘9m88’, ‘age’: 20} after the function ends, the object is {‘name’: ‘9m88’, ‘age’: 20} 5. 來看看 Python 是不是 Pass by Sharing接下來我們來看範例 3，將範例 2 稍作改變，來看看會發生什麼事情 我們將 function_2() 方法改成 function_3()。並且把將方法的內容改成建立新物件的方式。 12345def function\\_3(obj): obj = { 'name': 'Amy', 'age': 50 } 執行結果: 1234before the function starts, the dict_object is {‘name’: ‘Leo’, ‘age’: 25}before assign, the obj is {‘name’: ‘Leo’, ‘age’: 25}after assign, the obj is {‘name’: ‘Amy’, ‘age’: 50}after the function ends, the dict_object is {‘name’: ‘Leo’, ‘age’: 25} 輸出結果再度變回跟 function_1 的結果一樣，無法改變外部物件，這是為什麼呢？ Step 1: 跟 function_2 完全相同。初始化字典物件內容。 Step 2: 這時就可以看得出來到底發生了什麼事情了，如果是直接使用建立一個新物件的來賦予變數 obj，那麼將不會改變原本變數 dict_obj 的值。 我們可以得出一個結論，在使用可變物件(Muttable Object)的時候，如果重新指派新的物件給它，它就不會保持共用記憶體，而是建立一個心的物件。 6. Python 到底是 Pass by Value, Pass Value 還是 Pass Sharing 呢？都不是，Python 是 Pass by Assignment！我覺得最清楚的是這篇 Stack Overflow 的回答，簡單解釋，引數傳的是物件的參照(Call by Object Reference)，但此 Reference 是由 Pass by Value 的方式實作。 可以歸納出兩個結論： 如果你傳遞的可變物件 (Mutable Object)，傳遞的是物件的參照(記憶體位址)，所以可變物件的值是可以改變的，你可以因此修改到原始的物件的內容。 可變物件 (Mutable Object) 有一個例外是你重新指派一個新的物件給他，外部的作用域(Scope)將無法得知你做的事情，所以外部作用域會認舊的物件，而不是新指派的物件。 如果你用的是不可變物件(Imutable Object)，那麼因為每次指派都會是新的物件，但是物件是在函式作用域內部生成的，所以外部作用域無法得知。就變成了兩個物件 https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference 最後再回到官方文件的定義，確認一下 Python 真的是 Pass by Assignment，打完收工。 https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference","link":"/2021/09/21/2021-09-21-is-python-call-by-sharing/"},{"title":"[Python 教學] 探討重要特性 Mutable 與 Immutable","text":"今天來探討 Python 中的 Mutable 與 Immutable 的概念。Mutable 顧名思意就是「可變的」，而「Immutable」顧名思義是不可變得。 那麼什麼在 Python 中什麼是「可變的」？什麼是「不可變的」呢？我們來說得具體一點。 Python 中 Mutable 定義， 物件的「值」可以被改變。 反之，Immutable 就是物件的值不可以被改變。 聽到這邊你可能產生一些疑惑，為什麼是「物件」？什麼是「值」？可以改變和不可以被改變又是怎麼回事？ 我們先來探討第一個問題，為什麼是物件。 Everything Is an Object by DiveIntoPython 這是什麼意思呢？ 在 Python 中你所使用的一切東西都是物件。 如果你有寫過其他語言，例如：Java。你可能會產生一些疑惑。Java 中的 int 是基本型別(Primitive Data Types)。 我們來看看 Java 中的基本型別是怎麼定義的： Primitive types are special data types built into the language; they are not objects created from a class. A literal is the source code representation of a fixed value; literals are represented directly in your code without requiring computation. Java 中的基本型別是語言中特別的資料型別，「不是」物件。 Python 中一切皆是物件，跟 Java 剛好成為強烈的對比。我們來試試看一下 Python 中的資料型別。 使用 id(object) 可以找到物件 id。使用 __class__ 特殊方法可以找到物件是由哪個類別(class)生成的。 由此可知，在 Python 中的基本型別也是物件。其他特殊情況，例如函式，在 Python 中也是物件，這邊講太多會有點失焦，所以我們先回到主軸。 接下來來談談「可變的物件」，那麼什麼東西是可變的呢？同理，此物件的值可以被改變。 我們用字典 ( dict) 資料型別來演示，當我們創造出一個字典資料結構的時候，裡面的內容是可以被改變的，而且外部的 id 卻不會改變。這樣的特性就跟 JS 之類的動態語言比較相似。","link":"/2021/08/24/2021-08-24-mutable-and-imuttable/"},{"title":"Design Pattern - 資源總整理","text":"要學Design Pattern之前, 一定要先搞懂的物件導向基礎:強烈建議先閱讀91Design Pattern學習的心得之後，再開始學習Design Pattern。文中提到學Design Pattern時必須具備下列的物件導向知識。強調Design Pattern只是幫助物件導向程式達到「高內聚、低耦合」的目的。並且需遵照設計原則來使用。 三大特性：封裝、繼承、多型 兩種抽象：interfact、abstract 目的：高內聚、低耦合 SOLID 原則：單一職責原則、開放封閉原則、里氏替換原則、最小知識原則、介面隔離原則、依賴反轉原則 設計原則：DRY、KISS、YAGNI 設計方式：interface-driven、intention-driven、生成物件與使用物件分開 延伸閱讀：Kent Beck 的四個簡單程式設計原則一些軟件設計的原則 文中提到，濫用Design Pattern的傷害很可能比不用Design Pattern還要大。使用時須根據需求來運用Design Pattern，而非無節制的使用Patterns。 Pin 點部落Design Pattern目錄這是一個我很推薦的學習資源，內容以深入淺出設計模式的學習筆記為主要骨幹。深入淺出設計模式寫得很好，但稍嫌囉嗦，故事敘述往往花了很長的篇幅，因此我選擇精簡整理過的筆記，也就是這個網站的資源來學習。 Teddy搞笑談軟工Teddy提到坊間的書籍，如大話設計模式、設計模式之禪……等等的書籍，以範例來說明Design Patern，以實際程式來解說Desgin Pattern。諸如此類以「操作型定義」來學習，對於入門來說是個好方法。然而由GOF所著作的Design Pattern書中提到的抽象型定義，卻沒有書籍著重在這方面。因此Teddy使用6大元素，將抽象型定義囊括其中，藉以探究Design Pattern。 Teddy流 - 物件導向核心概念亂談軟體設計（1）：Cohesion and Coupling亂談軟體設計（2）：Open-Closed Principle亂談軟體設計（3）：Single-Responsibility Principle亂談軟體設計（4）：Liskov Substitution Principle亂談軟體設計（5）：Dependency-Inversion Principle亂談軟體設計（6）：Single Choice Principle Teddy流 - 設計與設計模式設計的定義盤點 Design Patterns 設計模式的逆襲：種子篇Force是什麼 Teddy流 - 從Force出發了解Force讓你做出好設計（1）：自然界與設計界的Force了解Force讓你做出好設計（2）：一個軟體設計範例尋找Force實驗1：Observer篇尋找Force實驗2：State Pattern篇尋找Force實驗3：Adapter Pattern篇尋找Force實驗4：Facade篇尋找Force實驗5：Proxy篇尋找Force實驗6：Singleton篇 Teddy流-重新整理系列重新整理Adapter Pattern重新整理Singleton Pattern重新整理Factory Method Pattern重新整理Abstract Factory Pattern重新整理Template Method Pattern重新整理Composite Pattern重新整理Observer Pattern重新整理Facade Pattern重新整理Strategy Pattern重新整理State Pattern Teddy流-要解決什麼問題系列Creational Patterns要解決什麼問題(上)?Creational Patterns要解決什麼問題(中)?Creational Patterns要解決什麼問題(下)?Structural Patterns要解決什麼問題(上)?Behavioral Patterns要解決什麼問題(一)? 91的站 很棒的站，對於物件導向觀念一直延伸至Design Pattern，一整套的學習教材。進階版有實際範例將程式重構為Design Pattern的型式。 iT邦 ASP.NET由淺入深 不負責講座系列 重構之路系列 參考書籍 深入淺出設計模式最多人推薦的教材，我也不例外，從最直覺但有缺陷的方式開始思考，慢慢推導致Design Pattern的產生。並不時檢視著SOLID五大原則。非常適合打基礎。缺點是故事篇幅啥在太長，常常看到恍神。書中只講解到其中幾種的Design Pattern並非全部。 大話設計模式引導讀者進入情境，讓讀者思考該用甚麼方法解決問題，類似深入淺出設計模式。優點是故事較短，很容易閱讀。缺點是有些例子對Pattern的了解有限，程式碼有些是中文，較難閱讀。 設計樣式的解析與活用Teddy在網站中推薦的教材，少數有提到抽象型定義的書籍。","link":"/2014/01/01/old%20posts/2014-01-01-design-pattern-resources/"},{"title":"Design Pattern - Command Pattern","text":"定義: Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations 粗分為兩部分: 把request封裝成物件。 實踐queue、日誌、以及支援復原功能。先來介紹的是沒有undo功能的Simple Command Pattern。 Simple Command Pattern初步了解:老方法，用Headfirst Design Pattern的範例熟悉一下Command Pattern。這一章HeadFirst書上並沒有使用UML將範例畫出來，於是我稍作整理，以下是範例的UML:圖中有幾個主要角色:Invoker:調用者，負責調用client端需要的命令，並執行之。Command &lt;&lt; interface &gt;&gt;:透過這個介面Invoker可以調用各種實作這個介面的Command執行之。Reciver:接收者，reciver接收到命令後執行相符合的動作。Client:客戶端，發出命令者。 12345678910111213public class SimpleRemoteControl { Command slot; public SimpleRemoteControl() {} public void setCommand(Command command) { slot = command; } public void buttonWasPressed() { slot.execute(); }} Command:命令接收者(reciver)做出實際行動，Class名稱就是它要reciver做的事情。例如: 123456789101112//LightOffCommand.javapublic class LightOffCommand implements Command { Light light; public LightOffCommand(Light light) { this.light = light; } public void execute() { light.off(); }} 可以很清楚的知道，這個命令是要Light這個reciver去做開燈這件事。 從這個Simple Command pattern中可以觀察到幾個特性: 原本需由Client端直接面對各種Reciver不同的API，現在只要setCommand，然後執行即可。讓Client端的程式碼更具有可讀性。 要設成Command的行為，必須要有一定的相似性，通常是輸入的變數都是同一類型。如開燈與開電視機他們都不需要輸入參數。 使用Command的行為盡量不要回傳值，或者回傳值即是需要的結果。簡化Client程式碼。 ##Meta Command Pattern什麼是meta command pattern?剛剛的simple command pattern，invoker使用setCommand()方法，一次可以設定一個command對吧。現在我們把command存在陣列中，最後再使用executeAll()方法一次執行所有儲存的命令。來做個比較便一目了然: 12345678910111213141516// SimpleCommandInvoker.javapublic class SimpleCommandInvoker { Command command; public SimpleCommandInvoker() { } public void setCommand(Command command){ this.command = command; } public void execute(){ command.execute(); }} 12345678910111213141516171819202122232425// MetaCommandInvoker.javapublic class MetaCommandInvoker { List&lt;Command&gt; commands = new ArrayList&lt;Command&gt;(); //把command儲存在List中，由executeAll一一執行。 public MetaCommandInvoker() { // TODO Auto-generated constructor stub } public void setCommand(Command command){ commands.add(command); } public void removeCommand(Command command){ commands.remove(command); } public void executeAll(){ for(Command c:commands){ c.execute(); } }} Undo與NoCommand這部分先行跳過，擇日補上，如果對復原有需要的朋友，請參閱Head First Design Pattern一書。 延伸思考: 如果我們把Command用Abstract class或是Concrete Class實作一些方法，而非interface會怎麼樣? Command Pattern or Stragery Pattern一個情境，在登入時，能選擇google登入、facebook登入或者使用網站本身資料庫來登入，這種情形下，用Command Pattern比較好還是用Stragery Pattern比較好呢? Command pattern與Facade Pattern同樣都是在實際執行的物件和Client中間加上一個物件來降低藕合，差別在於facade必須為所有的method命名，例如開電視。而Command要使用哪一個才調用並執行，可以看得出Command Pattern適用於大量且不一定會使用的指令，而facade是讓你很明顯的看到，我這個系統有這些功能，扮演著介面的角色。 參考資源:Head First Design Pattern搞笑談軟工 重新整理Command PatternCommand與Stragery Pattern的差異Rico 技術農場 Command Pattern","link":"/2014/02/08/old%20posts/2014-02-08-design-pattern-command-pattern/"},{"title":"UML - Class Diagram","text":"Design Pattern的學習中頻繁的出現著Class Diagram，如果不仔細地了解箇中意思，將會學得很辛苦，因此特別介紹Class Diagram，也就是類別圖。UML中的專有名詞與一般寫程式的專有名詞並不完全相同，例如UML用的一般化（generalization）這個名詞就等於是物件導向語言中「繼承」。而這些UML特有的名詞經常會出現在學習的過程中，如果能夠了解，對學習來說很有幫助，因此建議熟記在Class Diagram中出現的專有名詞。 最後簡單的介紹一下UML，UML是描述物件導向程式的語言，使用圖形來表示我們設計的軟體。從需求設計實作，都可以用UML來表示。而Class Diagram描述著系統的結構，是UML中唯一可以對應實際物件導向程式的UML圖。 能見度(Visibility)加在Class中的變數或是方法前面。public:大家都可以使用。private:只能在自己本身的Class中使用。protected:跟自己有繼承關係的class皆可共用。package:在同package下可以使用。 多重性(multiplicity)關係類別間的關係是最重要也是最需要釐清地部分，小小的不同意思都會差的很多，請特別注意。 ** Generalization 一般化**說明：物件導向程式中稱為Inheritance-繼承。表示繼承了父類別。 ** Realization 實現：**說明：物件導向程式中的Implementation-實作。表示實作了介面。 ** dependency 相依關係**說明：類別依賴於另一個類別所提供的功能。從程式語言角度來看：當一個類別使用到另一個類別的方法(method)。 ** associations 關聯**說明：程式語言角度：類別之間的關聯，通常代表著一個類別的變數參考至(refer to)另一個類別。舉例來說： navigable assovciations 有方向性的結合關係箭頭開始的那類別，擁有箭頭指向類別的參考(reference) 。 ** aggregation 聚合**說明：弱關連 - 整體(Whole)消失後，部分(part)還是繼續存在。有包含的意思，英文為is-part-of。例如：學生是學校的一部分，學校不見了，學生還是可以到別的學校讀書，並不會因為學校不見跟著消失。 ** Composition**說明：強關連 - 比聚合更強的包含關係，整體消失，部分也會跟著消失。整體-部分的生命週期是一致的。如果電話消失了，那麼按鍵也會跟著消失。 參考資料：游峰碩老師個人網頁","link":"/2014/03/01/old%20posts/2014-03-01-uml-class-diagram/"},{"title":"爆炸性的學習","text":"這學期我的目標是成為一個有爆炸學習速度的男人忽然想到很多值得一試的方法： 聚焦一段時間內聚焦於一個小目標，不顧一切的把它完成。避免游移所造成的浪費。 用大量的小目標代替一個大目標像演算法這種需要大量時間摸索的科目，設立一些小目標，一一達成目標。 捲起袖子下去實作是進步最快的方式不斷的練習可以幫助熟練，第一天也許比較痛苦，第二天第三天重複一樣的動作，就會慢慢漸入佳進，不斷的練習！！ 早上起來固定看一些影片將原本會浪費時間的習慣用一些學習的習慣來替代，久而久之非常顯著。 快速的累積文章（以敏捷式開發代替完美主義）我之前想寫design pattern文章的方式太過要求，想做到面面俱到，但這樣做往往會在某些點鑽牛角尖。用敏捷式開發吧！先寫出一篇來，聽取大家的建議，或是自己覺得不好的地方再做修改！這樣會有效率的多。 擁抱限制常常因為效率不錯，就無限度的加長工作時間，卻沒想到沒有時間的限制下，動力會大大的降低。時間一長發現自己什麼都沒做到，於是只好再加長工作時間，惡性循環。給自己定下一個合理的工作時間吧！足夠學習，又不會令人喪失鬥志。如果再三小時內完成一個小功能是一個好玩的挑戰。若是覺得前三個小時效率不錯，那麼繼續工作9小時，是不是令人提不起勁呢？ 回頭想想，如果我可以快速的學會一個東西，那我不就有很好的素材可以寫。如果我為了寫網誌而拖累了學習速度，那我不僅寫得文章數少，學到的東西又更加少。完全本末倒置。","link":"/2014/03/20/old%20posts/2014-03-20-explosive-learning/"},{"title":"HTML額外標籤","text":"因為學習HTML在一般的標籤上並沒有遇到什麼問題，所以就不多做說明。直接進入比較容易混淆不理解的地方，就是HTML的額外標籤。 HTML的額外標示 一般常見的標籤，很容易理解，所以特別針對HTML的額外標示來加強需具備的Web知識。 1. DOCTYPEhtml經歷了不同版本，所以每個網頁一開始都應該告訴瀏覽器使用的html版本。&lt;!DOCTYPE html&gt; 2. 註解html裡的註解以表示 3. id屬性a) 每個HTML屬性都可以使用id屬性，將某元素「獨立」辨識出來，也就是說它是唯一的。b) 同一個頁面上的兩個元素不能有相同的id屬性，否則該值就不再唯一。c) 學習javascript時，id屬性可以讓程式碼與特定元素互動。d) 屬性是全域變數(global attribute)。 4. class屬性如果你想做的並非獨立辨識文件中的單一元素，而是選取特定的幾個元素，對這幾個元素進行「分組」的動作，這樣一來你就可以一次美化使用相同class屬性的所有成員。例如：你想區別內部連結與外部連結。就可以使用class屬性來標示它們。 quote 在任何屬性上的class屬性都可以套用相同的值。 5. Block（區塊元素）有些元素會在瀏覽器視窗另起一行，稱為block level的元素。。 6. Inline（行內元素）有些元素會跟鄰近元素保持在同一行，這些稱為行內元素。 7. div元素&lt;div&gt;可以將一組元素全組起來，成為一個block level的方塊。因為div可以用在很多地方，在&lt;/div&gt;後面加一個註解，可以大大提昇可讀性。使用&lt;div&gt;元素來容納頁面的不同區域，可以讓管理原始碼的工作更容易。 8. span元素&lt;span&gt;的作用就像&lt;div&gt;元素的inline版本。也就是它是一個inline level的元素。 9. iframe元素&lt;iframe&gt;就像網頁上的一個小窗戶，透過這個小窗戶你可以看到其他網頁。常見的像是youtube或是google map都是這種用法。 10. meta元素&lt;meta&gt;標示位在&lt;head&gt;元素內，包含網頁相關資訊。有以下幾個propertiesdescription:網頁的描述，有時候會在搜尋結果中出現。robots:此屬性標明搜尋引擎是否要將此頁面加到搜尋結果中。 11. 其他一些不受到html5支援的額外標示就不在此寫出，需要用到的時候再去查詢即可。","link":"/2014/04/18/old%20posts/2014-04-18-html-tags/"},{"title":"CSS簡介","text":"了解CSS運作方式的關鍵想像每個HTML元素四周都有看不見得方框，使用Rules來改變呈現的方式。 CSS的運作方式CSS associates style rules with html elements（CSS的運作方式是將HTML和Rules連結起來。） Rulesrules包含兩個部分：selector與declaration。 DeclarationDeclaration包含了Property和Value。 CSS properties affect how elementts are displayed selector的分類 ==============================================================================參考資料：HTML &amp; CSS DeSign and buiLd Webdites 最好的HTML&amp;CSS書籍","link":"/2014/04/18/old%20posts/2014-04-18-introduction-to-css/"},{"title":"Algorithm - BFS(Breadth-first Search)(ch22.1 22.2)","text":"Graph algorithm 符號說明 Graph用G=(V,E)來表示，V是Vertex的縮寫，也就是頂點。E是Edge的縮寫，也就是邊。理解V和E分別是頂點和邊之後，就不難理解Graph是由點和邊構成，所以表示成G=(V,E)。從頂點u到頂點v的一個邊則用(u,v)來表示。 表示Graph G=(V,E)有兩種方式，分別是adjacent matrix與adajecent list。比較常用adjacent list來表示graph，因為它花費的cose比較小。表示一個儲存Graph中鄰近u的所有頂點的adjacent list，用Adj[u]來表示。 Breadth-first Search(寬度優先搜尋)Minimum spanning tree中的Prim演算法和單一來源最短路徑問題中的dijkatra演算法都使用類似BFS的演算法的方法。BFS有系統的搜尋Graph G=(V,E)的邊來發現可以從Source(起始點，之後縮寫成S)到達的每個頂點。 BFS-Tree的建構BFS-Tree : 產生一棵以S為根的BFS-Tree來包含所有可到達的頂點。 最初只包含他的根，即來源頂點S。 每當掃瞄一個已經被發現的頂點u的adjacent list時，發現有白色的頂點V，麼頂點V和邊(u,v)就會被加入樹中。因為經由u才找到v，所以稱u是v的predecessor(先輩)或稱為parent。 頂點上的資料結構每個頂點儲存了一些屬性(attribute)來幫助實現BFS-Tree。u.color - 表示頂點u的顏色u.π - predecessor vertex，用來紀錄頂點的先輩。u.d - 儲存起點s到u點的距離 除了頂點的資料結構之外，還需要一個queue來管理灰色的頂點，代號Q。 BFS將頂點塗成白色、灰色與黑色來區分他們的狀態。白色代表未造訪過。黑色代表所有鄰近的頂點都被發現了。灰色則是介於兩者之間。一個頂點在第一次造訪的時候，從白色變成灰色或黑色，稱為discover(被發現)。 BFS演算法12345678910111213141516171819BFS(G,s)1. for each vertex u ∈ G.V - {s}2. u.color == WHITE3. u.d = INF4. u.pi = NIL5. s.color = GRAY6. s.d = 07. s.pi = NIL8. Q = ∅9. ENQUEUE(Q,s)10. while Q ≠ ∅11. u = DEQUEUE(Q)12. for each v ∈ G.Adj[u]13. if v.color == WHITE14. v.color = GRAY15. v.d = u.d + 116. v.pi = u17. ENQUEUE(Q,v)18. u.color = BLACK 程式說明: 1-9行是程式初始化。1-4行，將在Graph中頂點塗成白色，意思是未探索過。因為所有的點還未走訪過，所以把d設為INF代表的意思是無限大。還沒有predecessor所以先設為nill，代表空的意思。5-7行設定來源頂點s為灰色，d的定義是離s的距離有多遠，s離s的距離是0，所以設為0。來源點s沒有先輩，所以設為null。8-9行把Q這個queue初始化，裡面只存放來源頂點s。 第10-18行被一個while迴圈包住，當沒有灰色頂點的時候才會跳出，也就是當Q中沒有存放任何灰色頂點，Q=null時才會結束。第11-12行，從Q中取出一個灰色頂點u。把u的相鄰邊，也就是這個頂點u的adjacent list中儲存的相鄰頂點v(可能有很多個)，用for迴圈一一讀出來。13-17行，如果取出的頂點是白色，那就把它塗成灰色，標記他為造訪過的頂點。距離+1。pi先輩設為u。把v加入到Q中。最後頂點u的所有鄰近的頂點都被發現了，所以設為黑色。 時間複雜度 參考資料ycp cs 360Introduce to algorithm","link":"/2014/06/10/old%20posts/2014-06-10-algorithm-notes-fundamental-graphics-algorithms-and-bfs/"},{"title":"Algorithm - Bellman-Ford Algorithm(ch24.1)","text":"BELLMAN-FORD AlgorithmBELLMAN-FORD演算法是個很容易撰寫的演算法。而且他可以偵測負重量循環(negative weight cycle)。 123456789BELLMAN-FORD(G,w,s)1. INITIALIZE-SINGLE-SOURCE(G,s)2. for i = 1 to |G.V|-13. for each edge (u,v) ∈ G.E4. RELAX(u,v,w)5. for each edge (u,v) ∈ G.E6. if v.d &gt; u.d + w(u,v)7. return FALSE8. return TRUE 第2-4行的for迴圈執行Graph所有的邊的數量-1次，對每個邊做鬆弛一次。第5-8行檢查是否有負重量循環，回傳TRUE的話代表有負重量循環，換句話說正常情況下會回傳FALSE。 12345INITIALIZE-SINGLE-SOURCE(G,s)1. for each vertex v ∈ G.V2. v.d = ∞3. v.pi = NIL4. s.d = 0 1234RELAX(u,v,w)1. if v.d &gt; u.d + w(u,v)2. v.d = u.d + w(u,v)3. v.pi = u 時間複雜度Initialize d’s, π’s, and set s.d = 0⇒ O(V)Loop |V|-1 times through all edges checking the relaxation condition to compute minimum distances⇒ (|V|-1) O(E) = O(VE)Loop through all edges checking for negative weight cycles which occurs if any of the relaxation conditions fail⇒ O(E)The run time of the Bellman-Ford algorithm is O(V + VE + E) = O(VE). 參考資料Lecture 21: Single Source Shortest Paths - Bellman-Ford Algorithm","link":"/2014/06/11/old%20posts/2014-06-11-algorithm-notes-bellman-ford-algorithmch/"},{"title":"Algorithm - Dijkstra&#39;s Algorithm","text":"資料結構Q是一個以d值來做鍵值的Queue，取出時會從最小的d開始取，也就是取出距離最短的頂點V。S是一個頂點的集合，用來存放從Q中刪除的頂點。 Dijkstra’s Algorithm123456789DIJKSTRA(G,w,s)1. INITIALIZE-SINGLE-SOURCE(G,s)2. S = ∅3. Q = G.V4. while Q ≠ ∅5. u = EXTRACT-MIN(Q)6. S = S ∪ {u}7. for each vertex v ∈ G.Adj[u]8. RELAX(u,v,w) 第3行初始化Q包含Graph中所有的頂點V。第5行EXTRACT-MIN(Q)搜尋了Q中有最小的u.d的頂點u，將u從Q中刪除，並返回給用戶。第6行把u加到S中。 12345INITIALIZE-SINGLE-SOURCE(G,s)1. for each vertex v ∈ G.V2. v.d = ∞3. v.pi = NIL4. s.d = 0 1234RELAX(u,v,w)1. if v.d &gt; u.d + w(u,v)2. v.d = u.d + w(u,v)3. v.pi = u 時間複雜度Basically the algorithm works as follows: Initialize d’s, π’s, set s.d = 0, set S = ∅, and Q = G.V (i.e. put all the vertices into the queue with the source vertex having the smallest distance) While the queue is not empty, extract the minimum vertex (whose distance will be the shortest path distance at this point), add this vertex to S, and relax (using the same condition as Bellman-Ford) all the edges in the vertex’s adjacency list for vertices still in Q reprioritizing the queue if necessary The run time of Dijkstra’s algorithm depends on how Q is implemented: Simple array with search ⇒ O(V2 + E) = O(V2) Binary min-heap (if G is sparse) ⇒ O((V + E) lg V) = O(E lg V) Fibonacci heap ⇒ O(V lg V + E) Dijkstra’s Algorithm的正確性因為Dijkstra’s Algorithm永遠選擇最輕或最靠近的頂點來加入S，所以說們說它是採用貪婪的策略。貪婪策略不是擁有都會得到最佳的結果，所以我們必須推論它。因為太長就不推倒，詳見Theo24.6。 參考資料Dijkstra’s Algorithm","link":"/2014/06/10/old%20posts/2014-06-10-algorithm-notes-dijkstras-algorithm/"},{"title":"Algorithm - DFS(Depth-First Search)(ch22.3)","text":"頂點的資料結構DFS與BFS不同的是，在頂點上須標明兩個時間標籤(Timestamp，以頂點v為例子，就是v.d和v.f這兩個屬性。所以變成以下三個。u.π - predecessor vertex.u.d - timestamp when the vertex is first discovered (and is subsequently colored gray)u.f - timestamp when the vertex has been fully explored (and is subsequently colored black) ⇒ u.d &lt; u.f DFS 深度優先搜尋演算法12345678DFS(G)1. for each vertex u ∈ G.V2. u.color = WHITE3. u.pi = NIL4. time = 05. for each vertex u ∈ G.V6. if u.color == WHITE7. DFS-VISIT(G,u) 第1-4行進行初始化。把Graph中的所有點設為白色（代表未造訪的意思），先輩(predecessor)設為nill。第四行重置全域時間計數器。第5-8行檢查是否要進入DFS-VISIT: 輪流檢查頂點V的adjacent list裡面的每個頂點，如果碰到白色頂點就使用DFS-VISIT來造訪它。 1234567891011DFS-VISIT(G,u)1. time = time + 12. u.d = time3. u.color = GRAY4. for each v ∈ G.Adj[u]5. if v.color == WHITE6. v.pi = u7. DFS-VISIT(G,v)8. u.color = BLACK9. time = time + 110. u.f = time 第1行全域變數time+1，第2行把更新過的時間存進頂點u的時間標籤d內。第3行在u是白色的時候呼叫DFS-VISIT(G,u)，這時u已經造訪過了，塗成灰色。第4-7行檢查鄰接u的每個頂點v，如果v是白色的就遞迴地拜訪之。第8行當u的鄰接頂點v都被拜訪過後，此時把u塗成黑色。第9-10行，將全域時間變數time+1並儲存到u.f。每呼叫一次DFS-VISIT(G,u)就會創造一顆根為u的DFS-Tree，所以在DFS-VISIT(G,u)中的遞迴呼叫結構會構成一個DFS森林(DFS-Forest)。 邊的分類After DFS, all of the edges in the graph can then be classified as either:DFS還有一個額外的功能，它可以辨別邊的種類，而邊有下列四種： Tree edge - edge in one of the depth-first trees,i.e. v is first discovered from u ⇒ if v is white when (u,v) is explored, then (u,v) is a tree edgeBack edge - non-tree edges connecting u to an ancestor of v⇒ if v is gray when (u,v) is explored, then (u,v) is a back edgeForward edge - non-tree edges connecting u to a decendant of v⇒ if v is black when (u,v) is explored and u.d &lt; v.d, then (u,v) is a forward edgeCross edge - all other edges⇒ if v is black when (u,v) is explored and v.d &lt; u.d, then (u,v) is a cross edge","link":"/2014/06/11/old%20posts/2014-06-11-algorithm-notes-dfs-depth-first-searchch/"},{"title":"Algorithm - 最短路徑問題(ch24)","text":"最短路徑問題(Shortest Path)以下說明摘錄自Algorithm「最短路徑」是由起點到終點、權重最小的路徑。 最短路徑問題包括下列幾種：Point-to-Point Shortest Path，點到點最短路徑：給定起點、終點，求出起點到終點的最短路徑。一對一。 Single Source Shortest Paths，單源最短路徑：給定起點，求出起點到圖上每一點的最短路徑。一對全。 All Pairs Shortest Paths，全點對最短路徑：求出圖上所有兩點之間的最短路徑。全對全。 Relaxation（鬆弛）最短路徑有算法一個共通的重要概念。簡單的說找到捷徑以縮短原本路徑，便是 relaxation 。 12345INITIALIZE-SINGLE-SOURCE(G,s)1. for each vertex v ∈ G.V2. v.d = ∞3. v.pi = NIL4. s.d = 0 跟之前一樣先初始化v.d與v.pi。 1234RELAX(u,v,w)1. if v.d &gt; u.d + w(u,v)2. v.d = u.d + w(u,v)3. v.pi = u 透過Relaxation我們可以測試可否利用頂點u來增進v的最短路徑。如果可以就更新v.d與v.pi。 參考資料演算法筆記-PathLecture 21: Single Source Shortest Paths - Bellman-Ford Algorithm","link":"/2014/06/11/old%20posts/2014-06-11-algorithm-notes-shortest-path/"},{"title":"Algorithm - Merge sort(ch2.3)","text":"#原理每跑過一次merge-sort主程式都會把陣列分割成兩半。直到分成每個元素分離之後，再開始兩兩的排序並合併。合併到最後即為排序好的結果。 #程式碼說明MERGE-SORT主程式負責分割陣列，等到分割到不能分割，也就是每個陣列剩下一個元素的時候，改由MERGE副程式兩兩進行合併，合併的時候加以排序，等到全部合併成一個陣列之後，剛好就排序完成了。 123456MERGE-SORT(A,p,r)1 if p &lt; r2 q = (p+r)/23 MERGE-SORT(A,p,q)4 MERGE-SORT(A,q+1,r)5 MERGE(A,p,q,r) 12345678910111213141516171819MERGE(A,p,q,r)1 n1 = q - p + 12 n2 = r - q3 let L[1..n1+1] and R[1..n2+1] be new arrays4 for i = 1 to n15 L[i] = A[p+i-1]6 for j = 1 to n27 R[j] = A[q+j]8 L[n1+1] = INF9 R[n1+1] = INF10 i = 111 j = 112 for k = p to r13 if L[i] &lt;= R[j]14 A[k] = L[i]15 i = i + 116 else17 A[k] = R[j]18 j = j + 1 #Java程式碼實作使用下列網站的範例做說明Mergesort in Java - Tutorial - Lars Vogel 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package de.vogella.algorithms.sort.mergesort;public class Mergesort { private int[] numbers; private int[] helper; private int number; public void sort(int[] values) { this.numbers = values; number = values.length; this.helper = new int[number]; mergesort(0, number - 1); } private void mergesort(int low, int high) { // check if low is smaller then high, if not then the array is sorted if (low &lt; high) { int middle = low + (high - low) / 2; mergesort(low, middle); mergesort(middle + 1, high); // Combine them both merge(low, middle, high); } } private void merge(int low, int middle, int high) { // Copy both parts into the helper array for (int i = low; i &lt;= high; i++) { helper[i] = numbers[i]; } int i = low; int j = middle + 1; int k = low; // Copy the smallest values from either the left or the right side back // to the original array while (i &lt;= middle &amp;&amp; j &lt;= high) { if (helper[i] &lt;= helper[j]) { numbers[k] = helper[i]; i++; } else { numbers[k] = helper[j]; j++; } k++; } // Copy the rest of the left side of the array into the target array while (i &lt;= middle) { numbers[k] = helper[i]; k++; i++; } }} #參考資料[Sort] 淺談 merge sort","link":"/2014/06/12/old%20posts/2014-06-12-algorithm-notes-merge-sort/"},{"title":"Algorithm - Heap sort","text":"Heapheap可看作是幾乎完整的二元樹的陣列。 123456PARENT(i)return i/2LEFT(i)return 2iRIGHT(i)return 2i+1 Max heap與Min heapMax heap最大的元素在根部Min heap最小的元素在根部 heapsort用的是Max heap而priority queue用的則是Min heap，每次取出的會是最小的值。","link":"/2014/06/12/old%20posts/2014-06-12-algorithm-notes-heap-sort/"},{"title":"Algorithm - 時間複雜度整理","text":"以下資料摘自Ting的小筆記 ###Sorting Algorithms ###Graph Algorithms| | Graph algorithm | 時間複雜度 | strategy | negative weight || —- | ———————— | ———— | ——– | ————— || Ch22 | BFS(Breath-First Search) | O(V+E) | greedy | || | DFS(Depth-First Search) | O(V+E) | greedy | || Ch23 | Kruskal | O(E lgV) | greedy | allowed || | Prim | O(E+V lgV) | greedy | allowed || Ch24 | Bellman-Ford | O(VE) | DP | allowed || | Dijkstra’s | O(E+V lgV) | greedy | not allowed || Ch25 | Floyd-Warchall | O(V^3) | DP | allowed || | Johnson’s | O(VE+V^2lgV) | gd + DP | allowed | ###參考資料Ting的小筆記 - Algorithm time complexity 演算法時間複雜度整理Sorting IntroductionSorting Comparison小殘 - Bubble sort排序(sorting)","link":"/2014/06/15/old%20posts/2014-06-15-algorithm-notes-time-complexity/"},{"title":"Algorithm - Quick sort","text":"概念從數列中挑選一個pivot，大於pivot放在右邊，小於pivot放在左邊，重複循環最後得出的陣列即為排序結果。 流程(請搭配虛擬碼的QUICKSORT主程式一起服用) 選擇陣列中的一個元素作為pivot 比pivot小的都移到pivot的左邊，比pivot大的都移到pivot的右邊。 對pivot左邊和右邊的兩個陣列分別再做一次QUICKSORT()，形成一個遞迴呼叫。 程式碼12345QUICKSORT(A,p,r)1 if p &lt; r2 q = PARTITION(A,p,r)3 QUICKSORT(A,p,q-1)4 QUICKSORT(A,q+1,r) PARTITION()這個副程式的作用是將比pivot小的數放在pivot左邊，比pivot大的放在pivot的右邊。最後回傳pivot所在的位置存到變數q裡面，方便下一次quicksort的執行。 123456789PARTITION(A,p,r)1 x = A[r]2 i = p - 13 for j = p to r-14 if A[j] &lt;= x5 i = i + 16 exchange A[i] with A[j]7 exchange A[i+1] with A[r]8 return i+1 Java實現12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package quicksort;/** * * @author Steven */public class QuickSort {private float[] arr ; public void sort(float[] array) { this.arr = array; quickSort( 0 , array.length - 1); } public void quickSort(int left, int right) { int pivot = partition(left, right); if (left &lt; pivot - 1) quickSort(left, pivot - 1); else if (pivot &lt; right) quickSort( pivot, right); } public void findSmallest(float arr[], int k){ quickSort( 0 , arr.length - 1, k); } private void quickSort( int lefe, int right,int k){ int pivot = partition(lefe, right); if(pivot == k-1){ System.out.printf(&quot;第%d小數為%.2f\\n&quot;, k, arr[pivot]); } else if (pivot &gt; k-1) quickSort( lefe, pivot-1 , k); else quickSort( pivot, right, k); } private int partition(int left, int right) { int i = left, j = right; float tmp; float pivot = arr[(left + right) / 2]; while (i &lt;= j) { while (arr[i] &lt; pivot) i++; while (arr[j] &gt; pivot) j--; if (i &lt;= j) { tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; i++; j--; } }; return i; }} 參考資料小殘 - Quick Sort","link":"/2014/06/12/old%20posts/2014-06-12-algorithm-notes-quick-sort/"},{"title":"Dynamic Programming cheatsheet","text":"Problem 1:A manufacturing problem to find the fast way through a factory Problem 2:The matrix-chain multiplication problem Problem 3:LCS LCS程式實作 Problem 4:Floyd’s algorithm Reference杰哥數位教室–演算法課程","link":"/2014/06/14/old%20posts/2014-06-14-dymamic-programming-cheatsheet/"},{"title":"Algorithm - 3週不間斷學習演算法之心得","text":"這個禮拜花了大量的時間研讀演算法，紀錄下學習過程與心得。 清點在這一週中學到了什麼 了解演算法所解決的問題(Problem) 了解各個演算法的解決問題策略與方式。 部分的演算法我能夠以Java來實現。 了解了足夠數量的演算法。 學習演算法的三個階段 看的懂演算法，並且能用真正的程式語言實現出來。 了解演算法，可以利用演算法的特性解決教科書以外的問題。 設計演算法，這部分需要進修另一門課 - 演算法設計。工作或研究上有需求才進修至此階段。 一般學習上到第二個階段就足夠了。也就是說有兩個大方向，一是實現演算法，二是以課本上的演算法為基礎學習其他的演算法。這樣一來就不難聯想，如果我要比別人有優勢，我要： 了解每個演算法所解決的問題。 熟練實現演算法的過程。 了解除了課本上基礎演算法的變形，讓演算法可以適用在更多的場景。 演算法會用到許多的資料結構，學習演算法的同時可以幫助了解資料結構的特性。 沒有學習過演算法的人可能需要花一些時間了解這個演算法怎麼使用，而我可以快速並且更正確的使用它，減少冤枉路。演算法的變形建立於某演算法的特性之上，因此學習演算法的變形可以更了解演算法的特性。 實現(implement)的方式implement的方式以課本的為主比較好，等到實作出來了以後再看看別人怎麼寫，不然網路上的寫法其實非常多種，令人眼花撩亂，要找到一個符合自己口味的並不是太容易。幸運的找到了一個符合調性的blog也有可能作者用不同的寫法來寫，學習上並不特別效率。自己實作是比較理想的做法，訓練把自己的想法轉變為程式的能力。是個不錯的努力方向。","link":"/2014/06/16/old%20posts/2014-06-16-what-i-learned-after-learning-algorithms/"},{"title":"Bootstrap 學習筆記","text":"sublime的套件安裝與使用方式請看這裡 學習 Bootstrap 的幾個重點 學會使用grid system切版。 找相似的範例來練習版面。 練習熟練到可以直接打指令叫出想要的元件。 懂得微調成自己想要的。 了解如何傳值給後端(selector)。 多練習各種不同的版面 儲存成gist 最後練習 build 各種版面來熟練 bootstrap。 學習原則：相同的東西、學一遍就好，然後一個目標一個目標去扎實的達成，相信是最快的方式。所以直接從3開始學習，看的是 學習資源 Bootstrap RWD 使用方法及原理 limestrap Sublimte Text 3 + Bootstrap Snippets - Create simple login form一個簡單的範例 bootstrap 3 官網 Coder’s Guide一套很不錯的bootstrap教學 其他Bootstrap 3 Tutorial 4 - Using Bootsnipp to Copy &amp; Paste HTML5 Web ElementsBootsnipp","link":"/2014/07/23/old%20posts/2014-07-23-basic-bootstrap-practice/"},{"title":"Sublime 3 套件整理","text":"學習網頁一直以來有個困擾，打括號真的是慢到不行，原來sublime這個文字編輯器有許多方便的套件可以用。用簡單的指令就可以架構出一個網站。 先安裝必備的套件管理工具 ConvertToUTF8 ： 解決 Sublime Text 3 預設不支援 Big5 與其他 CJK 編碼的問題 Emmet: 前端工程師必備的擴充套件 ( 參見 http://emmet.io 官網 )傳說中的 Zen Coding 就是這一套。 AdvancedNewFile快速建立檔案的套件，只要輸入Option+Command+n就可以快速建立檔案。官方使用說明 BootStrap 3 Snippets HTML5Html5的Snippets SublimeLinter可以檢查錯誤的套件demo影片 GIST影片 Sublime-Better-Completiongithub用clone的方式還是靠譜的多 參考資料1.1 Configure Sublime Text 2 for BootStrap &amp; PHP一整系列使用sublime來快速撰寫bootstrap的教學，這篇是安裝套件篇。 Sublime Text 3 新手上路：必要的安裝、設定與基本使用教學 使用 Sublime Text Snippets 快速編輯 Bootstrap 3 的 HTML 代碼 Sublime Text Tutorials #17 - Write HTML Quickly with Emmet一套完整的sublime教學，我只挑了html的部份先看，以後再針對需要學習。教學中使用的是Emmet這個套件。下面連結有比較詳細的安裝教學。","link":"/2014/07/17/old%20posts/2014-07-17-web-tools-sublime-3/"},{"title":"Meteor專用的Sublime套件：TernJs","text":"終於安裝好這個Sublime套件了，安裝上有點麻煩，步驟很多，每次用的時候都要設定一下才能用。不過裝好之後爽度還是挺高的 demo影片 github 簡單記錄一下安裝過程 從finder開啟~/Library/Application Support/Sublime Text 3/Packages資料夾 把github上的meteor.js丟進這個資料夾中的TernJS/ternjs/plugin，如果沒有這三個資料夾，就創一個。 打開sublime &gt; project &gt; save project as &gt; 儲存project sublime &gt; project &gt; edit project &gt; 修改json檔案成（以官網為準） 12345678910111213{ &quot;folders&quot;: [ ... don't touch this part, leave it as it was ... ], // add this! ternjs object &quot;ternjs&quot;: { &quot;libs&quot;: [&quot;browser&quot;, &quot;underscore&quot;, &quot;jquery&quot;], &quot;plugins&quot;: { &quot;meteor&quot;: {} } }} 以後開發 meteor 專案時 先 open sublime-project 把要開發的 meteor 專案的檔案全部加進來 即可開始使用強大的 ternjs 套件 註：不然英打太慢關鍵字又記不清楚頭好暈阿＠＠","link":"/2014/07/23/old%20posts/2014-07-23-tools-meteor-sublime-suites/"},{"title":"Javascript Roadtrip 3 Closure","text":"這一章講的是closure，很奇妙的東西。JavaScript学习总结(十六)——Javascript闭包（Closure）這個網站寫的不錯，看來以後要拜讀一下他的文章。 2.1 影片1234567891011￼￼function buildCoveTicketMaker( transport ) { return function ( name ) {alert(&quot;Here is your transportation ticket via the &quot; + transport + &quot;.\\n&quot; + &quot;Welcome to the Cold Closures Cove, &quot; + name + &quot;!&quot;);￼￼} }```￼```js￼var getSubmarineTicket = buildCoveTicketMaker(&quot;Submarine&quot;);var getBattleshipTicket = buildCoveTicketMaker(&quot;Battleship&quot;);var getGiantSeagullTicket = buildCoveTicketMaker(&quot;Giant Seagull&quot;); 第一次呼叫的時候先初始化transport，因為回傳的是一個function，這時候getSubmarineTicket儲存的已經是內部的inner function，又稱為closure。下次可以直接使用closure這個內部函式，如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859getSubmarineTicket(&quot;Mario&quot;);￼￼￼￼￼￼getBattleshipTicket(&quot;Luigi&quot;);getGiantSeagullTicket(&quot;Bowser&quot;);```￼即會顯示出![Screen Shot 2014-07-29 at 13.19.36.png](http://user-image.logdown.io/user/6619/blog/6590/post/211815/AprhkyhjSF6LexQr6iGl_Screen%20Shot%202014-07-29%20at%2013.19.36.png)## 2.8呼叫closure顯示訊息。## 2.11將location存進陣列中。這題滿值得做的，能夠利用closure來儲存陣列，給五顆星。## 2.12比想像中的複雜，先記錄起來。```jsfunction warningMaker( obstacle ){ var count = 0; var zones = []; return function ( number, location ) { count++; var isThere = false; for (var ii = 0;ii&lt;zones.length;ii++){ if(zones[ii][0]==location){ zones[ii][1]=zones[ii][1]+number; isThere = true; break; }} if (!isThere){ zones.push([location,number]); } var list = &quot;&quot;; for(var i = 0; i&lt;zones.length; i++){ list = list + &quot;\\n&quot; + zones[i][0] + &quot; (&quot; +zones[i][1]+&quot;)&quot;; } alert(&quot;Beware! There have been &quot; + obstacle + &quot; sightings in the Cove today!\\n&quot; + number + &quot; &quot; + obstacle + &quot;(s) spotted at the &quot; + location + &quot;!\\n&quot; + &quot;This is Alert #&quot; + count + &quot; today for &quot; + obstacle + &quot; danger.\\n&quot; + &quot;Current danger zones are: &quot; + list ); };}","link":"/2014/07/29/old%20posts/2014-07-29-javascript-roadtrip-closure/"},{"title":"CSS Dinner - 好玩又有效的 CSS 教學","text":"CSS DinnerCSS Diner 是一個很有趣的小遊戲，你必須使用css來選取桌上扭動的物體，全部26關玩完對 CSS selector 想忘也忘不了。css selector 在 javascript 或是 jQeury 也會用到，不熟的話到時候還是需要花額外的時間加強。有神人整理成一系列好玩練習效果又顯著的教學，好教學不玩嘛？XD 學習目標 Univeral, Type selector, Class selector, ID selector的用法。 了解ul &gt; ui {}和ul ui{}的不同 了解A+B與A~B的不同。 了解pasudo selector的用法。 Memo1. A+B 與 A~B 的不同A+B 代表與 A 相鄰的 B。A~B 代表與 A 同一層的 B 都選。 2. Pseudo Class SelectorMeet the Pseudo Class Selectors 關卡筆記第12關 Adjacent sibling combinator卡了很久，想說 div+apple 應該沒錯，不然 .table+apple 應該萬無一失。忽略了在桌子上面有其他的蘋果。最後使用了 plate+apple 解決了這套題目。 第13關 General sibling combinatorA ~ B will select all B that follow a A 第17關 Last Child Pseudo-selector這關要用last-child來抓出需要的兩個元素，不可以使用其他的方式。div plate apple:last-child, div pickle:last-child 破關心得全部做完後，發現他每一題都沒有重複，有些selector感覺上不太用的到，但是確實很熟練了selector的作法。有些容易混淆的東西一定要搞清楚，並且記熟。 參考的小抄Child and Sibling SelectorsCSS筆記W3Cschool A~B","link":"/2014/08/03/old%20posts/2014-08-03-css-dinner/"},{"title":"Discover meteor Ch4：Collection","text":"Collection新增一個collection 1collections/posts.js 1Posts = new Meteor.Collection('posts'); 除了client與server以外的資料夾會在兩者都執行。所以Posts collection在client和server都可以使用。這裡的Posts前面不加var，這樣整個app都可以存取到Posts。 1git commit -m &quot;Added a posts collection&quot; Collection的性質On the server, the collection has the job of talking to the Mongo database, and reading and writing any changes. In this sense, it can be compared to a standard database library. On the client however, the collection is a secure copy of a subset of the real, canonical collection. The client-side collection is constantly and (mostly) transparently kept up to date with that subset in real-time. Server-Side CollectionOn the server, the collection acts as an API into your Mongo database. ##Client-Side Collectionclient side Mongo稱為MiniMongo，如字面所述，它不支援所有的Mongo的特徵。###三個理解重點 we talk about a client-side collections being a “cache”, we mean it in the sense that it contains a subset of your data, and offers very quick access to this data. In general, a client side collection consists of a subset of all the documents stored in the Mongo collection Secondly, those documents are stored in browser memory, which means that accessing them is basically instantaneous. Mongo on Meteor.com當你的app deploy上meteor之後，輸入meteor mongo myApp就可以存取網路上的mongodb。 #正式開始 輸入meteor reset重置資料庫。確保資料庫是乾淨的。 建立fixture.js 1server/fixtures.js 123456789101112131415if (Posts.find().count() === 0) { Posts.insert({ title: 'Introducing Telescope', author: 'Sacha Greif', url: 'http://sachagreif.com/introducing-telescope/' }); Posts.insert({ title: 'Meteor', author: 'Tom Coleman', url: 'http://meteor.com' }); Posts.insert({ title: 'The Meteor Book', author: 'Tom Coleman', url: 'http://themeteorbook.com' });} Commit 4-2Added data to the posts collection. 修改posts_list.js 1client/views/posts/posts_list.js 12345Template.postsList.helpers({ posts: function() { return Posts.find(); }}); Commit 4-3 1git commit -m &quot;Wired collection into postsList template.&quot; Inspecting DOM Changes這邊看不太懂 刪除autopulish這個package 1$ meteor remove autopublish 新增publication.js 1server/publications.js 123Meteor.publish('posts', function() { return Posts.find();}); 在main.js中subscribe posts 1client/main.js 1Meteor.subscribe('posts'); commit 4-4Removed autopublich and set up a basic publication. 還是不懂在幹嘛？ 接著要解釋的就是publication與subscription 4.5 Publications and SubscriptionsRails App的做法 當user造訪你的網頁，client送出一個request給server。 你的app的第一個工作是找到user所需要的資料。 當找到以後，server會把資料轉換成人類可讀的html。 最後server會將html送給瀏覽器，也就是client。 這樣一個動作就完成了，你的app繼續等待下一個request。 Meteor的做法根據剛剛的介紹可以了解到Rails app只能在server處理資訊。而Meteor在Client也就是你的瀏覽器中就可以處理資訊。這就像書店的店員不只是針對你的需求把書給你，而且他還跟著你回家把書的內容讀給妳聽。 This has two big implications:first, instead of sending HTML code to the client, a Meteor app will send the actual, raw data and let the client deal with it (data on the wire).Second, you’ll be able to access that data instantaneously without having to wait for a round-trip to the server (latency compensation). PublishingWe’ll need a way to tell Meteor which subset of data can be sent to the client, and we’ll accomplish this through a publication. Whats is DDP?這種利用publication/subscription系統的protocol，就稱為Distributed Data Protocol。 Subscribinghow you make a meteor app scalable in client-side 修改publication(server) 123Meteor.publish('posts', function(author) { return Posts.find({flagged: false, author: author});}); 在client subscribe 12// on the clientMeteor.subscribe('posts', 'bob-smith'); AutopulishAutomatically mirroring all data from the server on the client 實際運作如果你去看Publish and subscribe的說明，你會發現實際使用的方法並不是那麼的簡潔，那是因為meteor提供了一個方變的method叫做_publishCursor()。當你在return一個cursor的時候，就會使用到它（例如： return Posts.find({flagged: false, author: author});）。 _publishCursor() 做了哪些事？ It checks the name of the server-side collection. It pulls all matching documents from the cursor and sends it into a client-side collection of the same name. (It uses .added() to do this). Whenever a document is added, removed or changed, it sends those changes down to the client-side collection. (It uses .observe() on the cursor and .added(), .changed() and removed() to do this).","link":"/2014/08/05/old%20posts/2014-08-05-discover-meteor-ch4-collection/"},{"title":"Discover Meteor Ch5：Routing","text":"現在要做的事情是點選http://myapp.com/posts/post_id，就可以對應到post的網頁。 加入iron router這個package。$ mrt add iron-router 知識補充站Iron RouterNot only does it help with routing (setting up paths), but it can also take care of filters (assigning actions to some of these paths) and even manage subscriptions (control which path has access to what data). (Note: Iron Router was developed in part by Discover Meteor co-author Tom Coleman.) Router Vocabulary Routes: A route is the basic building block of routing. It’s basically the set of instructions that tell the app where to go and what to do when it encounters a URL. Paths: A path is a URL within your app. It can be static (/terms_of_service) or dynamic (/posts/xyz), and even include query parameters (/search? keyword=meteor). Segments: The different parts of a path, delimited by forward slashes (/). Hooks: Hooks are actions that you’d like to perform before, after, or even during the routing process. A typical example would be checking if the user has the proper rights before displaying a page. Filters: Filters are simply hooks that you define globally for one or more routes. Route Templates: Each route needs to point to a template. If you don’t specify one,the router will look for a template with the same name as the route by default. Layouts: You can think of layouts as one of those digital photo frames. They contain all the HTML code that wraps the current template, and will remain the same even if the template changes. Controllers: Sometimes, you’ll realize that a lot of your templates are reusing the same parameters. Rather than duplicate your code, you can let all these routes inherit from a single routing controller which will contain all the routing logic. The /lib folderAnything you put inside the /lib folder is guaranteed to load first before anything else in your app . This makes it a great place to put any helper code that needs to be available at all times.A bit of warning though: note that since the /lib folder is neither inside /client or /server, this means its contents will be available to both environments. Layout, Template與This helper will define a special dynamic zone that will automatically render whichever template corresponds to the current route Routing的使用方式 建立layout 建立route.js","link":"/2014/08/05/old%20posts/2014-08-05-discover-meteor-ch5-routing/"},{"title":"星期三搞定一週 88% 工作","text":"Part 1:工作清單以一週為規劃優點 不需要每天製工作清單，可以節省時間精力。 一年原本365份的工作清單，縮減成52份。 有足足一週可以進行最終的彙整工作，消除「工作未完成」的心理壓力。 可嚴選真正重要的工作：一天的工作量僅為一週的七分之一，審視一週所有的工作，較易依工作重要性決定優先次序。 提昇完成工作的成就感，比幾每天完成小部分工作，一週完成一項中大型工作可獲得較高的成就感。 Part2:一週只有三天，以星期三為最後期限為工作添加一些限制，像是「一週只有三天」，「星期三是最後的截止期限」這樣絕對可以讓自己以驚人的高效率、迅速完成工作。因為把工作集中在一個禮拜的前三天完成，這樣高密度的工作下，在經驗中反覆學習改進，自然可以養成高效率、高集中力的工作能力。（p39分析了禮拜中的每一天可能的心態，最後選擇了星期三當做最後期限。） 加班只能星期三 有些企業會將每月或每週的某天，規定為「不得加班的一天」。有「每週有一天絕對不加班」的自我約束，對於減少拖拖拉拉而加班可是相當的有效。 松本幸夫提出的理論是「除了星期三外，一律不加班」才是最佳方式。這個理論應是針對工作上的事務，限制自己一定要在上班時間處理完。這樣下班時間就可以享受、或是學習自己所需要的技能。 如果工作量太大無法實行只有星期三加班，那可以改成實行「每個禮拜的星期四不加班」的方式來解決。 星期三絕對不能延期在瞬息萬變的時代，若是要求「所有的工作都不得延期」，如此嚴苛的條件相信大家看到都冷汗直流吧。因此在逼不得已的情況下，將工作延期，重新規劃也無訪。但是唯獨在決戰之日星期三這天，就算眼前工作堆積如山，也要以「馬上動手做」取代延期。只要決戰星期三能安然度過，接著就可以以無比輕鬆的心情迎接星期四、星期五和週末。 如何精簡星期三的工作了解80%即可宣告大功告成的工作工作並不需要都已100%完成為目標，有些情況下只要完成80%即可宣告大功告成，將時間精力留給其他工作。這代表此項工作並未有應達到完成80%以上的必要性。以一週的前三天較要完成一週的工作的理想時，「不得不做」的工作自然是越少越好。在必要時請將「80%即可宣告大功告成的工作」省略。 區分可省略的工作 vs 不可省略的工作省略重要性低的工作、專注於重要工作上使工作計畫與行程簡潔明瞭，工作效率自然提昇。 不可省略的工作： 信用 安全 個人情報 金錢 品質 人才培育 可省略的工作: 僅限公司內部使用的文件 自己可以完成的工作 除了「不可省略」的工作外，都可以視為「可省略」的工作。 徹底活用「星期三」的關鍵以星期三為重點安排工作計畫時，應符合以下兩點原則： 工作的截止期限，集中於星期三。 優先度高的重要工作，集中於星期三。 在達成此兩點的原則上，我們還可以進一步思考，如何百分之百充分運用重要無比的星期三。工作計畫應確實執行下列三點： 在星期三排定下週的工作計畫 規劃「思考的時間」 保留「空白的時間」 1.在星期三發動下週工作計畫主張以星期三視為黃金工作天，以此概念延伸的工作方法有「必殺絕招」就是：在星期三排定規劃工作計畫的時間。實行的關鍵在於：重視一週的前半段，即星期一、星期二、星期三。在確實留意「在星期三前將一週工作完成時」，自然可以確保星期一、星期二與星期三的工作計畫。 2. 思考的時間松本幸夫認為思考亦是工作的一環。一心專注工作易陷入思考狹隘的陷阱，甚至犯下不應該出現的粗心過失。正因為思考的重要性，因此更應在時間計畫中優先考慮。 3. 空檔時間專用的工作清單在工作或私人形成之間免不了會空下十分鐘、十五分鐘的時間，就是所謂的「空檔時間」。光是在24小時內累積的空檔時間，仔細算算絕對不少。因為空檔時間無法預料何時發生，也當然無法規劃。空檔時間產生後，常常因為不知道這段時間該怎麼辦，就白白浪費了這段寶貴的時間。 為了有效的利用空檔時間，請注意以下幾點： 一有空檔時間應馬上行動 為了可以立即反應，應事先將代辦事項列成工作清單。了解以上兩點後，製作「空檔時間專用的工作清單」之重要性不言而喻： 不需複雜思考亦可以完成的事。 低重要性卻非做不可的雜事。 15分鐘內可完成的簡單工作。例如：回覆email…等等 觀念 不論學習了多麼高明的時間管理技巧，若是罹患了「明日病」，一切只是枉然。 追求成功的關鍵在於儘早擺脫時間的奴隸，化身為時間的主人。安排工作時間時，優先排定對自己而言重要的工作，讓重要工作擁有充足的時間。 為了避免生活失去平衡，請先優先安排私人行程。私人享樂擺第一。私人享樂所帶來的期待和快樂將成為工作的原動力。 後記有些有參考價值的書，寫成網誌來整理似乎還不錯，加深印象，整理出來的內容更便於回顧。這本書是每年開課超過220堂的時間管理學大師松本幸夫所著。推翻每天列工作清單的方法，採用「工作以週為單位」的時間管理方法。讀了之後發現跟我的習慣很接近，我也是喜歡以「工作成果」來估量自己的效率，並且喜歡在短時間內解決大量的工作。這跟松本幸夫所提出的利用一半時間就完成工作的理念不謀而合。既然是這麼適合自己的書，就來發掘一下有什麼重要的觀念需要注意！","link":"/2014/08/09/old%20posts/2014-08-09-get-things-down-at-wednesday/"},{"title":"Sitcon workshop：Git 入門到進階與實務經驗談","text":"Git 入門到進階與實務經驗談workshop網頁sitcon這次舉辦的為期五天的workshop每天不一樣的主題，我參加的有 8/11 Git 入門到進階與實務經驗談 8/14 那些學校沒教的黑魔法攻防 8/15 學習設計：從一個網站的設計開始 這是第一天 Git workshop 的學習筆記主講人:Denny投影片: 連結 第零部分：前置設定1. 讓你的termenal可以顯示出精美的彩色branch樹狀圖1git config --global alias.lg &quot;log --color --graph --all --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --&quot; 這些設定會存在.gitconfig ，因為指令加上–global，會加到user的設定上，而不是rep。設定完成後以後輸入git lg就會顯示樹狀圖與commit詳細資訊。 1git lg 將commit再終端機中顯示成樹狀圖。 2. 在terminal顯示branch名稱12345function parse_git_branch { git branch --no-color 2&gt; /dev/null | sed -e '/^[^*]/d' -e 's/ (.)/(\\1)/'}export PS1=&quot;\\h:\\W \\u\\$(parse_git_branch)$ &quot; 將以上代碼貼到.bashrc profile， 第一部分：git基本操作1ls -al 顯示資料夾內的隱藏檔案。 認識git儲存的結構 working space是你的工作目錄staging area 代表這些檔案等著進reprepository則是儲存庫 牛刀小試1git add 輸入git add . 將檔案抓進staging area。 1git reset 輸入git reset，將staging area把檔案拿出來。 1git status 輸入git status可以查看目前的狀態。untracked files內的資料代表在staging area的檔案。 gitingnore與gitkeep1.使用gitignore來設定不需要版本控制的檔案1.gitignore 像binary這種佔空間且無法比較，就不存放在rep裡。 2.使用gitkeep將資料夾加進版本控制之中1.gitkeep 建造一個空資料夾時，git並不會把它直接加進版本控制中，而加入gitkeep後讓這個新的資料夾加入版本控制中。 使用git diff來檢查差異1git diff 可以看到目前版本與前一個版本的差異 1git diff --cached 可以看到rep和staging area的差異 git commit與patch commit1git commit 除了第一行外，其他部分可以寫詳細的演算法、作法，可以使用git log來看完整的內容。(git status只看的到第一行) 1git commit -m &quot;commit message&quot; 當commit不需太多說明時，使用單行的commit可以使用此指令。 1git add --patch youtube - Intro to git add patch mode tutorial 1git commit --patch 對某幾行commit而非整個檔案。 1git commit -a 跳過staging area從work directory直接丟進rep。 使用 git show 顯示 commit 資訊1git show = git show HEAD HEAD表示最新的一筆，所以git show就是顯示最新的一個commit。 1git show HEAD^ 表示HEAD的前一筆 認識git rmgit rm不只能夠刪除檔案還能夠取消追蹤檔案。 1git rm &lt;file&gt; Remove file 1git rm --cached &lt;file&gt; Untrack file 認識 git checkoutgit checkout HEAD^HEAD變成前一筆。 1git checkout master 返回最新版 1git checkout &lt;reversion&gt; &lt;file&gt; 把以前版本的單一檔案拿回來。 認識git stash1git stash 把工作區原封不動的保存起來（本地沒有變動的時候會不給暫存）。 1git stash list 看到目前暫存的東西 1git stash pop 把暫存的東西拿出來 1git stash show stash@{0} 顯示修改後的檔案 1git stash show -p stash@{0} 顯示修改後的檔案內容 1git stash drop 把暫存區的東西刪掉 認識git reset1git reset HEAD^ 刪掉一筆commit，但會保留目前檔案的內容。 1git reset HEAD^ --hard 刪掉一筆commit，連檔案內容都刪掉。 認識git revert1git revert 將別人所做的commit取消，讓revert的東西存在commit之中。 第二部分：推上遠端rep(Github)1git push origin master 本地會跟著名稱相同的遠端rep 1git push origin -u master 讓本機知道要跟著origin這條，以後只要打git push就可以推上去。這個路徑檔寫入在.git/config裡面。 1git branch -avv 看所有的-a -avv看更詳細 1git remote 可以看到目前有的分支 1git remote -v 可以看到目前分支的詳細資訊 1git remote show Cache https password使用cache記錄帳號密碼，可以設定可維持的時間。 12git config --global credential.helper cachegit config --global credential.helper &quot;cache --timeout=3600&quot; ssh小概念id_rsa.pub 公鑰 - 可以發給網路上的人id_rsa 私鑰 - 絕對不可以流出去 本機不知道該跟哪條branch的時候使用XXX可以修改指令。 練習：解決衝突先來製造點衝突開兩個terminal 分別是原來是repo與用git clone回來的repo接下來各下一個新的commit，修改同一檔案。並且push上遠端。第二個修改的commit需要先使用git pull把新版本拉回來，解決完衝突才能繼續push。(git pull = git fetch + git merge) 第三部分：初探branchbranch的用法很廣泛，一般來說分為三種主要的branch。不同branch的東西是不會互相污染的。 developer branch - 主要人員都在developer branch上開發。release branch - 穩定版本feature branch - 開發新功能 git pull 與 git pull –rebase 的差異1git pull merge 完的 branch 會顯示分支 1git pull --rebase merge 完的branch不會顯示不必要的分支。（因為本來就是同一個branch） 更詳細的介紹請參照 使用 git rebase 避免無謂的 merge Create a branch12git branch &lt;branch name&gt;git checkout -b &lt;branch name&gt; 直接跳過去dev順便創造。 查詢branch的資訊1234git branch -agit branch -vgit branch -vvgit branch -avv 顯示的資訊最詳細，所以用這個就好 把branch推上遠端rep1git push origin dev 把dev推上去 把dev merge回mastergit merge dev Fast forward 當master未新增東西時，branch有新東西。這時會發生fast forward現象。也就是branch直接接回master。 想保持branch的資訊依然存在，這時可以使用 1git merge --no-ff 刪除一個branch1branch -D 把branch砍掉。 使用cherry-pick1git cherry-pick &lt;reversion&gt; 把某一個branch的其中一個commit拿過來用。 第四部分：其他常用指令Modify commit history1git commit --amend 修改commit message，commit時會產生的commit id，建議只有在還沒推到server的時候做。 1git commit --amend --date=&quot;Mar 15 00:00 2014&quot; 修改commit的時間 1git rebase -i &lt;reversion&gt; 用 git relog 把 git reset –hard 的東西救回來 git reflog git reset –hard 要切回的分支id More about git log1234567git log -p --statgit log --onelinegit log --graphgit log --abbrev-commitgit log --pretty=%angit whatchangedgit log --author=&quot;Denny Huang&quot; 查詢某人對專案的貢獻 1git log --since={2014-07-01} --until=&quot;1 week ago&quot; 查詢時間內的log search by regex1git log -p -i -G 'regex' 想知道誰動了哪一行1git blame &lt;filepath&gt; 延伸閱讀Git-rebase 小筆記","link":"/2014/08/11/old%20posts/2014-08-11-sitcon-git-workshop/"},{"title":"jQuery Return Flight Ch1 ( 1 )：Ajax Basics","text":"這是之前在try jQuery做過的例子。 之前我們只能顯示localhost的圖片，現在我們要從server載圖片下來，並顯示之。接下來來完成我們第一個Ajax程式。 12345678$('.confirmation').on('click', 'button', function(){ $.ajax('http://example.org/confirmation.html', { success: function(response) { $('.ticket').html(response).slideDown(); } });}); 使用Ajax回傳的網頁並不是完整的網頁，而是只有局部更新。 12345&lt;div&gt; ... &lt;strong&gt;Boarding Pass: &lt;/strong&gt; &lt;a href='#' class='view-boarding-pass'&gt;View Boarding Pass&lt;/a&gt; &lt;img src='ticket.png' alt='Your boarding pass' class='boarding-pass' /&gt;&lt;/div&gt; Aax使用的是相對網址(relative URL)12345$('.confirmation').on('click', 'button', function(){ $.ajax('confirmation.html', { success: function(response) { $('.ticket').html(response).slideDown(); } });}); 跟http://example.org/confirmation.html一樣的效果。 使用$.get減少程式碼使用$.ajax 12345$.ajax('confirmation.html', { success: function(response) { $('.ticket').html(response).slideDown(); }}); 使用$.get 123$.get('confirmation.html', function(response) { $('.ticket').html(response).slideDown();}); 兩種方法效果完全一樣，用get的寫法比較精簡。格式是$.get(url, success callback) Sending parameters with requests有兩種寫法，作用是相等的。第一種把網址填入url 1234$.ajax('confirmation.html?confNum=1234', { success: function(response) { $('.ticket').html(response).slideDown(); }}); 第二種將網址寫在data項目之下 1234567$.ajax('confirmation.html', { success: function(response) { $('.ticket').html(response).slideDown(); }, data: { &quot;confNum&quot;: 1234 } }}); 這兩種方法都是寫死的，正常來說資料是會變動的，所以應該要用以下寫法。 1&lt;div class='ticket' data-confNum='1234'&gt; 1234567$.ajax('confirmation.html', { success: function(response) { $('.ticket').html(response).slideDown(); }, data: { &quot;confNum&quot;: $(&quot;.ticket&quot;).data(&quot;confNum&quot;) }}); 1.6 Ajax Data原本會顯示全部的圖片，透過修改data對應的url，變成只顯示london這張圖片我的答案是這樣 1234567891011$(document).ready(function() { $(&quot;#tour&quot;).on(&quot;click&quot;, &quot;button&quot;, function() { $.ajax('/photos.html', { data: {location:'london'}, success: function(response) { $('.photos').html(response).fadeIn(); } }); });}); 這時候出現了以下的錯誤 因為我把值寫死了，使用data來對應是比較好的作法。 1234567891011$(document).ready(function() { $(&quot;#tour&quot;).on(&quot;click&quot;, &quot;button&quot;, function() { var el = $(&quot;#tour&quot;); $.ajax('/photos.html', { data: {location: el.data('location')}, success: function(response) { $('.photos').html(response).fadeIn(); } }); });}); Ajax options使用error處理失敗的request 使用beforeSend和Complete製作Loading效果 使用delegation解決錯誤因為DOM在一進入頁面的時候就載入，所以如果用第一個寫法會發生錯誤，因為根本就還沒有這個物件。這時候需要delegate，在觸發事件的後面跟著設定一個selector，符合這個selector才會執行。delegate官方文件 1.8 在.photos內顯示新的&lt;li&gt;123456&lt;div id=&quot;tour&quot; data-location=&quot;london&quot;&gt; &lt;button&gt;Get Photos&lt;/button&gt; &lt;ul class=&quot;photos&quot;&gt; &lt;/ul&gt;&lt;/div&gt; 1$('.photos').html('&lt;li&gt;There was a problem fetching the latest photos. Please try again.&lt;/li&gt;');","link":"/2014/08/25/old%20posts/2014-08-25-javascript-return-flight/"},{"title":"Ruby bits ( 2 ) : Methods and Classes","text":"Hash Argument每一個不同的欄位就多一個 argument不是個好方法，會造成很多欄位空在那邊。用 Hash argument 來解決這個問題。使用方法，因為 hash 是由 key-value 所組成，所以可以把需要的屬性設成 symbol ，也就是:lat這種樣子。後面指定它的 value，形成 key-value 的形式。改寫成 1.9 以後的 hashhash 中的 key 可以省略，只寫出某幾個就可以，就連hash argument 本身都可以省略，。 Exceptions當 tweets 是空的時候，我希望我會知道這個訊息，這時候 Exception 就派上用場了。 123456def get_tweets(list) unless list.authorized?(@user) raise AuthorizationException.new end list.tweetsend 現在我有一個 method 叫做 get_tweets(list)，當他發現 user 沒有認證的時候，它就會丟出AuthorizationException這個例外，對應的程式碼是raise AuthorizationException.new，接下來再用另外一段程式碼，把剛剛上面的程式碼包起來，因為我們接下來要做的是對拋出的例外做一些處理，好讓我們可以藉由 exception 更輕鬆的了解到錯誤出現在哪裡。 12345begin tweets = get_tweets(my_list)rescue AuthorizationException warn &quot;You are not authorized to access this list.&quot;end 12行，先執行我們剛剛建立的method 叫做 get_tweet(my_list)，接著 34 行的意思是當發現有認證例外（AuthorizationException）產生時，就會跳出警告&quot;You are not authorized to access this list.&quot;。延伸閱讀：Ruby Exceptionstutorial point ruby exceptionruby exceptions and error handling Splat Argument前面有加 * 字號的變數代表傳入的會是 Array，依序傳入為 Array[0]、Array[1]、Array[2]…以此類推。 You Need a Class When … OverSharing Reopen Classes You can re-open and change any class. Beware! You don’t know who relies on the old functionality. You should only re-open classes that you yourself own. Self","link":"/2014/09/04/old%20posts/2014-09-04-ruby-bits-2-methods-and-classes/"},{"title":"Ruby bits ( 1 ) : Expression","text":"UnlessUnless is more intuitive用 unless 代替 if! 更加直覺 Unless with else is confusingunless 和 else 一起用的時候令人困惑 NILNIL IS FALSE因為 nil 的值等於 false 所以上面的程式可以簡化成下面這樣。 ONLY NIL IS FALSERails 世界中只有 nil 的值是 false（除了 False 本身的值當然是 False 以外）。 inline condition short circuit assignment指的是使用 and(&amp;&amp;) 和 or(||)來縮減 if-else Ex1 : if nil, default to empty array Ex2 : sign in一個常見的例子是用在「判斷使用者有沒有登入」，如果 session 中有 user_id 就去找到相對的 user。 session 中沒有找不到 user_id 時才導向登入畫面。 123def sign_in current_session || sign_user_inend conditional assignment 現在有一個敘述i_was_set ||= 2它的意思是如果 i_was_set 這個變數還沒被 assign 值，那就設定為2(下方的例子)。如果已經被 assign了值，i_was_set 的值保持原來 assign 的值（上方的例子）。 再看一個例子，如果變數未指定的話就會設成後面的值。 conditional return values利用 =if 來減少重複的程式碼。原理是再function中裸寫出一個值時，其實意義上等於 return 剛剛寫下的那個值。舉例來說 12345if list_name &quot;/#{user_name}/#{list_name}&quot;else &quot;/#{user_name}&quot;end 會回傳&quot;/#{user_name}/#{list_name}&quot;或&quot;/#{user_name}&quot;，所以如果寫下 12345options[:path] = if list_name &quot;/#{user_name}/#{list_name}&quot;else &quot;/#{user_name}&quot;end 其實就等於 12345if list_name options[:path] = &quot;/#{user_name}/#{list_name}&quot;else options[:path] = &quot;/#{user_name}&quot;end 上式先判斷listname的值，再指定給option[:path]，下式也是先判斷list_name的值，再指定給 option[:path]。可以發現兩者邏輯是相同的，只是書寫的方式看起來不同。 conditional return values (ex2)12345678def list_url(user_name, list_name) if list_name url = &quot;https://twitter.com/#{user_name}/#{list_name}&quot; else url = &quot;https://twitter.com/#{user_name}&quot; end urlend 1234567def list_url(user_name, list_name) if list_name &quot;https://twitter.com/#{user_name}/#{list_name}&quot; else &quot;https://twitter.com/#{user_name}&quot; endend CASEcase 的用法跟java不太一樣，但是其實意義上有點類似，ruby裡面的case流程判斷的else就是java裡面switch流程判斷的default。然後java設定條件的地方用關鍵字 case 而 ruby 用關鍵字 when。 CASE RANGES12345678popularity = case tweet.retweet_count when 0..9 nil when 10..99 &quot;trending&quot; else &quot;hot&quot;end CASE - REGEXPS12345678tweet_type = case tweet.status when /\\A@\\w+/ :mention when /\\Ad\\s+\\w+/ :direct_message else :publicend CASE - WHEN/THEN12345tweet_type = case tweet.status when /\\A@\\w+/ then :mention when/\\Ad\\s+\\w+/ then :direct_message else :public end 這個設定滿方便，用java寫至少要拆成兩個物件才能夠取得return的值。(看不懂不要緊，我沒有說的很清楚，總之就記得ruby這樣的寫法是比較簡潔的即可)。","link":"/2014/09/03/old%20posts/2014-09-03-ruby-bits-1-expression/"},{"title":"Ruby bits ( 3 )：Class","text":"上一個禮拜想要嘗試更多的動手記憶，經過實驗證明，還是需要筆記的輔助反覆記憶會比較好。經過這次的練習之後會更注重學習本身的強度。 ENCAPSULATION封裝跟物件本身有關的method，使用class會比使用許多的method來的好。 VISIBILITY有一些method你並不想給外面的人直接使用他，那麼宣告成private，限制這些private method不能給外面的人所使用。 12345678910class User def up_vote(friend) bump_karma friend.bump_karma end protected def bump_karma puts &quot;karma up for #{name}&quot; endend INHERITANCE重複的程式碼使用繼承來避免。原來程式碼： 12345678910111213class Image attr_accessor :title, :size, :url def to_s &quot;#{@title},{@size}&quot; endendclass Video attr_accessor :title, :size, :url def to_s &quot;{@title}, {@size}&quot; endend 使用繼承後： 123456789class Attachment attr_accessor :title, :size, :url def to_s &quot;#{@title}, #{@size}&quot;end endclass Image &lt; Attachmentendclass Video &lt; Attachmentend ruby內的繼承就用箭頭&lt;來表示 SUPERruby的super跟java的super只能夠繼承constructor一樣。（見下圖） super的省略寫法super不僅可以在method裡面用，而且有省略寫法。不過一開始學習還是把參數加上去避免混淆。 overideing methods以加強執行效率原來寫法：使用case來判斷。 12345678910class Attachment def preview case @type when :jpg, :png, :gif thumbnail when :mp3 player end endend 不如直接使用subclass，增加效率。 1234567891011class Attachment def preview thumbnail endendclass Audio &lt; Attachment def preview player endend HIDE INSTANCE VARIABLES這節要討論的是如何簡化程式碼原本 12345678class User def tweet_header [@first_name, @last_name].join(' ') end def profile [@first_name, @last_name].join(' ') + @description endend 可以看到method內有重複的地方。把他們包起來獨立出來。 1234567891011class User def display_name [@first_name, @last_name].join(' ') end def tweet_header display_name end def profile display_name + @description endend 更漂亮的寫法? 1234567891011class User def display_name title = case @gender when :female married? ? &quot;Mrs.&quot; : &quot;Miss&quot; when :male &quot;Mr.&quot; end [title, @first_name, @last_name].join(' ') endend OverrideOverride的方法很簡單，直接取相同的method名稱，就可以複寫掉父類別的method。 最後一關重構程式碼 refactoring","link":"/2014/09/05/old%20posts/2014-09-05-ruby-bits-3-class/"},{"title":"Ruby bits ( 4 )：ActiveSupport","text":"install it and load itinstall itgem install activesupportgem install i18n load itrequire ‘active_support/all’ core extensions: arrayarray.form()array.to()array.in_group_ofarray.splite core extensions: Date.at_beginning_of_day.at_end_of_monthr core extensions:hash有兩個hashoptions = {user: ‘codeschool’, lang: ‘fr’}new_options = {user: ‘codeschool’, lang: ‘fr’, password: ‘dunno’} options.diff(new_options)比較option與new_options的不同 options.stringify_keysturn keys into strings Merge hash會以前面的為主 remove keysnew_options.except(:password) 檢查是否有額外的keynew_options.assert_valid_keys(:user, :lang)，如果有額外的key的話就會出現警示訊息 core extensions: integerodd or evenindex.odd?index.even? ordinallize“#{1.ordinalize} place!”“#{2.ordinalize} place!”“#{3.ordinalize} place!” pluralize and singularize轉換單字的單數與複數 titleize and humznize 延伸閱讀看完還是有點霧煞煞，接著來看ihower實戰聖經:active support","link":"/2014/09/05/old%20posts/2014-09-05-ruby-bits-4-active-support/"},{"title":"Ruby bits ( 6 )：Blocks 學習筆記","text":"不得不再說一次，這些主題都超級重要，不先學Ruby直接學Rails感覺很卡。果然要從基礎開始打才是王道。在看這篇之前請先看完method / block / yield / Proc / lambda，很多觀念都是從這邊的延伸。 conventionsblock有兩種表達方式 single blockbraces if the block is a single line 1words.each { |word| puts word } multiblockdo/end if it’s multiple lines 1234words.each do |word| backward_word = word.reverse puts backward_wordend yield這邊有一個yield的範例 1234def call_this_block_twice yield yieldend 12call_this_block_twice{ puts &quot;twitter&quot;} #=&gt;twitter twitter 一開始看一定看不懂他是怎麼做的，因為他省略了很多東西，其實call block可以拆解成三個部分，第一個部分是定義呼叫block的function，在這個例子中就是 1234def call_this_block_twice yield yieldend 使用yield的時候可以省略傳入的&amp;block與呼叫的.call方法，上面這段程式碼等同於 1234def call_this_block_twice(&amp;block) block.call block.callend 第二個部分是宣告block在這個例子中省略了這一部分，其實”twitter”就是一個傳入的block。 第三部分是傳入block到function之中輸出結果把”twitter”這個block傳進能夠處理block的function之中。 12call_this_block_twice{ puts &quot;twitter&quot;} #=&gt;twitter twitter yield - arguments再來看另一個範例 123def call_this_block yield &quot;tweet&quot;end yield中傳入了參數”tweet”，也就等於block.call(“tweet”) 12call_this_block { |myarg| puts myarg } #=&gt;tweet 12call_this_block { |myarg| puts myarg.upcase } #=&gt;TWEET 這時候如果要在call block的時候呼叫參數，要用|和|把輸入的參數包起來。接著後面的陳述式就可以對輸入的進行一些處理。 Your own “each”現在我的class中有兩個method，一個要列出朋友的tweet，一個要儲存朋友的tweet。可以發現@user.friends.each do |friend| 這段iteration重複了。 12345678910111213class Timeline def list_tweets @user.friends.each do |friend| friend.tweets.each { |tweet| puts tweet } end end def store_tweets @user.friends.each do |friend| friend.tweets.each { |tweet| tweet.cache } end endend 於是我們來著撰寫自己的each 12345678910class Timeline def each @user.friends.each do |friend| friend.tweets.each { |tweet| yield tweet } end endendtimeline = Timeline.new(user)timeline.each { |tweet| puts tweet }timeline.each { |tweet| tweet.cache } 加入Enumerable擴充更多的method 123456class Timeline def each...end include Enumerableend 在include Enumerable這個module之後，瞬間多了很多method（如下），要解了更多就去看看ruby-doc Enumerable吧。 123timeline.sort_by { |tweet| tweet.created_at }timeline.map { |tweet| tweet.status }timeline.find_all { |tweet| tweet.status =~ /\\@codeschool/ } 重構練習12345678910def update_status(user, tweet) begin sign_in(user) post(tweet) rescue ConnectionError =&gt; e logger.error(e)ensure sign_out(user) endend 12345678910def get_list(user, list_name) begin sign_in(user) retrieve_list(list_name) rescue ConnectionError =&gt; e logger.error(e)ensure sign_out(user) endend 有裡個method裡面除了核心邏輯以外全部都一樣。這樣的話我們需要進行重構來實現DRY原則。因為Proc本身就是匿名函數也就是一段未執行程式碼，所以特別適用這個情況。 把重複的地方獨立出來，核心邏輯用yield代替。 123456789def while_signed_in_as(user) begin sign_in(user) yield rescue ConnectionError =&gt; e logger.error(e) ensure sign_out(user) endend 使用do的時候會省略傳入的&amp;block，所以這段程式碼其實是對block做些處理，並顯示在block.call也就是yield的部份。 123while_signed_in_as(user) do post(tweet)end 123tweets = while_signed_in_as(user) do retrieve_list(list_name)end 最後可以改寫的精簡一點去掉不必要的begin和end 12345678def while_signed_in_as(user) sign_in(user) yield rescue ConnectionError =&gt; e logger.error(e) ensure sign_out(user)end 作業實作6.1使用each代替for迴圈。原來使用for迴圈的程式： 123456def list for i in 0...(games.length) game = games[i] puts game.name endend 改寫成each 12345def list games.each do|game| puts game.name endend 6.2現在我們有一個class叫做Game裡面裝著每場比賽的資訊。有一個陣列叫做Games，裡面蒐集了很多場的比賽。現在我們要在Library中寫一個方法叫做each_on_system(system)，讓他可以讀出Games陣列裡面符合輸入的system的比賽。 1234567891011class Library attr_accessor :games def initialize(games = []) self.games = games end def each_on_system(system) endend 使用範例example.rb 12library = Library.new(GAMES)library.each_on_system(&quot;SNES&quot;) { puts &quot;Found a Super Nintendo game&quot; } 將library修正後，即為所得。 12345678910111213class Library attr_accessor :games def initialize(games = []) self.games = games end def each_on_system(system) games.each do|game| yield if game.system == system end endend 6.3 Passing Argument to Blocks讓產生的block能夠使用iterator的參數。如下圖可以使用|game|。 12library = Library.new(GAMES)library.each_on_system(&quot;SNES&quot;) { |game| puts game.name } 6.4 Return Value From blockModify the list method to yield to a block and print whatever the block returns.除了能夠在block中使用以外還要可以直接印出來。 12library = Library.new(GAMES)library.list { |game| &quot;#{game.name} (#{game.system}) - #{game.year}&quot; } 12345678910111213class Library attr_accessor :games def initialize(games = []) self.games = games end def list games.each do |game| puts yield game end endend 6.5include Enumerable module6.6重構以避免重複123456789101112131415161718192021222324252627282930class Game attr_accessor :name, :year, :system attr_reader :created_at def initialize(name, options={}) self.name = name self.year = options[:year] self.system = options[:system] @created_at = Time.now end def play begin emulator = Emulator.new(system) emulator.play(self) rescue Exception =&gt; e puts &quot;Emulator failed: #{e}&quot; end end def screenshot begin emulator = Emulator.new(system) emulator.start(self) emulator.screenshot rescue Exception =&gt; e puts &quot;Emulator failed: #{e}&quot; end endend 1234567891011121314151617181920212223242526272829303132333435class Game attr_accessor :name, :year, :system attr_reader :created_at def initialize(name, options={}) self.name = name self.year = options[:year] self.system = options[:system] @created_at = Time.now end def play emulate do |emulator| emulator.play(self) end end def screenshot emulate do |emulator| emulator.start(self) emulator.screenshot end end private def emulate begin emulator = Emulator.new(system) yield emulator rescue Exception =&gt; e puts &quot;Emulator failed: #{e}&quot; end endend 1234567891011121314151617class Emulator def initialize(system) # Creates an emulator for the given system end def play(game) # Runs the given game in the emulator end def start(game) # Loads the given game but doesn't run it end def screenshot # Returns a screenshot of the currently loaded game endend","link":"/2014/09/06/old%20posts/2014-09-06-ruby-bits-6-blocks/"},{"title":"Ruby bits ( 5 )：Modules","text":"Ruby bits的課程真的很不錯，講到的主題都是很重要的東西。有點相見恨晚的感覺，趕快把它做完吧! 本節學習目標 module activesupport ::Concern 了解self的意義 part1: moduleclass method與instance methoduse extend to expose methods as class method123class Tweet extend Searchableend 使用的時候，直接呼叫class（開頭大寫）。 1Tweet.find_all_from('@GreggPollack') use include to expose methods as instance methodsinstance method用include引進module 123class Image include ImageUtilsend 12image = user.imageimage.preview part2 :how to include class method and instance method in the same time第一種方法：依照直覺該怎麼寫第一種方法是在class中includ module並且extend classmothods。下例中Image想要使用ImageUtils這個module的class method與instance method，所以用兩種方式各自引用。 1234class Image include ImageUtils extend ImageUtils::ClassMethodsend 1234567891011121314module ImageUtils def preview end def transfer(destination) end module ClassMethods def fetch_from_twitter(user) end endend 使用上可以按照之前所學的來呼叫class method與instance method 123image = user.imageimage.previewImage.fetch_from_twitter('gregg') 第二種方法:method hooks這樣每次使用module的時候都需要explore兩種module實在太麻煩了，引入class module這個動作在module完成，這樣我們就不需要每次都引入兩種method，只要引入module就可以了。於是第二種方法method hook產生了： 1234class Image include ImageUtils #extend ImageUtils::ClassMethods 刪除掉引入class method的這一行end 12345678910111213module ImageUtils def self.included(base) #加入self.include （self就是ImageUtils這個module） base.extend(ClassMethods) end def preview end def transfer(destination) end module ClassMethods def fetch_from_twitter(user) end endend part3: 使用Activesupport :: Concern解決相依性問題 Activesupport :: Concern代表什麼意思:: is basically a namespace resolution operator. It allows you to access items in modules, or class-level items in classes. For example, say you had this setup:關鍵字double colon rubyWhat is Ruby’s double-colon (::) all about? 使用方式在terminal下gem install activesupport安裝activesupport在module檔中(xxx.rb)中require ‘active_support/concern’ 12345678910111213141516require 'active_support/concern' module ImageUtils extend ActiveSupport::Concern included do clean_up end module ClassMethods def fetch_from_twitter(user) end def clean_up end endend 這樣就可以直接include ImageUtil的ClassMethods 123class Image include ImageUtilsend 這樣看起來沒什麼了不起的對吧？只是換個寫法。實際上cocern的出現是為了解決更重要的問題，讓我們看下去。 Acitvesupport::concern要解決的問題12345678module ImageUtils def self.included(base) #base is ImageProcessing module base.extend(ClassMethods) end module ClassMethods def clean_up; end endend 12345678module ImageProcessing include ImageUtils def self.included(base) base.clean_up #undefined method error endend 123class Image include ImageProcessingend 這樣乍看之下好像沒問題，但是卻有個嚴重的問題導致無法執行，因為ImageUtils變成是由ImageProcessing所 include，所以對 ImageUtils 的 self.included 來說，他的參數 base 變成了 ImageProcessing 了，所以他就沒辦法存取到宿主 Host 的任何函式及變數，do_host_something 時就會失敗。 Okay，ActiveSupport::Concern 就是來幫助解決這個難題，我們希望宿主可以不需要知道 modules 之間的 dependencies 關係。dependencies 關係寫在 module 裡面就好了。 12345678module ImageUtils extend ActiveSupport::Concern module ClassMethods def clean_up; end endend 123456789module ImageProcessing extend ActiveSupport::Concern include ImageUtils included do clean_up endend 123class Image include ImageProcessingend Dependencies are properly resolved！！ part4 作答中遇到的問題5.1 宣告成class method原本的 1234module GameUtils def lend_to_friend(game, friend_email) endend 改成 1234module GameUtils def self.lend_to_friend(game, friend_email) endend 這樣呼叫時就會從原本的 12game = Game.new(&quot;Contra&quot;)game.lend_to_friend(game, &quot;gregg@codeschool.com&quot;) 變成 12game = Game.new(&quot;Contra&quot;)GameUtils.lend_to_friend(game, &quot;gregg@codeschool.com&quot;) 5.2 reopen game and include the gameutil module5.3 reopen Game and expose the method from module as class method of Game class原本 12class Gameend 加上GameUtils的class method 123class Game extend GameUtilsend 5.4 extend the single game object with Playable module原本 12game = Game.new(&quot;Contra&quot;)game.play 加入module Playable的method到game這個instance中。 123game = Game.new(&quot;Contra&quot;)game.extend(Playable)game.play module長這樣 1234module Playable def play endend 這個用法讓我有點困惑，特地查了一下ruby-docextend的解釋如下Adds to obj the instance methods from each module given as a parameter.雖然是用extend這個字，但並非是繼承的意思，而是加入instance method。 5.5使用self.include初始化class method 5.6使用ActiveSupport::Concern代替self.included 5.7 AcitveSupport::Concern part II使用included class method 5.8 AcitveSupport::Concern part III延伸閱讀：深入Rails3: ActiveSupport::ConcernSelf - The current/default objectActiveSupport::Concern","link":"/2014/09/05/old%20posts/2014-09-05-ruby-bits-5-modules/"},{"title":"EDX Linux Foundation Ch 8：Filesystem","text":"File systemMountFile system table If you want it to be automatically available every time the system starts up, you need to edit the file /etc/fstab accordingly (the name is short for Filesystem Table) man fstab可以查詢文件 NFC(The Network Filesystem)file system arctectureThe /bin directory contains executable binaries, essential commands used in single-user mode, and essential commands required by all system users, such as:","link":"/2014/09/08/old%20posts/2014-09-08-edx-linux-foundation-ch-8-filesystem/"},{"title":"Ruby bits 2 ( 1 )：BLOCKS, PROCS &amp; LAMBDAS","text":"雖然跟Ruby bit名字很像，但是內容的確比較進階點。 two ways for storing blocks1.Proc1234my_proc = Proc.new do puts &quot;tweet&quot;endmy_proc.call # =&gt; tweet 等同於 12my_proc = Proc.new { puts &quot;tweet&quot; }my_proc.call # =&gt; tweet 2.lambda使用lambda來儲存又稱為static lambda。 12my_proc = lambda { puts &quot;tweet&quot; }my_proc.call # =&gt; tweet Ruby1.9以前的版本是這樣寫 12my_proc = -&gt; { puts &quot;tweet&quot; }my_proc.call # =&gt; tweet block to lambda12345678910class Tweet def post if authenticate?(@user, @password) # submit the tweet yield else raise 'Auth Error' end endend 12tweet = Tweet.new('Ruby Bits!')tweet.post { puts &quot;Sent!&quot; } 等同於 12345678910class Tweet def post(success) if authenticate?(@user, @password) # submit the tweet success.call else raise 'Auth Error' end endend 123tweet = Tweet.new('Ruby Bits!')success = -&gt; { puts &quot;Sent!&quot; }tweet.post(success) multiple lambdas12345678910class Tweet def post(success, error) if authenticate?(@uerser, @password) # submit the tweet success.call else error.call end endend 1234tweet = Tweet.new('Ruby Bits!')success = -&gt; { puts &quot;Sent!&quot; }error = -&gt; { raise 'Auth Error' }tweet.post(success, error) Using the ampersand有兩種情況會用到ampersand也就是＆符號 1.Calling a method with &amp; in front of a parameter1tweets.each(&amp;printer) turn a proc into block 2.Defining a method with &amp; in front of a parameter1def each(&amp;block) turns a block into a proc so it can be assigned to parameter 這兩種用法很常同時使用 example 1:12printer = lambda { |tweet| puts tweet }tweets.each (printer) ( 這樣會出現錯誤，因為each expects a block, not a proc.改成這樣就沒問題了。 12printer = lambda { |tweet| puts tweet }tweets.each(&amp;printer) &amp;turns proc into block example 2:123456class Timeline attr_accessor :tweets def each(&amp;block) #block into proc tweets.each(&amp;block) #proc back into a block endend 1234timeline = Timeline.new(tweets)timeline.each do |tweet| puts tweetend symbol to Proc未完待續…","link":"/2014/09/06/old%20posts/2014-09-06-ruby-bits_2-1-blocks-procs/"},{"title":"EDX Linux Foundation Ch 9：User Environment Section 1 Account","text":"Section 1 Account1. Identifying the Current UserwhoTo list the currently logged-on users, type who whoamiTo identify the current user, type whoami who -aGiving who the -a option will give more detailed information. 2. Basics of Users and GroupsLinux uses groups for organizing users. Groups are collections of accounts with certain shared permissions. UID and GIDAll Linux users are assigned a unique user ID (uid), which is just an integer, as well as one or more group ID’s (gid), including a default one which is the same as the user ID. /etc/passwd這個檔案的構造是這樣的：每一行都代表一個帳號，有幾行就代表有幾個帳號在你的系統中！ 不過需要特別留意的是，裡頭很多帳號本來就是系統正常運作所必須要的，我們可以簡稱他為系統帳號， 例如 bin, daemon, adm, nobody 等等，這些帳號請不要隨意的殺掉他 12345ubuntu@ip-172-31-27-94:~$ head -n 4 /etc/passwdroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologin 帳號名稱：就是帳號啦！用來對應 UID 的。例如 root 的 UID 對應就是 0 (第三欄位)； 密碼：早期 Unix 系統的密碼就是放在這欄位上！但是因為這個檔案的特性是所有的程序都能夠讀取，這樣一來很容易造成密碼資料被竊取， 因此後來就將這個欄位的密碼資料給他改放到 /etc/shadow 中了。所以這裡你會看到一個『 x 』！ UID： GID這個與 /etc/group 有關！其實 /etc/group 的觀念與 /etc/passwd 差不多，只是他是用來規範群組名稱與 GID 的對應而已！ 使用者資訊說明欄這個欄位基本上並沒有什麼重要用途，只是用來解釋這個帳號的意義而已 家目錄root 的家目錄在 /root預設的使用者家目錄在 /home/yourIDname Shell當使用者登入系統後就會取得一個 Shell 來與系統的核心溝通以進行使用者的操作任務。那為何預設 shell 會使用 bash 呢？就是在這個欄位指定的囉！ 這裡比較需要注意的是，有一個 shell 可以用來替代成讓帳號無法取得 shell 環境的登入動作！那就是 /sbin/nologin 這個東西！這也可以用來製作純 pop 郵件帳號者的資料呢！ /etc/shadow早期的密碼也有加密過，但卻放置到 /etc/passwd 的第二個欄位上！這樣一來很容易被有心人士所竊取的， 加密過的密碼也能夠透過暴力破解法去 try and error (試誤) 找出來！因為這樣的關係，所以後來發展出將密碼移動到 /etc/shadow 這個檔案分隔開來的技術， 而且還加入很多的密碼限制參數在 /etc/shadow 裡頭呢 詳細內容請看：鳥哥：/etc/shadow 檔案結構 /etc/groupControl of group membership is administered through the /etc/group file, which shows a list of groups and their members. 12345ubuntu@ip-172-31-27-94:~$ head -n 4 /etc/grouproot:x:0:daemon:x:1:bin:x:2:sys:x:3: 這個檔案每一行代表一個群組，也是以冒號『:』作為欄位的分隔符號，共分為四欄，每一欄位的意義是： 群組名稱：就是群組名稱啦！ 群組密碼：通常不需要設定，這個設定通常是給『群組管理員』使用的，目前很少有這個機會設定群組管理員啦！ 同樣的，密碼已經移動到 /etc/gshadow 去，因此這個欄位只會存在一個『x』而已； GID：就是群組的 ID 啊。我們 /etc/passwd 第四個欄位使用的 GID 對應的群組名，就是由這裡對應出來的！ 此群組支援的帳號名稱：我們知道一個帳號可以加入多個群組，那某個帳號想要加入此群組時，將該帳號填入這個欄位即可。 舉例來說，如果我想要讓 dmtsai 也加入 root 這個群組，那麼在第一行的最後面加上『,dmtsai』，注意不要有空格， 使成為『 root:x:0:root,dmtsai 』就可以囉～ 3. Adding and Removing UsersOnly the root user can add and remove users and groups. useraddIn the simplest form an account for the new user turkey would be done with: 1$ sudo useradd turkey which by default sets the home directory to /home/turkey, populates it with some basic files (copied from /etc/skel) and adds a line to /etc/passwd such as: 1turkey:x:502:502::/home/turkey:/bin/bash and sets the default shell to /bin/bash userdel and userdel -rRemoving a user account is as easy as typing userdel turkey However, this will leave the /home/turkey directory intact. This might be useful if it is a temporary inactivation. To remove the home directory while removing the account one needs to use the -r option to userdel. idTyping id with no argument gives information about the current user, as in: 12$ iduid=500(george) gid=500(george) groups=106(fuse),500(george) If given the name of another user as an argument, id will report information about that other user. usermod所謂這『人有失手，馬有亂蹄』，您說是吧？所以囉，當然有的時候會『不小心』在 useradd 的時候加入了錯誤的設定資料。或者是，在使用 useradd 後，發現某些地方還可以進行細部修改。 此時，當然我們可以直接到 /etc/passwd 或 /etc/shadow 去修改相對應欄位的資料， 不過，Linux 也有提供相關的指令讓大家來進行帳號相關資料的微調呢～那就是 usermod 囉～ 鳥哥：usermod 4. Adding and Removing GroupsgroupaddAdding a new group is done with groupadd: 1$ sudo /usr/sbin/groupadd anewgroup groupdelThe group can be removed with 1$ sudo /usr/sbin/groupdel anewgroup groups輸入groups turkey查看turkey的group 12$groups turkeyturkey : turkey 得到turkey : turkey，代表預設的群組是自己。 使用usermod修改群組Adding a user to an already existing group is done with usermod. 123$ sudo /usr/sbin/usermod -G anewgroup turkey$ groups turkeyturkey: turkey anewgroup -g ：後面接初始群組，修改 /etc/passwd 的第四個欄位，亦即是 GID 的欄位！-G ：後面接次要群組，修改這個使用者能夠支援的群組，修改的是 /etc/group 囉～ 5. The root AccountThe root account is very powerful and has full access to the system. Other operating systems often call this the administrator account; in Linux it is often called the superuser account. suswitch or substitute user sudosudo 可以讓你以其他用戶的身份執行指令 (通常是使用 root 的身份來執行指令) /etc/sudoerssudo configuration files are stored in the /etc/sudoers file and in the /etc/sudoers.d/ directory. By default, the sudoers.d directory is empty. 6.Startup Files/etcIn Linux, the command shell program (generally bash) uses one or more startup files to configure the environment. Files in the /etc directory define global settings for all users while Initialization files in the user’s home directory can include and/or override the global settings. /etc/profile(login shell reading it)When you first login to Linux, /etc/profile is read and evaluated, after which the following files are searched (if they exist) in the listed order: ~/.bash_profile ~/.bash_login ~/.profile The Linux login shell evaluates whatever startup file that it comes across first and ignores the rest. This means that if it finds ~/.bash_profile, it ignores ~/.bash_login and ~/.profile. Different distributions may use different startup files. ~/.bashrc (non-login shell reading it)However, every time you create a new shell, or terminal window, etc., you do not perform a full system login; only the ~/.bashrc file is read and evaluated. ~/.bash_history還記得我們在歷史命令提到過這個檔案吧？預設的情況下， 我們的歷史命令就記錄在這裡啊！而這個檔案能夠記錄幾筆資料，則與 HISTFILESIZE 這個變數有關啊。每次登入 bash 後，bash 會先讀取這個檔案，將所有的歷史指令讀入記憶體， 因此，當我們登入 bash 後就可以查知上次使用過哪些指令囉。至於更多的歷史指令， 請自行回去參考喔！ login shell 和 no-login shell“login shell” 代表用戶登入, 比如使用“su -“ 命令, 或者用ssh 連接到某一個服務器上, 都會使用該用戶默認shell 啟動login shell 模式.該模式下的shell會去自動執行/etc/profile和/.profile文件,但不會執行任何的bashrc文件,所以一般再/etc/profile或者/.profile裡我們會手動去source bashrc文件.而no-login shell 的情況是我們在終端下直接輸入bash 或者bash -c “CMD” 來啟動的shell.該模式下是不會自動去運行任何的profile 文件.","link":"/2014/09/13/old%20posts/2014-09-13-edx-linux-foundation-ch-9/"},{"title":"EDX Linux Foundation Ch 9：User Environment Section 3 and 4","text":"Section 3:Recalling Previous CommandsUp and Down you can recall previously used commands simply by using the Up and Down cursor keys. histroy To view the list of previously executed commands, you can just type history at the command line. ~/.bash_history.The list of commands is displayed with the most recent command appearing last in the list. This information is stored in ~/.bash_history. Using History Environment Variables$HISTFILE stores the location of the history file.$HISTFILESIZE stores the maximum number of lines in the history file.$HISTSIZE stores the maximum number of lines in the history file for the current session. 1234567ubuntu@ip-172-31-27-94:~$ echo $HISTFILE/home/ubuntu/.bash_historyubuntu@ip-172-31-27-94:~$ echo $HISTFILESIZE2000ubuntu@ip-172-31-27-94:~$ echo $HISTSIZE1000ubuntu@ip-172-31-27-94:~$ Finding and Using Previous CommandsUp/Down arrow keyBrowse through the list of commands previously executed !! (Pronounced as bang-bang)Execute the previous command CTRL-RSearch previously used commands Executing Previous Commands Section 4:Command AliasesCreating AliasesYou can create customized commands or modify the behavior of already existing ones by creating aliases. Most often these aliases are placed in your ~/.bashrc file so they are available to any command shells you create. alias列出所有的縮寫(alias) alias 縮寫＝’指令’設定新的縮寫 範例：","link":"/2014/09/14/old%20posts/2014-09-14-edx-linux-foundation-ch-9-user-environment-section-3-recalling-previous-commands/"},{"title":"EDX Linux Foundation Ch 9：User Environment Section 2 Environment Variables","text":"##Environment VariablesEnvironment variables are simply named quantities that have specific values and are understood by the command shell, such as bash. Some of these are pre-set (built-in) by the system, and others are set by the user either at the command line or within startup and other scripts. 環境變數可以幫我們達到很多功能～包括家目錄的變換啊、提示字元的顯示啊、執行檔搜尋的路徑啊等等的， 還有很多很多啦！那麼，既然環境變數有那麼多的功能，問一下，目前我的 shell 環境中， 有多少預設的環境變數啊？我們可以利用兩個指令來查閱，分別是 env 與 export 呢！ ###env和exportenv是environment的簡寫，可以列出來所有的環境變數。 123456$ envSSH_AGENT_PID=1892GPG_AGENT_INFO=/run/user/me/keyring-Ilf3vt/gpg:0:1TERM=xtermSHELL=/bin/bash... 如果使用 export 也會是一樣的內容～ 只不過， export 還有其他額外的功能就是了。（下面會講到） 12345$ exportdeclare -x COLORTERM=gnome-terminaldeclare -x COMPIZ_BIN_PATH=/usr/bin /declare -x COMPIZ_CONFIG_PROFILE=ubuntu... ###set用 set 觀察所有變數 (含環境變數與自訂變數) 12345$ setBASH=/bin/bashBASHOPTS=checkwinsize:cmdhist:expand_aliases:extglob:extquote:force_fignoreBASH_ALIASES=()... ###環境變數與自定變數By default, variables created within a script are only available to the current shell; child processes (sub-shells) will not have access to values that have been set or modified. Allowing child processes to see the values, requires use of the export command. 環境變數與自訂變數這兩者之間有啥差異呢？其實這兩者的差異在於『 該變數是否會被子程序所繼續引用』子程序僅會繼承父程序的環境變數， 子程序不會繼承父程序的自訂變數啦！所以你在原本 bash 的自訂變數在進入了子程序後就會消失不見， 一直到你離開子程序並回到原本的父程序後，這個變數才會又出現！ ##Setting Environment Variables ###Show the value of a specific variable 1echo $SHELL ###Export a new variable valueexport除了可以查看以外還可以用來設定環境變數 1export VARIABLE=value (or VARIABLE=value; export VARIABLE) ###Add a variable permanently 1Edit ~/.bashrc and add the line export VARIABLE=value Type source ~/.bashrc or just . ~/.bashrc (dot ~/.bashrc); or just start a new shell by typing bash ##The HOME VariableHOME is an environment variable that represents the home (or login) directory of the user.輸入echo $HOME會顯示家目錄的路徑輸入cd後面不加目錄名稱會切換到家目錄 ##The PATH VariablePATH is an ordered list of directories (the path) which is scanned when a command is given to find the appropriate program or script to run. Each directory in the path is separated by colons (:). A null (empty) directory name (or ./) indicates the current directory at any given time. ###show $Pathecho $PATH ###To prefix a private bin directory to your path: 123$ export PATH=$HOME/bin:$PATH$ echo $PATH/home/me/bin:/usr/local/bin:/usr/bin:/bin/usr 延伸閱讀：鳥哥：$Path ##The PS1 VariablePrompt Statement (PS) is used to customize your prompt string in your terminal windows to display the information you want.用來改變終端機外觀的變數。 ##The SHELL VariableThe environment variable SHELL points to the user’s default command shell and contains the full pathname to the shell: 12$ echo $SHELL/bin/bash","link":"/2014/09/14/old%20posts/2014-09-14-edx-linux-foundation-ch-9-environment-variable/"},{"title":"EDX Linux Foundation Ch 9：User Environment Section 5 File Permissions","text":"File Ownership 0.File Permission Modes rwx: rwx: rwx u: g: o rwx Files have three kinds of permissions: read (r), write (w), execute (x). These are generally represented as in rwx. ugo u:user/owner g:group 0:others 1.chmod12345$ ls -l a_file-rw-rw-r-- 1 coop coop 1601 Mar 9 15:04 a_file$ chmod uo+x,g-w a_file$ ls -l a_file-rwxr--r-x 1 coop coop 1601 Mar 9 15:04 a_file This kind of syntax can be difficult to type and rememberso one often uses a shorthand which lets you set all the permissions in one step. 4 if read permission is desired.2 if write permission is desired.1 if execute permission is desired.Thus 7 means read/write/execute, 6 means read/write, and 5 means read/execute. When you apply this to the chmod command you have to give three digits for each degree of freedom, such as in 123$ chmod 755 a_file$ ls -l a_file-rwxr-xr-x 1 coop coop 1601 Mar 9 15:04 a_file 2.chown有三個檔案file-1, file-2, temp 12345$ ls -ltotal 4-rw-rw-r--. 1 bob bob 0 Mar 16 19:04 file-1-rw-rw-r--. 1 bob bob 0 Mar 16 19:04 file-2drwxrwxr-x. 2 bob bob 4096 Mar 16 19:04 temp 對file-1下chown改變檔案擁有者為root 12$ sudo chown root file-1[sudo] password for bob: 下ls -a看檔案完整的訊息，發現檔案擁有者已經改變成root。 12345$ ls -ltotal 4-rw-rw-r--. 1 root bob 0 Mar 16 19:04 file-1-rw-rw-r--. 1 bob bob 0 Mar 16 19:04 file-2drwxrwxr-x. 2 bob bob 4096 Mar 16 19:04 temp 3.chgrp續上面的例子：這次對file-2下chgrp改變檔案的群組。 123456$ sudo chgrp bin file-2$ ls -ltotal 4-rw-rw-r--. 1 root bob 0 Mar 16 19:04 file-1-rw-rw-r--. 1 bob bin 0 Mar 16 19:04 file-2drwxrwxr-x. 2 bob bob 4096 Mar 16 19:04 temp","link":"/2014/09/14/old%20posts/2014-09-14-edx-linux-foundation-ch-9-user-environment-section-5-file-permissions/"},{"title":"EDX Linux Foundation Ch10：Text Editor","text":"本週比較輕鬆，介紹的是Text Editor，但是我卻從中得到很多收穫。課程中介紹了Vim和Emacs，話說這是我第一次聽到Emacs這個編輯器，但他卻是原生的linux編輯器。而且還有不少的愛用者，開發效率也不輸Vim！( 以下內容大部分由Carl大哥所分享，加上我的心得所寫而成。 ) VimVIM Adventureshttp://vim-adventures.com/初學Vim的好遊戲，強迫你要用Vim指令來解謎破關XD Vim 正體中文社團https://www.facebook.com/groups/vim.tw/有很多的Vim資源、套件。 Best Vim Tipshttp://vim.wikia.com/wiki/Best_Vim_Tips Vimgeniushttp://www.vimgenius.com/一個畫面精美的教學，不過考法似乎是用背的XD Iteractive Vimhttp://www.openvim.com/sandbox.html右邊有指令邊看邊試還不錯用，但並非全部vim的指令都支援，只有表上的可以使用。 vim使用技巧ZZ = :wq 無法寫入的狀況關鍵字：vim sudo github vundle :set paste貼進來就不會縮排變成梯形 ultra vimhttps://github.com/bcbcarl/ultra_vim Emacs特色：功能強大，可取代 IDE Emacs tutorial: C-h tp.16 commands for emacs Awesome Emacshttps://github.com/emacs-tw/awesome-emacs Emacs 台灣https://twitter.com/EmacsTW Emacs 中文https://plus.google.com/communities/115469134289640648214 Dot-Emacshttp://www.emacswiki.org/emacs/CategoryDotEmacshttp://www.dotemacs.de Emacs Starter Kithttp://eschulte.github.io/emacs-starter-kit/ Configuring Emacs as a Python IDEhttp://blog.csdn.net/mikelearnscode/article/details/23022277可與 PyCharm 一拼，作者試了 Sublime 依然選了 Emacs，建議來看看。 emac starter kit不錯的套件包","link":"/2014/09/17/old%20posts/2014-09-17-edx-linux-foundation-ch10text-editor/"},{"title":"Vim 學習筆記","text":"常用指令筆記 第一課：使用hjkl控制上下左右 第二課：使用w e b跳躍單字 第三課：使用dd剪下一行，並使用p或P貼上。 第三課：移動跳至某一行 :第幾行跳至段落{或}跳至句首$跳至句尾0跳至某行： 第四課：畫面捲動page down:page up: Vim資源整理VIM AdventuresVim 正體中文社團Best Vim TipsVimgenius一個畫面精美的教學，不過考法似乎是用背的XDIteractive Vim右邊有指令邊看邊試還不錯用，但並非全部vim的指令都支援，只有表上的可以使用。","link":"/2014/09/17/old%20posts/2014-09-17-vim-learning-notes/"},{"title":"Agile Meetup 2014 9月：喚醒者的工具箱","text":"Part1:當一個好的教練！如何讓一個二十幾年沒運動的阿宅學會打球一個網球教練如何讓一個二十幾年沒出門運動的宅女學會打球，答案是沒有太多的技巧，沒有標準的動作，當場示範怎麼打網球，然後把球丟給那個宅宅，阿宅揮空幾次以後，發現真的打的到了！證明學習的最好方法不是看書，而是用本能來適應。 Try error 嘗試錯誤人類的腦子分為兩個部分，其中腦幹會想保護自己。 先讓人專注之後，保護自己的機制就會降低一旦降低了自己的恐懼感，便增加awareness。learning the hard way自己跌倒才會學到 Part2:營銷訊息爆炸的時代如何讓別人知道自己的產品，關鍵是這事情是否令人所印象深刻（markable），製造一些話題，會有不錯的效果（紫牛效應）。 一個例子-雕爺牛楠找美食家來試吃，每個月淘汰兩道菜，增加兩道菜，製造話題1.理解鐵桿粉絲真正想要需要什麼2.墨守成歸是風險最大的作法3.在邊緣求生存才是正確的作法 敏捷轉型其實是個營銷 Part3:不同的人思考的方式第一種人early adopter特色：喜歡嘗鮮 原則一：specific 具體的轉型的時候行為是很重要的，關注具體的行為，並鼓勵之變革的行為需要鼓勵 the curse of knowledge 認知心理學 在daily scrum提出具體的問題讓人喝幾口水後&gt; 抓住具體的機會，讓人做反思 1.抓住機會&gt; 你這會是為我開的？2.有人不來開會團隊自己的問題，不該由scrum master來叫。解答：基於事實，剛剛看到有人在看窗外。3.誰來畫板趕緊去網路上找一個最爛的板，別人受不了就會去畫了，畫了第一次以後就是他畫了。 好的教練對好的team才有作用，對爛的team還是沒救（指大家想不想為了進步而努力）。 第二種人 early majority願意判斷，很實際，但害怕失敗。這些人怎麼搞？1.穿他的鞋跟他一起做事情 ，讓他發現一些新的方式讓人自己來找你做事情2.做出的事情可以分享network-利用網絡傳小消息 第三種人 late majority 後知後覺要用傳染，社會壓力的方式例子：do me a favor 叫下屬看某一頁，引起他的興趣。 第四種人i’m working the change 演講投影片連結","link":"/2014/09/18/old%20posts/2014-09-18-agile-meetup-2014-in-september/"},{"title":"Agile Meetup 2014 9月：More with LeSS","text":"這是第三次參加agile meetup，真的很感謝scrum community舉辦這麼這麼有優質又免費的活動。今天的主題LeSS在講的是Large-Scale Scrum，也就是大型的scrum組織如何協同合作。 每一個小team都要正確的執行scrum，否則team的數量一多更容易崩壞。 今天提到的scrum原則 每個團隊成員都有責任管理自己 scaling itegration每個人都不斷的提交(commit)，一天提交2~5次是不夠的，最好可以每小時都commit。 在backlog中刪除不必要的功能 resource pool是不可行的方式resource pool指的是誰有空誰就被抓去組成一個團隊來處理新的專案，因為每次成立新的團隊就要一段磨和期，無形間浪費了很多的產能。一個scrum team組成三年以上都有可能再度成長。 feature team與component team由feature來組隊代替由componet team，因為這樣的開發方式可以降低cycle time，也就是從收到ticket到完成的時間。因為componet team是把所有功能做好之後再組合起來，這樣開發cycle time至少都需要6週以上。而如果針對feature來開發，則1周內就可以看到成果，符合agile精神 community of practice每個feature team派出代表，了解其他的team所寫的componentd 單元測試的重要性單元測試可以讓別人知道如何使用你的程式，並且可以讓別人知道你的程式有什麼功能。","link":"/2014/09/18/old%20posts/2014-09-18-agile-meetup-2014-september-more-with-less-to-participate-in-experiences/"},{"title":"EDX Linux Foundation Ch11：Local Security Principle section 4~5","text":"Section 4: Working with passwordsHow Passwords are Stored On modern systems, passwords are actually stored in an encrypted format in a secondary file named /etc/shadow. Only those with root access can modify/read this file. Password EncryptionMost Linux distributions rely on a modern password encryption algorithm called SHA-512 (Secure Hashing Algorithm 512 bits), developed by the U.S. National Security Agency (NSA) to encrypt passwords. 可以玩玩看下面這個指令，加密test這個字。 1echo -n test | sha512sum Good Password PracticesIT professionals follow several good practices for securing the data and the password of every user. 1.Password agingPassword aging is a method to ensure that users get prompts that remind them to create a new password after a specific period. This can ensure that passwords, if cracked, will only be usable for a limited amount of time. This feature is implemented using chage, which configures the password expiry information for a user. 2.PAMAnother method is to force users to set strong passwords using Pluggable Authentication Modules (PAM). PAM can be configured to automatically verify that a password created or modified using the passwd utility is sufficiently strong. PAM configuration is implemented using a library called pam_cracklib.so, which can also be replaced by pam_passwdqc.so for more options. 3.John the ripperOne can also install password cracking programs, such as John The Ripper, to secure the password file and detect weak password entries. It is recommended that written authorization be obtained before installing such tools on any system that you do not own. Seciton 5: Securing the Boot Process and HardwareRequiring Boot Loader PasswordsYou can secure the boot process with a secure password to prevent someone from bypassing the user authentication step. GRUB version 1（older version）you can invoke grub-md5-crypt which will prompt you for a password and then encrypt as shown on the adjoining screen. You then must edit /boot/grub/grub.conf by adding the following line below the timeout entry: 1password --md5 $1$Wnvo.1$qz781HRVG4jUnJXmdSCZ30 You can also force passwords for only certain boot choices rather than all.舊的作法是直接修改/boot/grub/grub.conf GRUB version 2（older version）For the now more common GRUB version 2 things are more complicated, and you have more flexibility and can do things like use user-specific passwords, which can be their normal login password. Also you never edit the configuration file, /boot/grub/grub.cfg, directly, rather you edit system configuration files in /etc/grub.d and then run update-grub. One explanation of this can be found at https://help.ubuntu.com/community/Grub2/Passwords. 新的作法不直接修改/boot/grub/grub.cfg，而是先修改/etc/grub.d然後跑update-grub。 Hardware VulnerabilityWhen hardware is physically accessible, security can be compromised by: Key logging: Recording the real time activity of a computer user including the keys they press. The captured data can either be stored locally or transmitted to remote machines Network sniffing: Capturing and viewing the network packet level data on your network Booting with a live or rescue disk Remounting and modifying disk content The guidelines of security are: Lock down workstations and servers Protect your network links such that it cannot be accessed by people you do not trust Protect your keyboards where passwords are entered to ensure the keyboards cannot be tampered with Ensure a password protects the BIOS in such a way that the system cannot be booted with a live or rescue DVD or USB key","link":"/2014/09/22/old%20posts/2014-09-22-edx-linux-foundation-ch11-local-security-principle-section-45/"},{"title":"EDX Linux Foundation Ch11：Local Security Principle section 1~3","text":"Section 1 Understanding Linux Security使用者權限的管理在個人電腦上可以放輕鬆使用，但如果是多人共用的電腦，就必須限制的嚴格，最好只給用戶他所可以用的權限就好，不要多給，本章將會以最嚴格的標準來說明如何管理使用者的權限以增加安全性。 User AccountsFor each user, the following seven fields are maintained in the /etc/passwd file: Types of AccountsBy default, Linux distinguishes between several account types in order to isolate processes and workloads. Linux has four types of accounts: root System Normal Network The last utility, which shows the last time each user logged into the system, can be used to help identify potentially inactive accounts which are candidates for system removal. Understanding the root Account root is the most privileged account on a Linux/UNIX system. This account has the ability to carry out all facets of system administration, including adding accounts, changing user passwords, examining log files, installing software, etc. Utmost care must be taken when using this account. It has no security restrictions imposed upon it. section 2: Understanding the usage of rootOperations that Require root Privileges root privileges are required to perform operations such as: Creating, removing and managing user accounts. Managing software packages. Removing or modifying system files. Restarting system services. 一般用戶也可以安裝或是更新軟體，但是只有root帳號可以讓軟體做一些跟系統有關的事情。 Creating a New User in Linuxuseradd passwd Operations That Do Not Require root PrivilegesSUID（Set owner User ID upon execution）SUID (similar to the Windows “run as” feature)is a special kind of file permission given to a file. SUID provides temporary permissions to a user to run a program with the permissions of the file owner (which may be root) instead of the permissions held by the user. 當 s 這個標誌出現在檔案擁有者的 x 權限上時，例如/usr/bin/passwd 這個檔案的權限狀態：『-rwsr-xr-x』，此時就被稱為 Set UID，簡稱為 SUID 的特殊權限。明明 /etc/shadow 就不能讓 vbird 這個一般帳戶去存取的，為什麼還能夠修改這個檔案內的密碼呢？ 這就是 SUID 的功能! vbird 對於 /usr/bin/passwd 這個程式來說是具有 x 權限的，表示 vbird 能執行 passwd； passwd 的擁有者是 root 這個帳號； vbird 執行 passwd 的過程中，會『暫時』獲得 root 的權限； /etc/shadow 就可以被 vbird 所執行的 passwd 所修改。 另外，SUID 僅可用在binary program 上， 不能夠用在 shell script 上面！這是因為 shell script 只是將很多的 binary 執行檔叫進來執行而已！ Section 3:Comparing sudo and suUsers’ authorization for using sudo is based on configuration information stored in the /etc/sudoers file and in the /etc/sudoers.d directory. The sudoers FileWhenever sudo is invoked, a trigger will look at /etc/sudoers and the files in /etc/sudoers.d to determine if the user has the right to use sudo and what the scope of their privilege is. Unknown user requests and requests to do operations not allowed to the user. Edit sudoers You can edit the sudoers file by using visudo, which ensures that only one person is editing the file at a time. The basic structure of an entry is: 1who where = (as_whom) what /etc/sudoers.dMost Linux distributions now prefer you add a file in the directory /etc/sudoers.d with a name the same as the user. This file contains the individual user’s sudo configuration, and one should leave the master configuration file untouched except for changes that affect all users. Command LoggingBy default, sudo commands and any failures are logged in /var/log/auth.log under the Debian distribution family, and in /var/log/messages or /var/log/secure on other systems.This is an important safeguard to allow for tracking and accountability of sudo use. A typical entry of the message contains: Running a command such as sudo whoami results in a log file entry such as:Dec 8 14:20:47 server1 sudo: op : TTY=pts/6 PWD=/var/log USER=root COMMAND=/usr/bin/whoami Process IsolationLinux is considered to be more secure than many other operating systems because processes are naturally isolated from each other. One process normally cannot access the resources of another process, even when that process is running with the same user privileges. Hardware Device Accessdevice special file (often called a device node) under the /dev directory that corresponds to the device being accessed./dev/sd*Hard disks, for example, are represented as /dev/sd*. While a root user can read and write to the disk in a raw fashion (for example, by doing something like: 1$ echo hello world &gt; /dev/sda1 寫入divice node很容易會毀掉整個檔案系統，所以絕對不要直接存取device node。 Keeping CurrentThe best practice is to take advantage of your Linux distribution’s mechanism for automatic updates and never postpone them. It is extremely rare that such an update will cause new problems.","link":"/2014/09/22/old%20posts/2014-09-22-edx-linux-foundation-ch11-understanding-linux-security/"},{"title":"Personal Kanban：能夠用在自己身上的敏捷方法 學習筆記","text":"如何將敏捷方法用在個人身上?符合敏捷精神 Agile因為Scrum需要角色的區分，所以對個人來說，並不需要使用Scrum，只要符合敏捷精神即可。 「個人看板系統」Personal Kanban偶然發現這個真的是太酷了，一直在尋找可以管理自己的敏捷方法。在今天終於找到了答案。Personal Kanban可以讓自己看見自己的問題。看到自己問題之後便能夠做出調整，持續改善，增加產能。這也是敏捷方法的精神，透過敏捷方法改善單位時間的產能，避免低效率的加班，如此一來有更多的時間休息、散心，有更多的時間學習新的知識，形成正向循環。 實行Personal Kanban三步驟 visualize(視覺化)：把你手頭的工作用流程畫出來 Limit Work-in-progress（限制WIP)：依據利特爾調整進行中工作的數量。 Manage flow（管理工作流)：透過反省、分析最佳化你的工作，這是最有價值的部分。 步驟1: 視覺化把手頭上的工作畫成你的第一個看板。因為看的到所以知道 我漏了什麼？ 每日排序工作行程，變得井然有序。 改善工作流程。 知道自己該做些什麼 步驟2：限制WIP數量來提高THBuffering 緩衝區法運用增減 Buffer 大小的控制方式，正是 Kanban Method 的威力所在，請依據利特爾法則 Little’s law ，來追求最大的產出。 利特爾法則Work in Process (進行中的工作) 同時開工但是卻尚未完工的工作項目數量Throughput (產能) 團隊在單位時間內的產出。Lead time (開發週期時間) 團隊完成一個項目所花費的平均時間。 如何來限制半成品 WIP數與獲取最大的產能TH值，便成了Kanban方法不斷從看板上做調整以追求開發瓶頸的工作了。設定限制工作項WIP數目可以讓我們更專注，更清楚眼前應該認真完成的目標。 步驟3：管理工作流：個人看板讓你掌握時間《做自己》個人看板不只是拿來提升個人工作效能, 它更能拿來管理自己生活與工作流程，讓你知道如何掌握時間《做自己》。 如何改善瓶頸？ 注意自己開始和完成工作的速率 每個工作是否按步就班在自己能夠容忍的範圍之內完成。 超過WIP的狀況嚴重嘛？應該採用寬鬆的方法（加大WIP值）還是緊縮的方法讓現象能夠改善呢？ 等待的時間過程如何改善？ 等待是最沒有產能的工作，即使在個人的看板系統裡頭，你仍然會發現它充滿了人與人之間的合作關係，這正是所謂的人是群體的動物，是不可能離群索居的。那些與其他人相互關聯的工作，往往不僅僅是效能的問題它可能還牽扯到彼此之間的滿意和信任的程度，這些或許才是你真正在意的。因此把你認為重要的工作呈現出來，已經是一個好的開始了。 遭遇到緊急事故；看板方法該如何規劃呢?就在看板下方另外開闢一條渠道來單獨處理它，我們稱之為:新增渠道的處理方法。這正是所謂的多工，對效能而言是很不好的，但事出必有因，再怎麼無奈也得做。而且必須盡快做完 持續改善看板方法是典型的改善工程，它的改進方式強烈的依靠經驗，因此問題成了你最佳的導師，所以成長的過程就變成: 發覺問題 -&gt; 思考如何改善並嘗試改善它 -&gt; 在解決問題後，繼續再來…。因此持續改善便成為了他的座右銘。 心得使用敏捷方法改善個人效率一直是我非常想做的事情，今天偶然間開啟了Kanban的這一扇門，讓我日後學習有了方向。 主要研讀對象：這篇學習筆記是研讀以下文章所作出的筆記，想要深入了解務必讀一讀下列的文章。 運用個人看板做時間管理 用來提升個人效能的「個人看板系統」– Personal Kanban 參考資料： 看板方法介紹（1）：Kanban這個字是什麼意思？ 看板方法介紹（2）：Push 和 Pull 看板方法介紹（3）：Kanban方法的六個實務做法–Visualize與Limit WIP 看板方法介紹（4）：Kanban方法的六個實務做法–Manage Flow 看板方法介紹（5）：Kanban方法的六個實務做法—Make Policies Explicit 看板方法介紹（6）：Kanban方法的六個實務做法—Implement Feedback Loops 看板方法介紹（7）：Kanban方法的六個實務做法—Improve Collaboratively, Evolve Experimentally","link":"/2014/09/29/old%20posts/2014-09-29-personal-kanban/"},{"title":"EDX Linux Foundation Ch12：Network","text":"IP and packageIP(Internet Protocol) address is essential for routing packets of information through the network.These packets contain data buffers together with headers which contain information about where the packet is going to and coming from, and where it fits in the sequence of packets that constitute the stream. Decoding IPv4 AddressesA 32-bit IPv4 address is divided into four 8-bit sections called octets. IP address are divided into five classes Classes A, B, and C are classified into two parts: Network addresses(Net ID) and Host address (Host ID). The Net ID is used to identify the network, while the Host ID is used to identify a host in the network.Class D is used for special multicast applications (information is broadcast to multiple computers simultaneously)Class E is reserved for future use. IP Address AllocationTypically, a range of IP addresses are requested from your Internet Service Provider(ISP) by your organization’s network administrator You can assign IP addresses to computers over a network manually or dynamically. When you assign IP addresses manually, you add static (never changing) addresses to the network. When you assign IP addresses dynamically (they can change every time you reboot or even more often), the Dynamic Host Configuration Protocol (DHCP) is used to assign IP addresses. Manually Allocating an IP Address??ipcalc Name ResolutionName Resolution is used to convert numerical IP address values into a human-readable format known as the hostname.text For example, 140.211.169.4 is the numerical IP address that refers to the linuxfoundation.org hostname. Hostnames are easier to remember. Using Domain Name System (DNS) and Name Resolution ToolsDomain Name System (DNS) translates Internet domain and host names to IP addresses.私有IP對應的主機名稱cat /etc/hosts顯示DNS IPcat /etc/resolv.conf 1host linuxfoundation.org 1nslookup linuxfoundation.org 1dig linuxfoundation.org look up domain name information Network InterfacesNetwork interfaces are a connection channel between a device and a network. Physically, network interfaces can proceed through a network interface card (NIC) or can be more abstractly implemented as software. A list of currently active network interfaces is reported by the ifconfig utility which you may have to run as the superuser. Network Configuration Files /etc/init.d/network start ??? Network Configuration CommandsTo view the IP address:$ /sbin/ip addr show To view the routing information:$ /sbin/ip route show ip is a very powerful program that can do many things. Older (and more specific) utilities such as ifconfig and route are often used to accomplish similar tasks. A look at the relevant man pages can tell you much more about these utilities. pingping is used to check whether or not a machine attached to the network can receive and send data; i.e., it confirms that the remote host is online and is responding.To check the status of the remote host, at the command prompt, type ping &lt;hostname&gt;. routeServers maintain routing tables containing the addresses of each node in the network.route is used to view or change the IP routing table. traceroute？？？traceroute is used to inspect the route which the data packet takes to reach the destination host which makes it quite useful for troubleshooting network delays and errors. Check the route which the data packet takes to reach the destination host (google.com). Type traceroute &lt;domain&gt;. More Networking ToolsNow, let’s learn about some additional networking tools. Networking tools are very useful for monitoring and debugging network problems, such as network connectivity and network traffic. Using More Networking Toolssudo ethtool eth0netstat -rsudo nmap -sP 10.0.2.15/24 先看自己啟動哪些serviceservice statslsof socket_name strace ls可以知道command怎麼run的 netstat grep某個port看某個server的port 其他指令forkoperating clifd: 識別馬lsof 可以茶城市到底開了多少個fd","link":"/2014/09/30/old%20posts/2014-09-30-edx-linux-foundation-ch12-network/"},{"title":"Techdays Videos 釋出","text":"門票要價15000的techday影片釋出了蒐集了幾個比較有興趣的影片，分別是: 保哥的 使用 TypeScript 開發大型應用程式 幾個敏捷開發的經驗分享: Kanban 看板及 Lean 精實的技巧在大型軟體開發專案 現代化網站開發技巧應用實例 Modern Web Development Practices 從版本管控到持續整合 (Continuous Integration, CI) 的實踐 其他就請大家自己挖寶囉 techday videos","link":"/2014/10/01/old%20posts/2014-10-01-techday-videos/"},{"title":"EDX Linux Foundation 補充筆記","text":"七層筆記＋tcp/ip筆記 ip mac socket 基本知識乙太網路了解封包內容 名詞釐清IEEE國際上專業制定單位的組織LAN (LOCAL AREA NETWORK)區域網路WAN (WIDE AREA NETWORK)廣域網路NIC(NETWORK INTERFACE CARD)NI 1. OSI (Open System Interconnection) 七層協定layer 1 phisical layerlayer 2 data link layer偏軟體的子層 MAC(media access control)MAC 是網路媒體所能處理的主要資料包裹，這也是最終被實體層編碼成位元串的資料。 MAC frame偏硬體的子層LLC(logical link control)主要在多工處理來自上層的封包資料 (packet) 並轉成 MAC 的格式 layer 3 Network layerIProutelayer 4 transport layerlayer 5 session layerlayer 6 presentation layerlayer 7 application layer2. TCP/IP是什麼？如何運作？2.TCP/IP 如何運作那 TCP/IP 是如何運作的呢？我們就拿妳常常連上的 Yahoo 入口網站來做個說明好了，整個連線的狀態可以這樣看： 應用程式階段：妳打開瀏覽器，在瀏覽器上面輸入網址列，按下 [Enter]。此時網址列與相關資料會被瀏覽器包成一個資料， 並向下傳給 TCP/IP 的應用層； 應用層：由應用層提供的 HTTP 通訊協定，將來自瀏覽器的資料包起來，並給予一個應用層表頭，再向傳送層丟去； 傳送層：由於 HTTP 為可靠連線，因此將該資料丟入 TCP 封包內，並給予一個 TCP 封包的表頭，向網路層丟去； 網路層：將 TCP 包裹包進 IP 封包內，再給予一個 IP 表頭 (主要就是來源與目標的 IP 囉)，向鏈結層丟去； 鏈結層：如果使用乙太網路時，此時 IP 會依據 CSMA/CD 的標準，包裹到 MAC 訊框中，並給予 MAC 表頭，再轉成位元串後， 利用傳輸媒體傳送到遠端主機上。等到 Yahoo 收到你的包裹後，在依據相反方向拆解開來，然後交給對應的層級進行分析，最後就讓 Yahoo 的 WWW 伺服器軟體得到你所想要的資料，該伺服器軟體再根據你的要求，取得正確的資料後，又依循上述的流程，一層一層的包裝起來， 最後傳送到你的手上！就是這樣囉！ MACMAC 其實就是我們上面一直講到的訊框 (frame) 囉！ 只是這個訊框上面有兩個很重要的資料，就是目標與來源的網卡卡號，因此我們又簡稱網卡卡號為 MAC 而已。 簡單的說，你可以把MAC想成是一個在網路線上面傳遞的包裹，而這個包裹是整個網路硬體上面傳送資料的最小單位了。 也就是說，網路線可想成是一條『一次僅可通過一個人』的獨木橋， 而 MAC 就是在這個獨木橋上面動的人啦！ 乙太網路乙太網路已經是一項公認的標準介面了，如此一來，大家都可以依據這個標準來設定與開發自己的硬體， 只要硬體符合這個標準，理論上，他就能夠加入乙太網路的世界，所以，購買乙太網路時， 僅需要查看這個乙太網路卡支援哪些標準就能夠知道這個硬體的功能有哪些， 而不必知道這個乙太網路卡是由哪家公司所製造的吶 RJ-45接頭乙太網路的傳輸協定：CSMA/CD每張乙太網路卡出廠時，就會賦予一個獨一無二的卡號，那就是所謂的 MAC (Media Access Control) 啦！ routeIP 的取得方式staticDHCP(Dynamic Host Configuration Protocol)透過撥接取得：向你的 ISP 申請註冊，取得帳號密碼後，直接撥接到 ISP ，你的 ISP 會透過他們自己的設定，讓你的作業系統取得正確的網路參數。 IP 是門牌，TCP 是樓層，真正提供服務的，是在該樓層的那個人 (Protocol)！ ICMP 協定ICMP 的全名是『 Internet Control Message Protocol, 網際網路訊息控制協定 』。 基本上，ICMP 是一個錯誤偵測與回報的機制，最大的功能就是可以確保我們網路的連線狀態與連線的正確性！ ICMP 也是網路層的重要封包之一，不過，這個封包並非獨立存在，而是納入到 IP 的封包中！","link":"/2014/09/30/old%20posts/2014-09-30-edx-linux-foundation-to-add-notes/"},{"title":"Sinatra 初體驗(2) template與layout","text":"第一次使用Sinatra，還滿好玩的。只要輸入gem install sinatra安裝之後在ruby檔中require &quot;sinatra/base&quot;就可以使用了 each_with_index原來要使用each_with_index來取出index，我還在想說沒有i怎麼用＠＠ 123456&lt;% @images.each_with_index do |image, index| %&gt; &lt;h2&gt;&lt;a href=&quot;/images/&lt;%= index %&gt;&quot;&gt;&lt;%= image[:title] %&gt;&lt;/a&gt;&lt;/h2&gt; &lt;p&gt; &lt;img src=&quot;&lt;%= image[:url]%&gt;&quot; alt=&quot;&quot; /&gt; &lt;/p&gt;&lt;% end %&gt; 初次使用haml一樣輸入gem install haml安裝使用方法跟erb的template差不多 12345get &quot;/images/:index&quot; do |index| index = index.to_i @image = IMAGES[index] haml :&quot;images/show&quot;end 比較有趣的地方是路徑前面都要多加個冒號。 view寫成這樣/view/images/show.haml 使用layout 在views底下新增一個layout.erb views/layout.erb 123456789 &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;title&gt;Erb layout&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%= yield %&gt; &lt;/body&gt;&lt;/html&gt; 這是app.rb也就是route 12345678910 get '/images' do @images = IMAGES erb :imagesendget &quot;/images/:index&quot; do |index| index = index.to_i @image = IMAGES[index] haml :&quot;images/show&quot;, layout: trueend 這邊的haml預設的 layout 會找 views/layout.haml 而不是 layout.erb，所以會找不到。這邊 layout: true 其實可以不用設定，預設就會套用了。","link":"/2014/10/03/old%20posts/2014-10-03-try-sinatra-02/"},{"title":"Sinatra 初體驗(1) - Route","text":"First Sinatra App輸入gem install sinatra安裝gem 建立app.rb檔 1234567require &quot;sinatra/base&quot;class App &lt; Sinatra::Base get '/' do &quot;Hello World!!&quot; endend 建立config.ru 123require &quot;./app&quot; # relative file pathrun App #class Name 輸入rackup啟動server，在 http://localhost:9292 即可看到Hello World 使用curl來模仿HTTP Verb - GET1curl -v &quot;http://localhost:9292&quot; RESTful HTTP Post: 1curl -X POST -d &quot;http://localhost:9292&quot; http-post-and-get-using-curl-in-linux curl指令用法 改寫app為post1234567require &quot;sinatra/base&quot;class App &lt; Sinatra::Base post '/' do &quot;Hello World!!&quot; endend 輸入curl -X Post -v -d &quot;&quot; http://localhost:9292這邊分號沒有寫錯，因為就是要傳一個空字串給server。這樣server就會傳回http response HTTP verb 都來一次1234567891011121314151617181920# app.rbrequire &quot;sinatra/base&quot;class App &lt; Sinatra::Base get '/' do &quot;Hello World!!&quot; end post '/' do &quot;Hello World via POST!!&quot; end put '/' do &quot;Hello World via PUT!!&quot; end delete '/' do &quot;Hello World via DELETE!!&quot; endend 輸入curl -X POST -v -d &quot;&quot; http://localhost:9292回應Hello World via POST!!輸入curl -X PUT -v -d &quot;&quot; http://localhost:9292回應Hello World via PUT!!輸入curl -X DELETE -v -d &quot;&quot; http://localhost:9292回應Hello World via DELETE!! 解析完整的POST1234567891011121314151617181920&gt; POST / HTTP/1.1&gt; User-Agent: curl/7.30.0&gt; Host: localhost:9292&gt; Accept: */*&gt; Content-Length: 0&gt; Content-Type: application/x-www-form-urlencoded&gt;&lt; HTTP/1.1 200 OK&lt; Content-Type: text/html;charset=utf-8&lt; Content-Length: 22&lt; X-Xss-Protection: 1; mode=block&lt; X-Content-Type-Options: nosniff&lt; X-Frame-Options: SAMEORIGIN* Server WEBrick/1.3.1 (Ruby/2.0.0/2013-11-22) is not blacklisted&lt; Server: WEBrick/1.3.1 (Ruby/2.0.0/2013-11-22)&lt; Date: Fri, 03 Oct 2014 07:58:10 GMT&lt; Connection: Keep-Alive&lt;* Connection #0 to host localhost left intactHello World via POST!!% 比較重要的欄位有 第一行，說明是使用哪種http動詞 Content-Type: text/html;charset=utf-8 說明是html 最後輸出的就是route相對輸出的內容 接下來123get &quot;/hello/:first_name/:last_name&quot; do |first, last| &quot;hello#{first}#{last}&quot;end 在網址列輸入http://0.0.0.0:9292/hello/steven/huang網頁上就會印出 hellostevenhuang 這樣寫的缺點這樣寫的話有如果網址列輸入http://0.0.0.0:9292/hello/test就會出現 Sinatra doesn’t know this ditty 的錯誤，因為這樣的寫法比較沒有彈性，route並沒有match到網址。 修正選擇性欄位的問題123get &quot;/hello/:first_name/?:last_name?&quot; do |first, last| &quot;hello#{first}#{last}&quot;end 這樣的話 last_name 就變成了選擇性欄位有沒有輸入都會進入這個 route來測試看看：輸入 http://0.0.0.0:9292/hello/steven果然輸出了 hellosteven","link":"/2014/10/03/old%20posts/2014-10-03-try-sinatra-01-route/"},{"title":"jQuery Returm Flight Ch2：Javascript Object &amp; Function","text":"Part 1. javascript Object將改原本的程式重構，所有的function都變成Object的Method，增加可讀性。 這是原本的code 12345678910var confirmation = { init: function() { $('.confirmation').on('click', 'button', function() { $.ajax('confirmation.html', { ... }); }); $('.confirmation').on('click', '.view-boarding-pass', function(event) { ... }); } }; $(document).ready(function() { confirmation.init(); }); 把function全部獨立出來，用this呼叫，增加可讀性。 123456789101112var confirmation = { init: function() { $('.confirmation').on('click', 'button', this.loadConfirmation); $('.confirmation').on('click', '.view-boarding-pass', this.showBoardingPass); }, loadConfirmation: function() { ... } showBoardingPass: function(event) { ... }};$(document).ready(function() { confirmation.init();}); Part2 javascript FunctionObject vs Function這是物件，只允許一個vacation。 1234567var vacation = { init: function() { // init vacation}$(document).ready(function() { vacation.init();}); 這是function，允許多個vacation。 1234567function Vacation(destination) { // init vacation to destination}$(document).ready(function() { var paris = new Vacation('Paris'); var london = new Vacation('London');});","link":"/2014/10/06/old%20posts/2014-10-06-jquery-return-flight-2/"},{"title":"jQuery Return Flight Ch1 ( 2 )：補充筆記","text":"使用.html()插入元素要使用的ajax長這樣，點下#tour之下的button後，如果出現錯誤，就會顯示錯誤訊息。 1234567891011121314$(document).ready(function() { var el = $(&quot;#tour&quot;); el.on(&quot;click&quot;, &quot;button&quot;, function() { $.ajax('/photos.html', { data: {location: el.data('location')}, success: function(response) { $('.photos').html(response).fadeIn(); }, error: function() { $('.photos').html('&lt;li&gt;There was a problem fetching the latest photos. Please try again.&lt;/li&gt;'); } }); });}); 在錯誤發生的時候，在.photo底下插入&lt;li&gt;元素 12error: function() { $('.photos').html('&lt;li&gt;There was a problem fetching the latest photos. Please try again.&lt;/li&gt;'); ajax回傳之後的html 123456789101112&lt;li&gt; &lt;img src=&quot;/assets/photos/paris1.jpg&quot;&gt; &lt;span style=&quot;display: none;&quot;&gt;Arc de Triomphe&lt;/span&gt;&lt;/li&gt;&lt;li&gt; &lt;img src=&quot;/assets/photos/paris2.jpg&quot;&gt; &lt;span style=&quot;display: none;&quot;&gt;The Eiffel Tower&lt;/span&gt;&lt;/li&gt;&lt;li&gt; &lt;img src=&quot;/assets/photos/london.jpg&quot;&gt; &lt;span style=&quot;display: none;&quot;&gt;London&lt;/span&gt;&lt;/li&gt; event delegate錯誤寫法 1$('.confirmation .view-boarding-pass').on('click', function(){ ... }); 正確寫法 1$('.confirmation').on('click', '.view-boarding-pass', function(){ ... }) 因為當頁面載入時，.view-boarding-pass並不存在，所以必須使用把要選擇的元素寫在event handler裡面又稱為event delegate的作法。 做出Loading特效這是一個使用event delegate概念完成的特效。 12$('.photos').on('mouseenter', 'li', showPhotos) .on('mouseleave', 'li', showPhotos); 完整js檔如下 123456789101112131415161718192021222324252627$(document).ready(function() { function showPhotos() { $(this).find('span').slideToggle(); } $('.photos').on('mouseenter', 'li', showPhotos) .on('mouseleave', 'li', showPhotos); var el = $(&quot;#tour&quot;); el.on(&quot;click&quot;, &quot;button&quot;, function() { $.ajax('/photos.html', { data: {location: el.data('location')}, success: function(response) { $('.photos').html(response).fadeIn(); }, error: function() { $('.photos').html('&lt;li&gt;There was a problem fetching the latest photos. Please try again.&lt;/li&gt;'); }, timeout: 3000, beforeSend: function() { $('#tour').addClass('is-fetching'); }, complete: function() { $('#tour').removeClass('is-fetching'); } }); });});","link":"/2014/10/06/old%20posts/2014-10-06-jquery-return-flight-1-ajax-basics/"},{"title":"jQuery Return Flight Ch4：Utility Methods","text":"each用each把result的物件讀出來，插入頁面元素之中。要插入&lt;p&gt;&lt;/p&gt;之中使用的是html()要插入img的src欄位，使用find('img').attr('src', city.image)之前也有使用過attr()這個方法來找到data欄位。 12345678success: function(result){ $.each(result, function(index, city) { var favorite = $('.favorite-'+index); favorite.find('p').html(city.name); favorite.find('img') .attr('src', city.image); });} 1$.each(collection, function(&lt;index&gt;, &lt;object&gt;) {}); getJSON用ajax設定dataType:'json' 1234567('.update-status').on('click', function() { $.ajax('/status', { contentType: 'application/json', dataType: 'json', success: function(result) { ... } });}); 等於使用getJSON 1234567$('.update-status').on('click', function() { $.getJSON('/status', function(result) { name: 'JFK - New York, NY', var statusElements = ??? $('.status-list').html(statusElements) });}); map1234var myNumbers = [1,2,3,4];var newNumbers = $.map(myNumbers, function(item, index){ return item + 1 }); //myNumbers =&gt; [1,2,3,4] //newNumbers =&gt; [2,3,4,5] 使用map插入元素123456$.map(result, function(status, i) { var listItem = $('&lt;li&gt;&lt;/li&gt;'); $('&lt;h3&gt;' + status.name + '&lt;/h3&gt;').appendTo(listItem); $('&lt;p&gt;' + status.status + '&lt;/p&gt;').appendTo(listItem); return listItem;}); 完整版 1234567891011$('.update-flight-status').on('click', function() { $.getJSON('/status', function(result) { var statusElements = $.map(result, function(status, i) { var listItem = $('&lt;li&gt;&lt;/li&gt;'); $('&lt;h3&gt;'+status.name+'&lt;/h3&gt;').appendTo(listItem); $('&lt;p&gt;'+status.status+'&lt;/p&gt;').appendTo(listItem); return listItem;}); $('.status-list').html(statusElements); });}); 可以看出map需要另外指定一個陣列(statusElemets)來儲存所有的li。一次把一整包li，塞進ul中。而each是一個一個塞進去。相似的部份用map是語意滿清楚的作法。 還有一個最大的不同是each回傳的陣列不會改變，而map回傳的陣列是經過處理的。請看下圖： detach123456789101112$('.update-flight-status').on('click', function() { $.getJSON('/status', function(result) { var statusElements = $.map(result, function(status, index) { var listItem = $('&lt;li&gt;&lt;/li&gt;'); $('&lt;h3&gt;'+status.name+'&lt;/h3&gt;').appendTo(listItem); $('&lt;p&gt;'+status.status+'&lt;/p&gt;').appendTo(listItem); return listItem; }); $('.status-list').detach() }); .html(statusElements) .appendTo('.status');}); 這邊使用detach而不使用remove來刪除元素，因為detach其實不會把元素真正的刪除，而會保留下來。這樣做效率比較好。 detach與remvove的區別","link":"/2014/10/10/old%20posts/2014-10-10-jquery-return-flight-4/"},{"title":"jQuery Return Flight Ch5 ( 1 )：Advanced Event","text":"advanced event handlertrigger使用trigger就像是你按下那個按鈕。範例: 1234567891011function picture() { console.log('Show Plane'); }function status() { console.log('In Service'); }function zoom() { console.log('Zoom Picture'); }$(document).ready(function() { $('button').on('click.image', picture); $('button').on('click.details', status); $('button').on('mouseover.image', zoom); ... $('button').trigger('click');}); 使用trigger觸發事件(等於使用者按下按鈕) 1$('button').trigger('click'); 會觸發這兩個 12$('button').on('click.image', picture);$('button').on('click.details', status); 自訂&lt;event&gt;同時觸發多個事件照理說evnt的格式是： 1$(&lt;dom element&gt;).on(&quot;&lt;event&gt;.&lt;namespace&gt;&quot;, &lt;method&gt;) 但其實jquery可以自訂event，讓我們做更多方便的操作。現在我們來自訂一個event。 1$('.vacation').on('show.price', showPrice); 可以看到本來應該是’click’的部份，已經用show.price這個我們新創的event所代替。這樣我們就可以透過這個event來trigger所有的vacation。 1$('.vacation').trigger('show.price'); 或是透過這個event來trigger最後一個vacation。 1$('.vacation:last').trigger('show.price') 完整範例： 1234567var showPrice = function() {...};$('.vacation').on('click.price', 'button', showPrice)$('.vacation').on('show.price', showPrice);$('show-prices').on('click', function(event) { event.preventDefault(); $('.vacation').trigger('show.price');}; 下面這個例子是，要在點擊show photo按鈕時，也會顯示天氣。這 1234567891011121314151617$(document).ready(function(){ // Get Weather $('button').on('show.weather', function() { var results = $(this).closest('li').find('.results'); results.append('&lt;p&gt;Weather: 74&amp;deg;&lt;/p&gt;'); $(this).off('show.weather'); }); // Show Photos $('button').on('click.photos', function() { var tour = $(this).closest('li'); var results = tour.find('.results'); results.append('&lt;p&gt;&lt;img src=&quot;/assets/photos/'+tour.data('loc')+'.jpg&quot; /&gt;&lt;/p&gt;'); $(this).off('click.photos'); $(this).trigger('show.weather'); });}); 這樣就不會像原來一個button綁兩個click listener，而是綁定一個click listener依序執行兩個函數。 123456789101112131415161718$(document).ready(function(){ // Get Weather $('button').on('click.weather', function() { var results = $(this).closest('li').find('.results'); results.append('&lt;p&gt;Weather: 74&amp;deg;&lt;/p&gt;'); $(this).off('click.weather'); }); // Show Photos $('button').on('click.photos', function() { var tour = $(this).closest('li'); var results = tour.find('.results'); results.append('&lt;p&gt;&lt;img src=&quot;/assets/photos/'+tour.data('loc')+'.jpg&quot; /&gt;&lt;/p&gt;'); $(this).off('click.photos'); $(this).trigger('click.weather'); });}); off將符合event.namespace的handler移除刪除符合event的handler也可以指定namespace，符合namespace的handler都移除","link":"/2014/10/10/old%20posts/2014-10-10-jquery-return-flight-5-jquery-plugins/"},{"title":"EDX Linux Foundation Ch15：Shell Script ( Ch14跳過 )","text":"這是參加開源社群Tossug Linux讀書會的心得筆記，部分內容經過大大的補充，讓學習上更完整:）Ch14講的是Printer，因為實際使用上較多Bug所以跳過這一章節，等有需要的時候再來學習。 Shelllinux系統可分為三個重要的部份：1.kernel2.shell3.application 因為kernel的部份太過低階，所以需要透過一個友善介面(interface)來讓使用者操作的時候更為方便，這個介面便是shell。涵蓋範圍包括但不限於： CLI (Command line interface)GUI (Graphical user interface) 常見的CLI有以下幾種。 sh是最古老的shell，大部分的linux系統使用上sh時，會直接使用其他shell的對應功能來取代，所以使用時需特別注意，就算語法是sh，其實實際上運作的是bash或者其他的shell如zsh…等等。 csh 用c寫shell 其他shell如zsh功能較bash強大，但是bash是一般linux系統最常見最基本的shell，所以撰寫 Shell Script 時，使用 Bash 是較好的選擇。 GUI的話，略過不提，在linux下還是學習Command Line來的踏實。 Bash的兩種工作模式 interactive mode shell script mode interacitive mode 就是在終端機中一一輸入指令，等待一個指令執行完接著輸入下一個指令。而shell script mode顧名思義就是寫成.sh檔並執行裡面的shell script code，而shell script code就是由一連串的命令所組成。 第一支bash Scripts來試試看寫下第一個bash程式 1234$ cat &gt; exscript.sh #!/bin/bash echo &quot;HELLO&quot; echo &quot;WORLD&quot; 輸入chmod +x exscript.sh讓檔案可以執行。 重點整理1.Defensive BASH Programminghttp://www.kfirlavi.com/blog/2012/11/14/defensive-bash-programming/好的coding style可以大幅降低錯誤發生的機率。 2.double bracketshttp://mywiki.wooledge.org/BashFAQ/031在使用判斷式的時候 (例如：if) 使用[[]]代替[]，這樣可以減少很大出錯的原因。 3.如何實現function回傳值？Shell Script 可視為是一種字串取代的過程。呼叫 echo 輸出參數可以就可以讓其他不同scope的函數使用該參數。 4. shell script中的遞迴遞迴在shell scipt中並不會佔用太多的記憶體。這是由於shell script的語言特性是一連串的字串取代。 你不知道的shell scriptShell Script 可以 import libary。可以把程式拆成許多函式庫。Shell Script 可以 include Module。可以把程式拆解成許多模組。Shell Script 有 Test Unit 叫做shunit。 參考連結tossug linux 讀書會 第11週","link":"/2014/10/13/old%20posts/2014-10-13-edx-linux-foundation-ch15shell-script/"},{"title":"Atom 防止 Snippet Package 更新","text":"使用 Snippet 最重要的針對自己的習慣客製化快捷鍵。 Atom 有許多內建的 Snippet，建議「不要」使用，因為那些設定會存在「Atom 程式」裡面，無法儲存在 .atom 資料夾中。所以一旦 Atom 版本更新之後，全部的設定都會不見。如果要使用 Snippet 請使用 Package 安裝，這樣用 git 來控管 .atom 資料夾時，就不會發生意外，全部的修改都能由 git 救回。 回到正題，下載別人的 snippet package 後，經過客製化才會變成自己慣用的 snippet。這些自訂的 snippet ，在 package 更新後會全部不見，所以我們要防止 package 出現更新訊息，改成手動修改這些 snippet package 的更新。作法很簡單： 以 atom-rails-snippet 來說：打開package.json 123456789101112 {{ &quot;name&quot;: &quot;rails-snippets&quot;, &quot;version&quot;: &quot;1.6.0&quot;, &quot;main&quot;: &quot;./lib/rails-snippets&quot;, &quot;activationEvents&quot;: [ &quot;rails-snippets:toggleErb&quot; ], ......} 將最上面的 name，從 “rails-snippets 改成 “my-rails-snippets，這麼一來原本會顯示的 update 訊息就會消失如下 但是在 package search 仍然可以搜尋的到還是可以對 package 修改成自己要的樣子，超級方便的。 一直在思考要如何管理自己的 snippet ，目前想到的解法是使用 package 加上用 git 來管理 .atom 資料夾，達到「備份」與「自訂」兩個重要的需求。","link":"/2014/10/29/old%20posts/2014-10-29-atom-prevent-snippet-package-updates/"},{"title":"Rails Project 1 URL Shortener","text":"前言接下來我要藉由實作一些比較小型的Rails Project，來練習工程師必備的技能，其中最主要訓練的目標是能抓出需要實作的use case與如何從use case中實踐功能。因為沒有網頁的相關背景，如何磨練Html css javascript的基本實作能力也是這一階段的重點。 熟悉了如何使用Rails完成所要的需求與一些常見功能的開發之後，下一階段可以是學習Rails如何跟API互動或是開始學習Design Patterns。學習Dessign Pattern的原因有：一是可以讀的懂程式碼，二是了解為什麼要這麼寫。anyway，先把眼前的事情做好最重要let’s do it！ Use Case , Page Flow and Data在練習實作Project的過程中，我會格外地注意Use Case、Page Flow和Data。一個網站從無到有，便是先抓出使用者的需求，也就是Use Case，可以表達出身為不同的使用者，各需要哪些需求。 Use CaseUrl Shortener顧名思義要能夠縮減網址，我們可以抓出幾個需求。 使用者可以使用URL Shortener縮短網址 輸入URL Shortener產生的網址時必須連接到原網址。 Page FlowDataURL Shortener in Rails1. 建立專案1rails new url_shortener 2. route中加入url的resource，並指定首頁為url#new12root to: :redirect('/urls/new')resources :urls 3. 建立controller，controller要加s1rails generate controller urls Model 建立model，名詞是單數。要使用的Model有兩個欄位，original用來記錄原始網址，random_id用來記錄縮址。 1rails g model url original:string random_id:string 在model加上validates，這邊的意思是儲存時一定要有「原網址」的欄位。 1validates :original, presence: true ControllerIndex繼續完成controller，從index開始著手，在index我們希望可以看到全部儲存的連結。 12345class UrlsController &lt; ApplicationController def index @urls = Url.all endend Show在action show我們希望可以做到的功能是「當使用者輸入縮址時，會轉址到原網址」，這也是也這個URL Shortener的核心功能。 1234567891011121314151617class UrlsController &lt; ApplicationController . . . def show url = Url.where( random_id: params[:id] ).first if url redirect_to url.original else render &quot;index&quot; end endend New 在action new要做的事情是「當使用者輸入原始網址，會產生相對應的縮網址」 12345678910111213class UrlsController &lt; ApplicationController . . . def new @url = Url.new letters = [('a'..'z'),('A'..'Z')].map{|i| i.to_a}.flatten @url.random_id = (0...8).map{ letters[rand(letters.length)]}.join endend letter陣列用來裝所有的字母包含大寫A-Z與小寫a-z。flatten使屬於Array的method是用來把許多陣列合併成單一的陣列。第二行 產生隨機小寫英數字 幾種方法 and 效能 Create儲存一筆url資料，記得要使用strong parameter核對欄位。 1234567891011121314151617class UrlsController &lt; ApplicationController . . . def urls_params params.require(:url).permit(:original, :random_id) end def create @url = Url.new(urls_parmas) if @url.save redirect_to url_path else render &quot;new&quot; end endend 比較show與new可以發現，前面有加@的變數，是view會使用到的變數。如果view不會用到，那就不要添加@，以免造成混淆，這樣在閱讀程式碼的時候，可以更清楚的知道這些變數作用在哪些地方。 來複習一下render的用法主要有四種：第一種是直接回傳結果，回傳的格式可以是xml,json,text…等等檔案格式。範例：render text: &quot;hello world&quot;、render json: @event.to_json。第二種是render template。可以直接指定template的路徑如：render &quot;/events/index.html.erb&quot;。如果是同controller的action可以寫成render &quot;index&quot;。第三種是回傳status code例如：render status: 500。第四種是回傳某template使用的layout，例如：render layout: &quot;special_layout&quot;。 其他用法請參考：Layouts and Rendering in Rails Views因為URL Shortener的action show是轉址，並不需要view，所以我們要實作的view只有index.html.erb和new.html.erb。 index.html.erb12345678&lt;h1&gt;Url Shortener&lt;/h1&gt;&lt;% @urls.each do |url| %&gt; &lt;p&gt; &lt;%= link_to url.random_id, url_path(id: url.random_id) %&gt; --&gt; &lt;%= url.original %&gt; &lt;/p&gt;&lt;% end %&gt;&lt;%= link_to &quot;Shorten another URL&quot;, new_url_path %&gt; new.html.erb12345678910111213&lt;h1&gt;Shorten a URL&lt;/h1&gt;erb&lt;% @url.errors.each do|attr,msg| %&gt; &lt;%= msg %&gt; on &lt;%= attr %&gt;&lt;% end %&gt;&lt;%= form_for @url do |f| %&gt; &lt;p&gt; &lt;%= f.label :original %&gt; : &lt;%= f.text_field :original %&gt; &lt;/p&gt; &lt;%= f.hidden_field :random_id, value: @url.random_id %&gt; &lt;%= f.submit &quot;Shorten my URL&quot; %&gt;&lt;% end %&gt; SummaryURL Shortener這個小Project需求上跟一般實作的留言板有點不一樣，但還是可以用new和index兩個action來達成了Use Case所抓出來的需求。這非常有趣，多做點不同專案的好處就是能夠用不同的角度來累積經驗。","link":"/2015/01/04/old%20posts/2015-01-04-rails-project-1-url-shorter/"},{"title":"Atom 常用快速鍵","text":"Sublime 快速鍵Sublime有的快速鍵Atom幾乎都有，以下是我有在使用的一些快速鍵。 基本的移動與選取游標移至行頭/行尾cmd + 左 / 右 跳到頁首頁尾cmd + 上 或 下 游標移至上個單字 / 下個單字option + 左 / 右 選取上個單字 / 下個單字option + shift + 左 / 右 選取一行，多按幾次可以往下選cmd + l 快速換行ctrl + g 之後輸入要跳至的行數 批次編輯多個單字或是編輯多行選取相同文字一次編輯，可按多次會選擇需要修改的相同字cmd + d 一次編輯數行cmd + shift + l 批次移動單字/移動多行整段選取改變位置cmd + control + 上 或 下 整段選取改變位置（左右）cmd + [ 或 ] 其他在「整個project」內搜尋關鍵字。cmd + shift + f 貼上時，符合縮排cmd + shift + v emmetctrl + w 用html tag包覆選擇文字 選取文字 ＋ [ 或 {配合原生的快速鍵：選取文字後直接按[或{，就可以包住選取文字。這樣想把文字包起來的問題可以說是完全解決。 ctrl + m在切換到bracket的另一邊 alt + tab擴展tag tree viewctrl + 0 focus tree viewm 修改路徑或者名稱a 增加檔案delete 刪除檔案d 複製重複檔案 Vim mode Package用Vim的指令來做一些畫面的移動，不過因為有lazy search，就算不是很熟悉Vim開發流程還是可以很順暢。","link":"/2015/01/10/old%20posts/2015-01-10-atom-shortcuts/"},{"title":"Rails note : Require Creator","text":"增加一個叫做Creator的別名，讓我們在判別作者時文意更加通順。 設定發文者我們透過foreign key新增一個叫做creator的別名。作法是修改model/post.rb原本的 1belongs_to :user 改成 1belongs_to :creator, foreign_key: &quot;user_id&quot;, class: &quot;User&quot; 原本我們要使用post.user來取得文章作者，現在可以使用post.creator來取得作者。 只有作者可以新增或修改文章 到posts controller加上before_action :require_creator, only: [:edit, :update] 在application controller中加入一個access dined的方法，這個方法的目的是「如果不是creator來新增或修改文章，就會出現錯誤訊息」。 123456789class ApplicationController &lt; ActionController::Base . . . def access_denied flash[:error] = &quot;You can't do that.&quot; redirect_to root_path endend 接著在posts controller加上剛剛使用before action驗證的方法，require_creator驗證了兩件事情，第一是你必須登入，第二則是你必須是文章的作者。 123def require_creator access_denied unless logged_in? &amp;&amp; (current_user == @post.creator)end 這樣子就做完發文的驗證了。","link":"/2015/01/13/old%20posts/2015-01-13-rails-note-require-creator/"},{"title":"Atom 套件整理","text":"atom-color-highlight 在編輯器中即時顯示色碼對應的顏色。 atom-development-server 一個很強大的東西，自己玩玩看吧。 atom-html-preview 老實說我不太會用這個套件，但是很多人下載，我就跟著下載了＠＠ autocomplete-plus 可以即時提示可用snippet或是路徑的套件。 autocomplete-snippets 搭配autocomplete-plus可以提示套件內的內容。懶人可以多多使用，爽度很高。 bootstrap3-snippets 我所使用的bootstrap3-snippet color-picker 顏色選擇器 docblockr 很好用的加強comment的套件，在block comment中按下enter就會自動多加個星號。很方便。建立block comment的快捷鍵是/**加上tab。 emmet 這就不用多做介紹了，網頁工程師必裝套件，如果不太清楚的話請google一下有很多介紹的好文。值得注意的是我會將預設的tab鍵改成慣用的按鍵，以免與snipppet相衝。 fancy-new-file 快速建立檔案的套件，可以提示目前有的資料夾路徑。 gist-it 用來將目前檔案或是選取的範圍製作成gist的工具。 gistom 可以從自己github呼叫想要使用的gist的工具。 git-history 配合tree-view使用可以顯示沒有commit過的檔案。 highlight-column highlight-line 以上兩者可以幫助寫程式對齊的問題，有時候會看到眼花很好用的XD。 highlight-selected 選取的地方highlight顯示。 javascript-snippets language-haml linter 可以當做debugger的好用工具，配合以下幾個套件使用，可以選擇性安裝你所撰寫的語言。 linter-csslint linter-erb linter-htmlhint linter-jshint livereload 可以即時更新網頁的套件。 minimap 右方出現小圖示讓我們知道目前畫面在檔案的哪一區段。 minimap-color-highlight 可以顯示目前畫面在minimap的哪一區段。 open-in-browser 可以在預設瀏覽器打開目前檔案的套件。 package-sync 創造目前package的清單，值得注意的是如果之前已經建立過了，他將不會覆蓋，要手動刪除.atom/package.cson檔案，在進行新增。 rails-navigation 配合vim-mode使用，可以快速切換model view controller。 rails-snippets 我慣用的rails snippet。 save-session 可以記錄目前檔案修改到哪邊的套件，跟另一套remember-session比起來的好處是啟動速度快非常多，所以我使用這套。 script 可以在atom中直接執行程式碼的工具。 seti-syntax seti-ui 我所使用的佈景主題。 tabs-to-spaces 可以將tab轉為空格。 vim-mode 可以在atom中使用vim的指令。 zentabs 限制開啟的分頁最多不超過5個。 最後附上我的package清單， 12345678910111213141516171819202122232425262728293031323334353637383940 ##packages.cson 'packages': [ 'atom-color-highlight' 'atom-development-server' 'atom-html-preview' 'autocomplete-plus' 'autocomplete-snippets' 'bootstrap3-snippets' 'color-picker' 'docblockr' 'emmet' 'fancy-new-file' 'gist-it' 'gistom' 'git-history' 'highlight-column' 'highlight-line' 'highlight-selected' 'javascript-snippets' 'language-haml' 'linter' 'linter-csslint' 'linter-erb' 'linter-htmlhint' 'linter-jshint' 'livereload' 'minimap' 'minimap-color-highlight' 'open-in-browser' 'package-sync' 'rails-navigation' 'rails-snippets' 'save-session' 'script' 'seti-syntax' 'seti-ui' 'tabs-to-spaces' 'vim-mode' 'zentabs']","link":"/2015/02/02/old%20posts/2015-02-02-atom-kit-recommended/"},{"title":"Rails - 拆解 Form Helper 以 Checkbox 為例","text":"使用Rails Form Helper時，很重要的一點是要知道Form Helper會產生什麼樣的Html Code，了解之，觀察之，這樣你才能修改成自己需要的樣子。如果要在form中加入check box，可以使用collection_check_boxes這個在rails 4新加入的form helper來完成。我們就以checkbox為例，來練習觀察html吧！ Collection Check Box第一個來使用到的是collection_check_boxes，完整的參數是collection_check_boxes(object, method, collection, value_method, text_method, options = {}, html_options = {}, &amp;block)，一看覺得眼花撩亂，沒關係，直接來看例子。首先我們有兩個model，分別為Post和Cateogry，他們是多對多的關係。現在我們想要在新增Post的時候可以用checkbox選擇Category。 1234&lt;%= f.label &quot;Categories&quot; %&gt;&lt;%= f.collection_check_boxes :category_ids, Category.all, :id, :name do |cb| %&gt; &lt;%= cb.label( class:&quot;checkbox inline&quot;){cb.check_box(class:&quot;checkbox&quot;)+cb.text} %&gt;&lt;% end %&gt; 產生的html是 1234&lt;input id=&quot;post_category_ids_1&quot; name=&quot;post[category_ids][]&quot; type=&quot;checkbox&quot; value=&quot;1&quot;&gt;&lt;label for=&quot;post_category_ids_1&quot;&gt;food&lt;/label&gt;&lt;input id=&quot;post_category_ids_2&quot; name=&quot;post[category_ids][]&quot; type=&quot;checkbox&quot; value=&quot;2&quot;&gt;&lt;label for=&quot;post_category_ids_2&quot;&gt;Play&lt;/label&gt;&lt;input name=&quot;post[category_ids][]&quot; type=&quot;hidden&quot; value=&quot;&quot;&gt; 使用binding.pry來看看create送出的params有哪些東西。 用binding pry把form傳出的資訊抓出來看可以發現，params中傳送的key正是使用category_ids來做為名稱，因為checkbox的name都是相同的，所以只會有一個key(這邊不懂的話請去了解一下checkbox的html與select的html有什麼不一樣)。而value就是選擇的選項，因為我在form中勾選了第一個選項，所以顯示為”1”。label的for屬性，代表這是給哪一個專屬的id所使用的label，for與id常常搭配使用。 手刻html版的checkbox知道會產生怎麼樣的form和知道會傳出怎麼樣的params以後我就可以手刻一個html版的checkbox。 12345&lt;% Category.all.each do |category| %&gt; &lt;input id=&quot;post_category_ids_&lt;%= category.id %&gt;&quot; name=&quot;post[category_ids][&lt;%= category.id %&gt;]&quot; type=&quot;checkbox&quot; value=&quot;&lt;%= category.id %&gt;&quot; /&gt; &lt;label for=&quot;post_category_ids_&lt;%= category.id %&gt;&quot;&gt;&lt;%= category.name %&gt;&lt;/label&gt;&lt;% end %&gt; 刻完之後更加了解了form中attribute的涵意(每個都要用手打阿)，在ruby on rails還沒有form helper時也是得要用手刻，這樣做的好處是可以對html更加的印象深刻，當然，如果閉著眼睛都記得這些tag怎麼使用了，再來使用form helper也不遲:)","link":"/2015/01/18/old%20posts/2015-01-18-rails-form-helper/"},{"title":"排版練習1：PSD to HTML Porfolio","text":"最近在訓練排版的熟練度，要快速打造protype基本的前端技能是必須的。我選擇的教材是tuts的psd to html porfolio。課程中介紹了詳細的切版流程，從切圖到建構html到用css排版都有詳細的介紹。本篇是psd to html也就是排版練習第一篇，練習的是使用純css來刻網站。接下來會練習更多題目，直到我掌握基本的排版技巧為止。 photoshop基本操作psd to html 顧名思義就是把設計師做好的 photoshop 檔案，用 html 和 css 刻成網頁。這個練習很棒的地方就是模擬了一個設計師跟你合作。所以首先你的電腦裡需要安裝photoshop。我使用的是photoshop cc 2014版本。 測量元素距離 查看字型、字體大小和行高 查看顏色 chrome基本操作 使用page ruler測量網頁元素距離，可以看看 在dev tool修改css屬性即時更新畫面效果。 在dev tool中觀看html結構（雖然是自己刻的但是還是會忘記呀-.-）。 使用 livereload 套件即時更新修改結果。 開始實作 首先是header的部份，使用具有透明度的圖片格式會是png，加上背景色之後就會呈現以下效果。設定好背景與圖片之後使用float進行排版即完成。 第二個部分是section .feature，使用的排版技巧是將三個li的寬度(width)設成33.333%，再使用float:left進行排版。需要注意的是，加上border時會產生寬度大於原本container寬度的bug，使用box-sizing:border-box將內部寬度大於原本ul寬度的問題修正掉。中間image的置中的效果其實是用anchor先包覆住image與h3，接著設定padding-top:100px來固定他的位置。 第三部分是section .porfolio，使用的排版技跟剛剛的.feature有所不同。首先設定.container的大小，本練習中.container的寬度設為900px。因為需要三個20px的間隔，所以900px-20px * 3=840px。最後除以四210px就是個元素的寬度 最後介紹的是footer，這邊使用的排版技巧跟feature相同，寬度設定為33.333%後使用float:left進行排版。Registration Form使用的排版技巧：設定input的寬度為100%，這樣就會看起來一列有一個input。對input設定padding會讓placeholer跟border有所空間，看起來更美觀。 練習後心得這個練習難易度較低，但是也因為如此可以熟練chrome、text-editor和photoshop等必備的開發工具。對我來說是很適合的練習。練習過後對一些常用的CSS屬性更加熟悉，對開發速度是很有幫助的。","link":"/2015/02/12/old%20posts/2015-02-12-psd-to-html-porfolio/"},{"title":"Ajax 學習筆記","text":"ajax 如何運作？ Ajax 立基於非同步 JavaScript 和 XML。簡單地說，Ajax 即運用非標準的XMLHttpRequest物件，並配合伺服器端的 Script 進行通訊。 Ajax 能夠傳送並接收各種格式的資訊，其中包括 XML、HTML 和 text 檔案。 Ajax 最吸引人之處在於它的〝非同步〞性質，這意味著 Ajax 能做各種動作，而無須更新整個頁面。如此便能透過使用者的事件更新頁面的一小部分。 step 1. 發出http request 建立跨瀏覽器物件實體。為了使用 JavaScript 向伺服器發送 HTTP 請求，便需要一個能夠提供相關功能的類別實體（an instance of a class)。IE以ActiveX物件的方式引入，稱為XMLHttp，而Mozilla、Safari 及其他瀏覽器則是使用XMLHttpRequest類別產生物件。123456var httpRequest;if (window.XMLHttpRequest) { // Mozilla, Safari, ... httpRequest = new XMLHttpRequest();} else if (window.ActiveXObject) { // IE httpRequest = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);} 決定伺服器傳回資料的處理方式，此時你只要以 onreadystatechange 這個屬性指明要處理傳回值的 JavaScript 函式名稱即可，例如：1httpRequest.onreadystatechange = nameOfTheFunction; 注意，指定的函式名稱後不加括號也沒有參數。這只是簡單的賦值，而非真的呼叫函數。除了指定函式名稱外，你也能用 Javascript 即時定義函式的技巧（稱為〝匿名函數〞）來定一個新的處理函式，如下：123httpRequest.onreadystatechange = function(){ // 做些事}; 確實發出request，此時需叫用 HTTP request 類別的 open() 及 send() 方法，如下：12httpRequest.open('GET', 'http://www.example.org/some.file', true);httpRequest.send(null); open()做的工作是初始化一些設定 第一個參數是 HTTP request 的方法，也就是從 GET、POST、HEAD 等伺服器支援的方法中擇一使用。為遵循 HTTP 標準，請記得這些方法都是大寫，否則有的瀏覽器（如 Firefox）不會處理這些請求。其他可用的 HTTP request 方法的列表請參考 W3C 規格書。 第二個參數是請求頁面的 URL。基於安全考量，你不能叫用同網域以外的網頁。如果網域不同，則叫用 open() 時會出現「權限不足，拒絕存取」那類的錯誤。常見的錯誤多為在 domain.tld 的網站下呼叫 www.domain.tld 中的網頁，僅是一點點差別都不行。 第三個參數決定此 request 是否不同步進行，如果設定為 TRUE 則即使伺服器尚未傳回資料也會繼續執行其餘的程式，這也就是 AJAX 中第一個 A 代表的意義。 send() 按下時真正送出request send() 的參數在以 POST 發出 request 時，可以是任何想傳給伺服器的東西，而資料則以查詢字串的方式列出，例如：name=value&amp;anothername=othervalue&amp;so=on step 2: 處理伺服器傳回的資料傳出 request 時必須提供處理傳回值的函數名稱，這個函數是用來處理伺服器的回應。 1httpRequest.onreadystatechange = nameOfTheFunction; 那麼來看看這個函數該做些什麼。首先，它必須檢查 request 目前的狀態。如果狀態值為 4 代表伺服器已經傳回所有資訊了，便可以開始解析所得資訊。 12345if (httpRequest.readyState == 4) { // 一切 ok, 繼續解析} else { // 還沒完成} readyState 所有可能的值如下： 0 (還沒開始) 1 (讀取中) 2 (已讀取) 3 (資訊交換中) 4 (一切完成) 接下來要檢查伺服器傳回的 HTTP 狀態碼。所有狀態碼列表可於 W3C 網站上查到，但我們要管的是 200 OK 這種狀態。 12345if (httpRequest.status == 200) { // 萬事具備} else { // 似乎有點問題，或許伺服器傳回了 404 (查無此頁) 或者 500 (內部錯誤) 什麼的} 檢查傳回的 HTTP 狀態碼後，要怎麼處理傳回的資料就由你決定了。有兩種存取資料的方式： 整理一下httpRequest回傳的屬性 readyState: ０：尚未讀取 １：讀取中 ２：已下載完畢 ３：資訊交換中 ４：處理完畢 Status:即HTTP協定的狀態碼 responseText:傳回值視為字串用 responseXML:把傳回值視為 XMLDocument 物件 參考資料 AJAX核心-XMLHttpRequest@神雕蝦 上手篇 - AJAX - MDN 延伸閱讀 AJAX - MDN Ajax Tutorial","link":"/2015/02/22/old%20posts/2015-02-22-ajax/"},{"title":"排版練習2：PSD to html with Bootstrap","text":"第二個練習一樣學習tuts的課程，選擇課程的好處是做到一半不知道該怎麼做時，有video解答可以看。看看高手怎麼做總是比自己亂弄的好的多。我選擇的課程是需要付費的，tuts還有一些免費的教材可以學習，影片或是文章教學都有，有興趣的自己發掘囉。第二個練習跟第一個練習不同之處在於本練習會使用bootstrap的grid system來排版，並且icon與logo會使用sprite css的方式來製作。 Sprite sheetssprite 說的是利用將 icon 集中在一張圖片上，藉由CSS設定不同顯示區域，來實現每一個不同的icon。這樣的好處是很可降低圖片request數，減少server負擔。現在我們要使用sprite的方法實作的是右上角的五個social-icon和左上角的mumbo logo。 Create Sprite Sheets 首先在photoshop中用方框工具圈選5個icon 點選file &gt; copy merge複製五個icon file &gt; new 建立新檔案，圖像大小設定為250 X 250。 開啟ruler(view &gt; ruler) 從左側ruler拉進隔線每50px拉一條，這是為了等等區隔複製過來的icon，每個間隔會是50px。 使用方框工具(第二個工具)選取後，用移動工具(第一個工具)將icon對齊左上角(如果右下角的layer選錯的話，方框工具會選不到圖案）。 接著將mumbo logo也複製進來，放在第二排，對齊左上角，製作好的photoshop檔案會是長得像這樣。註: 將photoshop檔案 save for web，存成檔名為sprite.png的檔案。放在imgs資料夾下。 製作好圖片之後來實際做做看social-list，關鍵是將background設成sprite.png。再利用個別的class鎖定不同的位置，這樣就會顯示不同的icon。12345678910111213141516171819202122.social-list li{ display: inline-block; margin: 0 2px;}.social-list li a { display: inline-block; width: 37px; height: 37px; background: url(../imgs/sprite.png) no-repeat 0 0;}.social-list li a.vimeo { background-position: -50px 0;}.social-list li a.lastfm { background-position: -100px 0;}.social-list li a.linkedin { background-position: -152px 0;}.social-list li a.dribble { background-position: -200px 0;} 這樣就完成social-icon了。 接著要把左上方的logo用sprite的手法改寫。123456header hgroup h1 a{ display: block; width: 172px; height: 25px; background: url(../imgs/sprite.png) no-repeat 0 -50px;} 如此一來便大功告成。使用photoshop手動製作sprite是比較沒效率的作法，現在已經有很多方便的工具可以使用，藉由這個練習了解sprite的原理，之後再學習快速開發的工具便容易許多。 學習筆記 先來進行header的h1與h2排版，要達成的效果如下圖。還在苦惱怎麼使用純CSS設定長寬和box-model讓他服服貼貼的時候，突然發現有.pull-left可以用。真是太方便了。 使用font-style: italic;就可以讓標題有傾斜的效果。 如何讓li前面的dot變色？對li加上color: #ff6b39;就可以將dot一同變色。","link":"/2015/02/12/old%20posts/2015-02-12-psd-to-html-with-bootstrap/"},{"title":"保哥 javascript 實戰課程筆記","text":"javascript 語言特性 javascript是個動態型別語言，無法在開發期間宣告型別，意味著javascript的單一變數可能會隨時改變型別! javascript是個弱型別的語言：意味著在開發時期無法指定javascript型別。只能在執行期間檢查型別。如果真的要知道這個變數的型態，只能在執行時透過typeof的方式將該變數目前的型別使用字串顯示。 javascript是個物件導向程式語言，除了五種 primitive type 以外其他都是物件。這部份會在下一節詳細的說明。 javascript 是個物件導向程式語言這節會從javascript是物件導向語言這個觀點延伸了解javascript的型別(type)。 除了數值(number) 字串(string) 布林(boolean) null undefined 這五個是原始型別(Primitive Type)外，所有的東西都是物件。(引用自Are You Still Confuse with Data Types in JavaScript ?) Primitive Wrapper 是將 primitive type 包裝成物件， 提供了許多方便的方法。但其實primitive type也可以調用這些方法，因為在使用這些方法時，javascript運作的環境會自動將 prinitive type 轉換成 Primitive Wrapper。 下圖中橢圓形的是primitive type而方形的就代表的是物件，可以看出primitive wrapper也是一種物件。（引用自What is the difference between JavaScript null and undefined? – Wintellect DevCenter) javascript 的物件特性了解javascript的型別之後，接下來我們要來了解javascript的物件特性。 1. JavaScript物件是個容器(Container)。每個物件包含了屬性(Property)和方法(Method或Function)。 123456var car={}; //宣告物件(Object)car.nume = &quot;BMW&quot;; //name是car的屬性(Property)car.start=function(){ //函式(Function) return &quot;OK&quot;;}var car_name = car['name']; 2. JavaScript 物件其實就是 HashMap 所有屬性名稱一定是字串 取得car的屬性name的內容有兩種取法 一種是物件取法car.name 和 另一種是陣列取法car['name']。 需要注意的是不能用數字當變數，所以cat.007 is undefined ，但是妳可以使用cat['007']。 （這部份code school的javascript課程有更多範例，未來有時間的時候再補充。） 3. JavaScript沒有Class概念，所以你可以不需要constructor，就能建立物件 javascript的constructor(建構式)就是函式，又稱建構式函式。 使用 new 關鍵字，透過建構式建立物件。 12345678function person(first, last, age, eyecolor) { this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor;}var myFather = new person(&quot;John&quot;, &quot;Doe&quot;, 50, &quot;blue&quot;);var myMother = new person(&quot;Sally&quot;, &quot;Rally&quot;, 48, &quot;green&quot;); 12var myFather = new person(&quot;John&quot;, &quot;Doe&quot;, 50, &quot;blue&quot;);var myMother = new person(&quot;Sally&quot;, &quot;Rally&quot;, 48, &quot;green&quot;); 因為javascript沒有Class概念，所以必須借助prototype的特性。 4. javascript的物件可以不需先行宣告就可以自由擴充屬性 這點是我之前學習時沒有發現的微妙之處，一般物件導向程式語言如java一定要先行宣告變數才能使用，而javascript卻不需要。 因為原始型別無法自由擴增屬性，所以針對 number,string,boolean有提供原始型別包裹方式，包裹成物件後，即可透過該物件自由擴增屬性。 物件也可以透過下列的方法轉換成原始型別。valueOf() : 物件型別轉成原始型別。toString() : 物件型別轉成字串型別。 12345678//物件範例var obj = { 'a':1, 'b':2 };//擴增屬性obj.c = 3;//這時候obj就會有a, b, c三個屬性了//刪除屬性elete obj.b;//這時候obj又只剩下a, c三個屬性了 5. 原生物件與宿主物件javascript有兩種物件： 原生物件(Native)，也可以叫做內建物件，例如Array、Date或是使用者自行定義(後面會提到) 宿主物件(Host)，例如window物件和所有DOM物件。 所有物件資料都從根物件(就是window)開始連結(chain)。 怎麼去分辨這兩種物件，只要看看物件能不能在瀏覽器底下執行就可以，如果只能在瀏覽器底下執行，就是Host物件，如果在非瀏覽器的地方也可以執行，那就是Native。 物件、變數與型別的關係 物件(object) 記憶體中的資料 僅存在執行時期 變數(variable) 用來儲存物件的記憶體位址(指標) 在開發時期進行宣告(使用var關鍵字) 型別(type) 用來標示物件的種類 不同型別可能會有不同的預設屬性與方法 (引用自梅西的小腦袋) 範例：物件、變數與型別之間的關係請問以下出現過幾個記憶體物件? 出現過幾個變數? 出現過幾個型別? 1234var a;a=1;a=&quot;a&quot;;a=&quot;a&quot;+a; (引用自梅西的小腦袋) ANS : 5個記憶體物件、1個變數、3個型別 ‘ 函式物件( funciton )函式是個特殊的物件(其實函式本身有一個內部物件，用來存放在函式中宣告的變數、物件與屬性，只是外部無法存取該內部物件。)，有兩大特色 函式是Javascript的一級物件(first-class object) 可以被動態建立 可以指定給變數，也可以複製給其他變數 可以擁有自己的屬性或方法(如同物件的特性) 提供變數的作用域(scope)，換句話說，作用域是看function範圍，而不是 {} 的符號範圍，跟C#不一樣。 函式表示法 表式式 具名表示1var add = function add(a, b){return a+b;}; 匿名表示1var add = function (a, b){return a+b;}; 宣告式 具名宣告1function add(a, b){return a+b;}; 匿名宣告1function (a, b){return a+b;}; 使用匿名的方式，在偵錯或是效能調教時，會無法看出確切的函式位置，盡量避免。 後記保哥javascript實戰開發課程中還有更多的內容，本篇學習筆記重點放在理解 javascript 的重要特性和 javascript 的物件特性，函式部分只有稍稍帶過，更詳細的筆記將會在研讀JavaScript語言核心系列的時候記錄。 參考資料 JavaScript觀念整理-保哥上課心得 (1) « Coding For Fun JavaScript觀念整理-保哥上課心得 (2) « Coding For Fun Wilson.S.Weng: JavaScript 基礎訓練","link":"/2015/02/22/old%20posts/2015-02-22-bogut-javascript-practical-notes/"},{"title":"javascript核心筆記：Object","text":"在 JavaScript 中，物件是 Object 的實例。你可以如下建立一個新的物件： 1var obj = new Object(); 實際上，現在已經很少人這麼撰寫了，使用物件實字（Object literal）語法就可以建立一個物件： 1var obj = {}; 上面你所看到的函式撰寫方式，稱之為函式實字（Function literal），這就像你寫下一個數值實字、物件實字或陣列實字，會產生數值或物件等： 搜尋物件上的特性想要知道物件上有哪些自定義特性，可以使用 for in 語法，逐一取出物件的特性名稱。例如： 123456789101112&gt; for(var prop in obj) {... console.log(prop);... console.log(typeof prop);... }xstringystringundefined&gt; 'x' in obj;true&gt; 物件個性化在 JavaScript 中，每個物件都可以是獨一無二，不一定是由其建構式來規範，這能力稱為物件個性化（Object individuation），你可以隨時為物件新增特性（Properties），也可以隨時用 delete 運算子來刪除特性。 有些內建特性無法被刪除，舉例來說，Array 實例有個 length 特性，你無法刪除它： 1234567&gt; var arr = [];undefined&gt; arr.length;0&gt; delete arr.length;false&gt; js物件的本質就像是Map物件JavaScript的物件本質上，其實是個特性與值的群集（Collection），要比喻的話，有點像是 Java 中的 Map 物件。如果你要使用 for in 取得物件上的特性與值，則可以如下： 123456789101112&gt; var obj = {... x : 10,... y : 20... };undefined&gt; for(var prop in obj) {... console.log(prop + ': ', obj[prop]);... }x: 10y: 20undefined&gt; 使用 [] 運算子的場合之一，就是當你的特性會包括空白、.字元、數字…等時。 特性偵測特性便是javascript物件中的key。我們要偵測物件是否存在某特性時可以用以下兩種方式： 使用 in 測試物件上是否存在特性之外。 由於物件上不存在某個特性時，你試圖存取時會傳回 undefined，而undefined若在判斷是否成立時會被當作 false，所以就有了特性偵測的作法：123456789&gt; var obj = {};undefined&gt; obj.x ? 'has x' : 'has no x';'has no x'&gt; obj.x = 10;10&gt; obj.x ? 'has x' : 'has no x';'has x'&gt; javascript是個弱型別語言JavaScript是個弱型別語言，在需要將物件的型別(Type)轉為number的時候，會呼叫 valueOf 方法。例如： 123456789101112131415&gt; var obj = {... valueOf : function() {..... return 100;..... }... };undefined&gt; 100 + obj;200&gt; obj + 200;300&gt; obj &gt; 100;false&gt; obj &gt;= 100;true&gt; 在需要將物件的Type轉換為字串的場合，則會呼叫toString方法。例如： 1234567891011&gt; var caterpillar = {... name : 'Justin Lin',... url : 'openhome.cc',... toString : function() {..... return '[name: ' + this.name + ', url: ' + this.url + ']';..... }... };undefined&gt; 'My info: ' + caterpillar;'My info: [name: Justin Lin, url: openhome.cc]'&gt; 比較”===”與”==”=== 用在物件比較時，是比較參考的對象是否為同一物件，而不是物件實際內含值（== 得考慮型態轉換後的結果)。 如果你要比較兩個物件實際上是否為同一物件，必須自行定義專屬方法。可以命名為equals。 123456789101112131415161718192021222324function equals(other) { return (this.name === other.name) &amp;&amp; (this.url === other.url);}var man1 = { name : 'Justin Lin', url : 'openhome.cc', equals : equals};var man2 = { name : 'Justin Lin', url : 'openhome.cc', equals : equalsÂ};var man3 = { name : 'Justin Lin', url : 'openhome.cc', equals : equals};console.log(man1.equals(man2)); // trueconsole.log(man1.equals(man3)); // true 如果了解prototype的概念，可以改寫成下面這樣。 123456789101112131415function Man(name, url) { this.name = name; this.url = url;}Man.prototype.equals = function(other) { return (this.name === other.name) &amp;&amp; (this.url === other.url);};var man1 = new Man('Justin Lin', 'openhome.cc');var man2 = new Man('Justin Lin', 'openhome.cc');var man3 = new Man('Justin Lin', 'openhome.cc');console.log(man1.equals(man2));console.log(man1.equals(man3)); 參考資料JavaScript 語言核心（6）鍵值聚合體的物件 by caterpillar CodeData","link":"/2015/02/24/old%20posts/2015-02-24-javascript-core-note/"},{"title":"Javascript核心筆記：callback","text":"callback是一種設計模式來看看callback的定義： Callback (computer programming) - WikipediaIn computer programming, a callback is a reference to a piece of executable code that is passed as an argument to other code. jQuery Document: How jQuery Works#Callback_and_Functio…A callback is a function that is passed as an argument to another function and is executed after its parent function has completed. The special thing about a callback is that functions that appear after the “parent” can execute before the callback executes. Another important thing to know is how to properly pass the callback. This is where I have often forgotten the proper syntax. 所以本質上callback是一種設計模式。當一段程式碼可以當做參數丟給其他程式碼執行就叫做callback。jQuery和許多其他的框架的設計原則都遵循這個模式。 callback不限於非同步使用同步時使用callback通常是希望程式能夠按照順序執行。通常callback在同步的情況下是最後執行的。 12345678910var func1=function(callback){ //do something. //如果callback存在就執行它 callback &amp;&amp; callback();}func1(func2); var func2=function(){} 非同步的例子： 1234567891011$(document).ready(callback);$.ajax({ url: &quot;test.html&quot;, context: document.body}).done(function() { $(this).addClass(&quot;done&quot;);}).fail(function() { alert(&quot;error&quot;);}).always(function() { alert(&quot;complete&quot;);}); callback function的撰寫方式1.沒有其他引數時123456789101112function basic( callback ){ console.log( '作些事情' ); var result = '我是等會要被傳送給 `do something` 的 callback 的函式結果'; // 如果 callback 存在的話就執行他 callback &amp;&amp; callback( result );}basic( function( result ){ console.log( '這個 callback 函式會在 terminal 上列出 `basic` 函式執行的結果' ); console.log( result );}); 結果 123作些事情這個 callback 函式會在 terminal 上列出 `basic` 函式執行的結果我是等會要被傳送給 `do something` 的 callback 的函式結果 2.有其他引數時可以用call或apply來實作。用call來實作看看。1234567891011121314151617181920212223function callbacks_with_call( arg1, arg2, callback ){ console.log( '作些事情' ); var result1 = arg1.replace( 'argument', 'result' ), result2 = arg2.replace( 'argument', 'result' ); this.data = '這等會可以讓 callback 函式用 `this` 來調用'; // 如果 callback 存在的話就執行他 callback &amp;amp;&amp;amp; callback.call( this, result1, result2 );}( function(){ var arg1 = '我是 argument1', arg2 = '我是 argument2'; callbacks_with_call( arg1, arg2, function( result1, result2 ){ console.log( '這一個 callback 函式將會列出 `callbacks_with_call` 的執行結果' ); console.log( 'result1: ' + result1 ); console.log( 'result2: ' + result2 ); console.log( 'data from `callbacks_with_call`: ' + this.data ); });})(); 執行結果 12345作些事情這一個 callback 函式將會列出 `callbacks_with_call` 的執行結果result1: i am result1result2: i am result2data from `callbacks_with_call`: 這等會可以讓 callback 函式用 `this` 來調用 參考資料Javascript callbacks | DreamersLabJavaScript 回调函数怎么理解","link":"/2015/02/27/old%20posts/2015-02-27-javascript-core-note-callback/"},{"title":"Javascript核心筆記：建構式與prototype","text":"建立物件時，實際上做了什麼事?使用 new 關鍵字時，JavaScript 會先建立一個空物件，接著設定物件的原型為函式的 prototype 特性所參考的物件，然後呼叫建構式並將所建立的空物件設為 this。接下來依照建構式設定實例上的特性，最後再由prototype補上未設定的特性。 建構式如何初始化實例1234567var p1 = new Person('Justin', 35);var p2 = new Person('Monica', 32);var p3 = new Person('Irene', 2);console.log(p1.toString()); // [Justin,35]console.log(p2.toString()); // [Monica,32]console.log(p3.toString()); // [Irene,2] 當你使用new產生Person物件時。其實是透過如下面例子的建構式function Person 初始化了建構式所設定的各個特性。 1234567891011121314function toString(){ return '[' + this.name +',' + this.age + ']';}function Person(name, age){ this.name = name; this.age = age; this.toString = toString;}var p = {}Person.call(p, 'Justin', 35);console.log(p.toString()); constructor特性每個透過 new 建構的物件，都會有個 constructor 特性，參考至當初建構它的函式。例如： 123function Person() {}var p = new Person();console.log(p.constructor == Person); // true 事實上，每個函式實例建立時，都會在函式實例上以空物件建立 prototype，然而在空物件上設定 constructor 特性，也因此每個 new 建構的物件，都可以找到 constructor 特性。例如： 12function Some() {}console.log(Some.prototype.constructor); // [Function: Some] prototype特性JavaScript 在尋找特性名稱時，會先在實例上找尋有無特性，以下例而言，p1 上會有 name 與 age 特性，所以可以直接取得對應的值。如果物件上沒有該特性，會到物件的原型上去尋找，以下例而言，p1 上沒有 toString 特性，所以會到 p1 的原型上尋找，而 p1 的原型物件此時也就是 Person.prototype 參考的物件，這個物件上有 toString 特性，所以可以 找到 toString 所參考的函式並執行。 1234567891011121314function Person(name, age) { this.name = name; this.age = age;} Person.prototype.toString = function() { return '[' + this.name + ', ' + this.age + ']';}; var p1 = new Person('Justin', 35);var p2 = new Person('Momor', 32); console.log(p1.toString()); // [Justin, 35]console.log(p2.toString()); // [Momor, 32] 要注意的是，只有在查找特性，而物件上不具該特性時才會使用原型，如果你對物件設定某個特性，是直接在物件上設定了特性，而不是對原型設定了特性。例如： 123456789function Some() {}Some.prototype.data = 10;var s = new Some();console.log(s.data); // 10s.data = 20;console.log(s.data); // 20console.log(Some.prototype.data); // 10 在上例中可以看到，你對 s 參考的物件設定了 data 特性，但並不影響 Some.prototype.data 的值。 如何實現private對熟悉物件導向私有（private）特性的人來說，可能覺得這不安全，這相當於在物件導向觀念中，每個類別成員都是公開成員的意味。JavaScript 本身並沒有支援物件導向私用特性的語法，如果你想模擬，則可以如下：(…待補充) 參考資料JavaScript 語言核心（13）在 Scope chain 查找變數 by caterpillar CodeDataJavaScript 語言核心（14）隱藏諸多細節的建構式 by caterpillar CodeData","link":"/2015/02/27/old%20posts/2015-02-27-javascript-core-note-constructor/"},{"title":"Javascript核心筆記：function","text":"javascript的函數是一級物件(First-Class)function是由Function的實例，並且在javascript中可以指定給變數，函式與數值的地位相同，並不會像有些語言中，無法像數值一樣地被指定，不會淪為二等公民，因此，對於支持函式可如數值一樣指定給變數的語言，我們稱函式在這個語言中是一級函數。 123456var number = 10; // Number literalvar obj = {x : 10}; // Object literalvar array = [1, 2, 3]; // Array literalvar func = function() { // Function literal // do something...}; 函式既然是物件，本身亦可擁有特性。例如函式有個 length 特性，代表其參數個數： 12345var gcd = function g(num1, num2) { return num2 != 0 ? g(num2, num1 % num2) : num1;};console.log(gcd.length); // 2 函數的回傳值函式沒設定return時，預設回傳undefined。 輸入的參數與引數不符合時如果函式傳入的參數不足時是可以執行的，不足的部份會自動補上undefined。 123456789function func(a, b) { console.log(a); console.log(b);}func(10, 20); // 10 20func(10); // 10 undefinedfunc(); // undefined undefinedfunc(10, 20, 30, 40); // 10 20 傳入比參數個數還多的引數也是可行的，在函式內部會自動宣告 arguments 名稱參考至具陣列外觀的物件，上頭帶有所有傳入的引數。例如，你可以如下設計一個加總數值的函式： 1234567891011function sum() { var sum = 0; for(var i = 0; i &lt; arguments.length; i++) { sum += arguments[i]; } return sum;}console.log(sum(1, 2));; // 3console.log(sum(1, 2, 3)); // 6console.log(sum(1, 2, 3, 4)); // 10 arguments 不是 Array 實例，它只是具有數字作為特性，特性參考至傳入的引數，並具有 length 特性代表傳入引數的個數。你可以使用arguments.length來檢查引數個數。 在 EMCAScript 5 前的版本，參數只是具名的引數，你改變參數的值，arguments 對應索引的參考值也會相應的改變。然而，若採用 EMCAScript 5 嚴格模式，參數的值 與 arguments 的元素值彼此互不影響。 函式宣告式、函式表達式與匿名函數 表達式 具名表達式 var add = function add(a, b){return a+b;}; 匿名表達式 var add = function (a, b){return a+b;}; 宣告式 具名宣告 function add(a, b){return a+b;}; 匿名宣告 function (a, b){return a+b;}; 宣告式的特性有： 在javascript引擎解析javascript程式碼時，會受到Function declaration Hoisting，提升到作用域的最前面執行。 後面加括號不可以立刻調用函數 表達式的特性有： 當javascript引擎執行到表達式的那行程式碼時，才會開始解析。 後面加括號立刻調用函數。 立即函數要在函數體後面加括號就能立即調用，則這個函數必須是函數表達式，不能是函數宣告式。所以立即函數的本質是函數表達式。立即函數可以讓括號內的變數變成區域變數，這部份請參考Scope的筆記。 後記除了本篇提到的性質以外，物件的建構式也是由function來構建，學習時一併理解以釐清不清楚的地方。 參考資料js中(function(){…})()立即执行函数写法理解","link":"/2015/02/27/old%20posts/2015-02-27-javascript-core-note-function/"},{"title":"Javascript核心筆記：namespace","text":"靜態命名空間方法1 - 直接指定123456789101112131415161718var myApp = {}myApp.id = 0;myApp.next = function() { return myApp.id++;}myApp.reset = function() { myApp.id = 0;}window.console &amp;&amp; console.log( myApp.next(), myApp.next(), myApp.reset(), myApp.next()); //0, 1, undefined, 0 方法 2. 使用物件實字（Object Literal Notation）方法3. 使用設計模式Module Pattern來建構動態命名空間未完…","link":"/2015/02/27/old%20posts/2015-02-27-javascript-core-note-namespace/"},{"title":"EDX Linux Foundation Ch13 Manipulating Text","text":"Section 1 cat and echocat(concatenate)1cat file 顯示檔案，按空白鍵可以捲動 1cat file1 file2 把file1和file2接起來顯示 1cat file1 file2 &gt; newfile 把file1和file2接起來並且存成newfile。 1cat &gt; filename 可以自行輸入內容，輸入完跳出後存成file(可輸入多行)。 1cat &gt;&gt; existingfile 代表在檔案後端插入( append )檔案，可以自行輸入內容，輸入完跳出後存成file(可輸入多行)。 1cat &gt; filename &lt;&lt; EOF 新增檔案的另一個方法，可以自行輸入內容，要離開的時候在句首輸入EOF。 taccat反過來 ，效果是從檔案的後面幾行開始顯示，用法跟cat相同tac filetac file file2 &gt; newfile echo跟cat不同是的是echo預設插入或新增一行。加上-e後允許使用\\n或\\t…等等的的特殊字元 123echo string &gt; newfileecho string &gt;&gt; existingfileecho $variable 印出變數。 Section 2 sed and awksed123sed Command Syntaxsed -e command &lt;filename&gt;sed -f scriptfile &lt;filename&gt; sed 的格式1234sed s/pattern/replace_string/ filesed s/pattern/replace_string/g filesed 1,3s/pattern/replace_string/g filesed -i s/pattern/replace_string/g file 如果需要寫入檔案，建議直接輸出，不要使用 -i 參數，會比較安全。例如：$ sed s/pattern/replace_string/g file &gt; file2 awk12awk ‘command’ var=value fileawk -f scriptfile var=value file Examples: 123awk '{ print $0 }' /etc/passwdawk -F: '{ print $1 }' /etc/passwdawk -F: '{ print $1 $6 }' /etc/passwd Section 3 File Manipulationsort123sort filenamesort -usort -r sort -u 將重複的資料僅列出一個(這邊不太確定)sort -k pos1[,pos2] 指定排序的key uniq刪除檔案中重複的資料，並儲存到另一個檔案，可以使用以下兩個方法。 12sort file1 file2 | uniq &gt; file3sort -u file1 file2 &gt; file3 使用-u比較好，因為uniq本身有bug，只有在兩個相同的東西相鄰時才會合併。 1uniq -c filename 計算重複的entry數量 paste想要把兩張表合併起來可以用paste來做到，輸出的結果依照delimiters來區分欄位，delimiter可以是tab、空格, comma, ‘|’等等。paste並不是很嚴謹的合併，需要先進行set且資料欄位齊全才可以使用。常用在user與group的對應。 1paste -d 使用 -d可以自訂delimiter。 1234paste -spaste file1 file2paste -d, file1 file2paste -d ':' names phone join$ cat phonebook 1234555-123-4567 Bob555-231-3325 Carol555-340-5678 Ted555-289-6193 Alice $ cat directory 1234555-123-4567 Anytown555-231-3325 Mytown555-340-5678 Yourtown555-289-6193 Youngstown The result of joining$ join phonebook directory 1234555-123-4567 Bob Anytown555-231-3325 Carol Mytown555-340-5678 Ted Yourtown555-289-6193 Alice Youngstown split1split infile &lt;Prefix&gt; 範例：把一個字典檔切成99000行wc可以用來查看檔案的行數或字數$ wc -l american-english 199171 american-english $ split american-english dictionary $ ls -l dictionary* 123-rw-rw-r 1 me me 8552 Mar 23 20:19 dictionaryab-rw-rw-r 1 me me 8653 Mar 23 20:19 dictionaryaa. . . Section 4 grep用來搜尋文字的工具，會依照設定的pattern來搜尋，pattern中可以使用regular experssion grep123456grep [pattern] &lt;filename&gt;grep -v [pattern] &lt;filename&gt;grep [0-9] &lt;filename&gt;grep -C 3 [pattern] &lt;filename&gt;grep -A 3 [pattern] &lt;filename&gt;grep -B 3 [pattern] &lt;filename&gt; Section 5tr用來刪除一段文字，或者替換一段文字。 Command Usage 1$ tr abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ Convert lower case to upper case 1$ tr '{}' '()' &lt; inputfile &gt; outputfile Translate braces into parenthesis 1$ echo &quot;This is for testing&quot; | tr [:space:] '\\t' Translate white-space to tabs 1$ echo &quot;This is for testing&quot; | tr -s [:space:] Squeeze repetition of characters using -s 1$ echo &quot;the geek stuff&quot; | tr -d 't' Delete specified characters using -d option 1$ echo &quot;my username is 432234&quot; | tr -cd [:digit:] Complement the sets using -c option 1$ tr -cd [:print:] &lt; file.txt Remove all non-printable character from a file 1$ tr -s '\\n' ' ' &lt; file.txt Join all the lines in a file into a single line tee想要將這個資料流的處理過程中將某段訊息存下來，就使用tee指令。 1ls -l | tee newfile wcword count計算line的數量或字數 cut這個指令可以將一段訊息的某一段給他『切』出來 Section 6使用 strings 需安裝 binutils。string可以用來 作業更好的解法(By Carl)Lab 2 1awk -F: '{ print $7 }' /etc/passwd | sort -u | sed '/^$/d' or 1awk -F: '{ print $7 }' /etc/passwd | sort -u | grep -v '^$' Lab 3解答的做法不好，應該單獨對 $7 做處理。 讀後心得課程中對awk sed等強大的指令只有輕輕帶過，但這次的範圍跟之後要學的shell script有密切的關係，開啟了","link":"/2014/10/07/old%20posts/2014-10-07-edx-linux-foundation-ch12-text/"},{"title":"Javascript核心筆記：scope","text":"Scope 每個function在呼叫時都會建立新的 Function execution context，有個物件用來代表 Execution context，而區域變數則是 context 物件上的特性。 JavaScript 在查找變數時，會先在目前 context 物件上找，若找不到指定名稱，則會到外層 context 物件上找，若找不到，就再到更外層 context 物件找，直到全域物件為止，這樣的順序形成變數查找的 Scope chain。 closure是典型應用scope chain的例子，在內部的 f 函式中 context 物件上找有無 x 特性時，並沒有找到，於是在包裹 f 的 doSome 呼叫物件上查找有無 x，也就是查找 f.parent 上有無 x，此時找到了。 1234567function doSome() { var x = 10; function f(y) { return x + y; } return f;} 參考資料JavaScript 語言核心（13）在 Scope chain 查找變數 by caterpillar - CodeData","link":"/2015/02/27/old%20posts/2015-02-27-javascript-core-note-scope/"},{"title":"Javascript核心筆記：this","text":"call可以讓你決定this的參考對象在 JavaScript 中，函式是 Function 的實例，Function 都會有個 call 方法，可以讓你決定 this 的參考對象。舉例來說，你可以如下呼叫： 12345678910111213141516function toString(){ return '[' + this.name + ',' + this.age + ',';}var p1 = { name:'Justin', age :35};var p2 = { name : 'momor', age : 32};console.log( toString.call(p1) ); //[Justin, 35]console.log( toString.call(p2) ); //[momor, 32] 妳可以覆寫call方法，讓this參考別的物件。 1234567891011121314151617function toString() { return this.name;}var p1 = { name : 'Justin', toString : toString};var p2 = { name : 'momor', toString : toString};console.log(p1.toString()); // Justinconsole.log(p2.toString()); // momorconsole.log(p1.toString.call(p2)); // momor 當call遇到有參數的函式時call 方法的第一個參數就是用來指定函式中的 this 所參考的物件。如果函式原本具有參數，則可接續在第一個參數之後。例如： 1234567function add(num1, num2) { return this.num + num1 + num2;}var o = {num : 10};console.log(add.call(o, 20, 30)); // 60 同樣決定this的參考對象還有apply可以使用決定差別在於apply必須將引數蒐集起成陣列，做為第二個參數來呼叫函數。 12345678910function add(num1, num2) { return this.num + num1 + num2;}var o1 = {num : 10};var o2 = {num : 100};var args = [20, 30];console.log(add.apply(o1, args)); // 60console.log(add.apply(o2, args)); // 150 this與全域物件如果呼叫函式時，無法透過 . 運算、call、apply 等方法確定 this 的對象，如果不是嚴格模式，那麼 this 會直接轉為參考全域物件（Global object）。 全域物件是 JavaScript 執行時期全域可見的物件，在不同的環境中想要取得全域物件，會透過不同的名稱，像是 Node.js 中可以使用 global，瀏覽器中可以透過 window 或在全域範圍使用 this，Rhino（或 JDK8 的 Nashorn）可以在全域範圍使用 this 取得。 因此，如果你想統一全域物件的變數名稱，例如統一使用 global，可以透過類似以下的方式： 123var global = global || (function() { return this;})(); this參考的對象並非以附屬在哪個物件而定this 實際參考的對象，是以呼叫方式而定，而不是它是否附屬在哪個物件而定。例如就算函式是附屬在函式上的某個特性，也可以這麼改變 this 所參考的對象： 1234567891011121314151617function toString() { return this.name;}var p1 = { name: 'Justin', toString: toString};var p2 = { name: 'momor', toString: toString};console.log(p1.toString()); // Justinconsole.log(p2.toString()); // momorconsole.log(p1.toString.call(p2)); // momor 參考資料 &amp; 延伸閱讀 JavaScript 語言核心（11）this 是什麼？ by caterpillar - CodeData Function.prototype.call - JavaScript - MDN","link":"/2015/02/27/old%20posts/2015-02-27-javascript-this/"},{"title":"Typescript是新手的好朋友","text":"為什麼 Typescript 是新手的好朋友typescript百分之百跟javascript相容，所有javascript的語法都可以在.tstypescript檔案中執行。因此就算是要javascrtip新手，也可以享受typescript帶來好處。typescript能夠讓 目前暫時不需要去研究typescript的其他功能，只需要他可以宣告型態，靜態語言即時偵錯，與關連定義檔就可以檢查method，光是這幾項就很值得使用了 需要注意的是因為typescript的許多特性，例如: class, module, interface 皆與原生javascript有所不同，如果對javascript還不了解，直接學習可能會更加的混淆。 在javascript演進這麼快速的現在，要選擇任何一種framework或是語言都是一種巨大的投資， 選擇 Typescript 還有什麼好處？ 因為javascript的是個動態型別的語言，所以只能在執行時期偵錯，要真的執行到那一行，才會跳出錯誤訊息，這使的偵錯上非常的不容易。 typescript所能解決的問題：因為typescript提供了靜態型別檢查，在編譯的時候就可以檢查到！尤其是打錯字的問題和型別不一致的問題。 typescript新增了一些型別，讓我們可以宣告靜態型別。也保留了原本動態型別的特性，只要你設為any！。 function 也可以使用冒號設定回傳值。 module 類似namespace的存在，裡面可以包其他module、interface、class、function… garbage collection(回收)是執行時期做的，只要參考的技術器是0的話，javascript就會自動回收他 其他Excelsior: [Java] 淺談 call by value 和 call by reference","link":"/2015/03/08/old%20posts/2015-03-08-typescript-is-newbies-good-friend/"},{"title":"SASS 的 @import @mixin @content @extend 與 @function","text":"1.ImportSASS在檔名前面加上底線時，不會直接編譯成CSS，使用@import引入後，才會編譯。 2. Mixins常見的mixin作法，要傳入的引數前面需加上$字號。 12345678910/* Mixins */@mixin border-radius($radius: 10px) { -webkit-border-radius: $radius; -moz-border-radius: $radius; border-radius: $radius;}@mixin large-font { font-size: 200%;} 使用時，輸入@include mixins_name即可引入CSS程式碼。 nested mixinmixin中也可以＠include mixin 1234@mixin hero-unit { @include border-radius; @include large-font;} 實際來用用看 1234567.box { @include hero-unit;}.container { @include border-radius(5px);} 撰寫可以傳入不定數量引數(arguments)的mixin使用$args...作為參數就可以傳入不定數量的arguments。 123456/* Mixins with variable arguments... */@mixin box-shadow($args...) { -webkit-box-shadow: $args; -moz-box-shadow: $args; box-shadow: $args;} 現在你可以用@include mixin來節省程式碼了:D 123.box-2 { @include box-shadow(0 0 3px #333, inset 5px 5px 5px red);} 3. content@content 的功用讓mixin可以撰寫自定的程式碼 4. Functions@function與@mixin的不同之處在於@function只會回傳一個值，而@mixin是回傳一段CSS程式碼。宣告Function時以@function開頭： 123@function pxToEm($px, $base: 16) { @return ($px / $base) * 1em;} 使用Function時前面不需要加上@。 123p{ font-size:pxToEm(20);} 編譯後 123p { font-size: 1.25em;} 結論幾點需要注意： @import用來引入開頭為底線的SCSS檔案。如：_layout.scss。 mixin可以傳入配變數，使用時語法為@include mixins_name使用。 mixin搭配@content使用，讓mixin可以輸入自定的程式碼。 @extend用來讓重複的程式碼只需要撰寫一次，裡面不可以傳入變數。 function使用時不需加上@，不熟悉的話可能會與CSS原本的property搞錯，需要特別注意。 有了這些基本知識就可以進一步的學習SASS與Compass了！","link":"/2015/06/01/old%20posts/2015-06-01-sass/"},{"title":"使用 SMACSS 製作button","text":"module抽離出常用元件，負責大致的外觀SMACSS是Jonathan Snook所發表的一個CSS/SASS的設計模式。在製作button時我們會把它放在module資料夾底下，並存成檔名為_btn.scss。在modules資料夾中的_btn.scss裡面撰寫Button的外觀，需要注意的是不包含顏色和其他特效。這樣是為了將顏色和細部調整放到之後的_theme.scss檔案中做調整。為什麼要這樣做呢？這樣做可以在有多個佈景主題的時候很方便的切換。也比較知道現在在這個檔案我要做哪些事情。不會一堆css碼做了什麼事情要一一去解讀。 modules/_btn.scss負責大致上的外觀 123456789101112.btn { display: inline-block; height: 3rem; padding: 0 1rem; outline: none; border: 1px solid; font-size: 1.125rem; @include border-radius(3px);} 完成圖片 theme負責顏色、陰影…等佈景主題需要的修飾在theme/_theme.scss中將按鈕的顏色、陰影效果、hover效果補上。因為主題可能有多個，所以我們抽離出來撰寫。以後想要加上別的主題的時候CSS碼就步會搞的很混亂。 123456789101112131415161718192021222324252627282930313233343536373839404142/* Buttons */.btn { background-color: $color-1; color: $color-text; border-color: darken($color-1, 20%); @include box-shadow(0 -2px 0 0 darken($color-1, 20%) inset); &amp;:hover { background-color: darken($color-1, 5%); }}.btn-primary { background-color: $color-link; color: #fff; border-color: darken($color-link, 20%); @include box-shadow(0 -2px 0 0 darken($color-link, 20%) inset); &amp;:hover { background-color: darken($color-link, 5%); }}.btn-secondary { background-color: $color-2; color: #fff; border-color: darken($color-2, 20%); @include box-shadow(0 -2px 0 0 darken($color-2, 20%) inset); &amp;:hover { background-color: darken($color-2, 5%); }} 使用的技巧有 利用box-shadow來製造陰影效果 box-shadow的顏色使用compass的darken函式來完成。使用方法是darken($color-2, 5%)，第一個參數是要跟黑色混和的顏色，第二個參數是要混和的比例。 完成畫面","link":"/2015/06/03/old%20posts/2015-06-03-making-a-button-by-using-sass/"},{"title":"練習：使用SASS開發Portfolio (1) Header 與 Footer","text":"標題列(Header)固定的標題 往下捲動時仍然會固定在上方 幫header加上position: fixed可以做到這個效果。透明的效果則是使用background: rgba(0, 0, 0, 0.8)。 標題列的水平置中這邊使用的水平置中技巧是使用CSS 垂直置中的3種方法中的**設定行高(line-height)**的方法。 而行高我們可以在_typography.scss中統一設置，typography.scss顧名思義就是用來處理一些排版的問題，常見的設定有body、anchor、paragraph和header等等常用到的東西。如果沒有使用scss的習慣，可以利用註解區隔出一個專門處理排版的區域。 123456body { color: $color-text; font: $body-font-size~&quot;/&quot;$baseline $body-font; -webkit-font-smoothing: antialiased;} font 的使用方法可以看看CSS官方文件 12/* Set the font size to 12px and the line height to 14px. Set the font family to sans-serif */p { font: 12px/14px sans-serif } 第一個欄位為font-size，而第二個則為行高。但其實我們不是完全的利用行高來達成，還有設定header的padding來幫助我們實現置中。因為要置中的不全部是文字，還有其他的元素例如ul需要考慮。 Footer重疊效果製作我們要把信封圖案置中並且讓信封圖案在背景的中間。還未做任何修飾的時候如下：要怎麼做重疊的效果呢？很簡單，把下方的.section-subscribe加上負的margin即可。 123.section-subscribe{ margin-top: -18px;} 加上後的效果如下： 讓段落置中我想讓段落分行並置中，所以我要做兩件事情：第一件事情是我要設定段落的寬度為65%第二件事情我要利用margin來讓段落置中。想要做到的效果： 1234567.section-subscribe{ p{ margin: 0 auto; color: #fff; width: 65%; }} 需要注意是display為block才能使用margin:auto的方式置中。","link":"/2015/06/04/old%20posts/2015-06-04-psd-to-html-practice-using-sass-development-portfolio/"},{"title":"Ruby中冒號開頭Symbol與&amp;:to_s用法解釋","text":"本篇介紹Ruby中特有的寫法，將解答&amp;:to_s和:symbol這兩種寫法的意義。並依序介紹以下議題： Symbol和String的不同之處分別宣告兩個symbol與string。 12345678[22] pry(main)&gt; sym = :abc=&gt; :abc[23] pry(main)&gt; str = &quot;abc&quot;=&gt; &quot;abc&quot;[24] pry(main)&gt; sym2 = :abc=&gt; :abc[25] pry(main)&gt; str2 = &quot;abc&quot;=&gt; &quot;abc&quot; 用object_id來看看是否為同一個物件。從下面結果可以發現，在參照同樣的symbol:abc時，不同的變數參考的是同一個物件。而String參考的物件是不同的。 123456789[26] pry(main)&gt; sym.object_id=&gt; 1172168[28] pry(main)&gt; sym2.object_id=&gt; 1172168[29] pry(main)&gt; str.object_id=&gt; 70232488314360[30] pry(main)&gt; str2.object_id=&gt; 70232505015640[31] pry(main)&gt; all_symbols 與 include? 搭配運用在終端機輸入Symbol.all_symbols可以列出目前所有的Symbol。 123456789101112131415161718192021222324252627[34] pry(main)&gt; Symbol.all_symbols=&gt; [:freeze, :inspect, :intern, :object_id, :const_missing, :method_missing, :method_added, :singleton_method_added, :method_removed, :singleton_method_removed, :method_undefined, :singleton_method_undefined, :length, :size, :gets, :succ, :each, :proc, :lambda, :send, :__send__, :__attached__, :initialize, . . . 我們把用all_symbols取出的陣列用變數symbols存起來。這樣我們就可以用include?來檢查某個symbol是否已經宣告。 1234567[23] pry(main)&gt; all_symbols.include?(:sym)=&gt; true# :sym是系統預設的所以顯示true[24] pry(main)&gt; all_symbols.include?(:abc)=&gt; false# :abc是我亂輸入的所以顯示false[25] pry(main)&gt; &amp;:to_s的用法與原理以下兩個寫法效果相同，:代表一個Symbol，當Symbol遇上&amp;符號時，會把to_s方法轉變為proc，而是否能轉變為proc則是看Class中有沒有to_proc方法，這是ruby中的duck typing特性所致。我會另外寫一篇來說明duck typing是如何運作。 1234[72] pry(main)&gt; [1,2,3,4].map(&amp;:to_s)=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;][73] pry(main)&gt; [1,2,3,4].map{|i| i.to_s}=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;] String、Symbol和Integer的互相轉換Symbol可以轉換成String 12[74] pry(main)&gt; :a.to_s=&gt; &quot;a&quot; String可以轉換成Symbol 12[75] pry(main)&gt; &quot;a&quot;.to_sym=&gt; :a Fixnum(數字的類別)不能轉換成Symbol，會出現錯誤。 123[76] pry(main)&gt; 1.to_symNoMethodError: undefined method `to_sym' for 1:Fixnumfrom (pry):98:in `__pry__' 參考資料誘人的ruby-符號篇","link":"/2015/07/16/old%20posts/2015-07-16-ruby-colons-at-the-beginning-of-the-variable-symbol/"},{"title":"Atom殺手級套件介紹","text":"這次來介紹兩個殺手級套件，以及其他的輔助的畫面跳躍套件來完善atom快速鍵不足的地方。 jumpy運用他你可以快速的跳躍到畫面中程式的任何一個地方，只需按下shift + enter。 如果你使用atom-Material-UI這個套件的話可能畫面會變得像這樣。 這時候在選單列選擇 atom &gt; open your style sheet，加入以下內容，即可改善。 123456789atom-text-editor::shadow .jumpy { &amp;.label { opacity: 0.75; color: black; font-weight: bold; } &amp;.jump { }} 完成畫面如下。已經修好了！ 你也可以編寫自己喜歡的樣式。enjoy it! multi-cursor接下來介紹第二個殺手級應用multi-cursor，這個套件用的人不多，但是我覺得非常的實用。按下alt + shift + cmd + up or down就等於用滑鼠一一點擊多行，同時新增相同的內容。 基礎篇沒有提到「垂直跳躍」垂直跳躍可以使用幾個套件來達到。第一個介紹的套件是Indentation Jumper，他的效果是在同樣位置的開頭中跳躍。 另一個介紹的套件是line-jumper。按下alt + up or down就可以跳躍10行，行數可以依照個人喜好調整。 配合之前基礎篇介紹的alt+left or right和cmd + left or right可以應付絕大多數寫程式需要的情況。 小結這篇是atom快速上手系列的第二篇，看完本篇與基礎篇之後已經能應付大多數的情況。第三篇會介紹的是如何使用Key Binding Resolver觀察快速鍵，並進而修改成自己慣用的快速鍵。","link":"/2015/07/22/old%20posts/2015-07-22-introduce-atoms-killer-packages/"},{"title":"Demo：使用Matirialize框架實現視差滾動","text":"完成品展示頁 Materialize 是除了 Bootstrap 以外現今相當熱門的前端框架，可以製作的網頁類型相當廣泛，未來將使用 Materialize 來開發一些小作品，是今天練習的主要目的。 實現Materialize框架提供的視差滾動效果視差滾動的效果由materialize提供的Parallax JS 套件來完成，效果可以讓圖片滿板，並且有視差效果。步驟如下： 自行撰寫.parallax-container包覆需要跟圖片有視差效果的區域。 第二層的最下方加上.parallax並包覆圖片即可完成視差效果。 123456&lt;section class=&quot;slogan-section margin-bottom parallax-container valign-wrapper &quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;h3 class=&quot;center-align slogan-description&quot;&gt;A modern responsive front-end framework based on Material Design&lt;/h3&gt; &lt;/div&gt;&lt;!-- container --&gt; &lt;div class=&quot;parallax&quot;&gt;&lt;img src=&quot;images/background2.jpg&quot; alt=&quot;Unsplashed background img 2&quot;&gt;&lt;/div&gt;&lt;/section&gt;&lt;!-- slogan --&gt; 12345678.parallax-container { min-height: 380px; line-height: 0; height: auto; color: rgba(255,255,255,.9); position: relative; overflow: hidden;} 其他學習記錄 一般區塊的垂直置中使用materialize的valign-wrapper來達到垂直置中的效果。 Footer使用width+line-height的垂直置中技巧。垂直置中的對象必須是外層的footer.copyright，包在container裡面會造成多餘的空白。 修飾某些元件時除了class名稱以外，需加上元件名稱，來解決沒有蓋過原本framework的CSS的問題。例如：使用.footer-copyright無法順利設定背景顏色，但若改成footer.footer-copryright則可以順利完成。 如果有以下的突出狀況，可以加上overflow: hidden;即可解決。","link":"/2015/10/12/old%20posts/2015-10-12-practice-using-the-matirialize-framework-parallax-scrolling/"},{"title":"HTTP Status Code In Rails","text":"Rails將這些HTTP Status定義成有意義的單字。讓我們可以在使用的時候減少因為背錯而發生錯誤的機率。 使用方式用symbol加上單字即可取代原本的HTTP Status Code(500) 12render status: 500render status: :forbidden 這些Symbol其實定義在Rack中原始碼 rack/utils.rb 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970HTTP_STATUS_CODES = {# Informational 100 =&gt; 'Continue', 101 =&gt; 'Switching Protocols', 102 =&gt; 'Processing',# Success 200 =&gt; 'OK', 201 =&gt; 'Created', 202 =&gt; 'Accepted', 203 =&gt; 'Non-Authoritative Information', 204 =&gt; 'No Content', 205 =&gt; 'Reset Content', 206 =&gt; 'Partial Content', 207 =&gt; 'Multi-Status', 208 =&gt; 'Already Reported', 226 =&gt; 'IM Used',# Redirection 300 =&gt; 'Multiple Choices', 301 =&gt; 'Moved Permanently', 302 =&gt; 'Found', 303 =&gt; 'See Other', 304 =&gt; 'Not Modified', 305 =&gt; 'Use Proxy', 307 =&gt; 'Temporary Redirect', 308 =&gt; 'Permanent Redirect',# Client Error 400 =&gt; 'Bad Request', 401 =&gt; 'Unauthorized', 402 =&gt; 'Payment Required', 403 =&gt; 'Forbidden', 404 =&gt; 'Not Found', 405 =&gt; 'Method Not Allowed', 406 =&gt; 'Not Acceptable', 407 =&gt; 'Proxy Authentication Required', 408 =&gt; 'Request Timeout', 409 =&gt; 'Conflict', 410 =&gt; 'Gone', 411 =&gt; 'Length Required', 412 =&gt; 'Precondition Failed', 413 =&gt; 'Payload Too Large', 414 =&gt; 'URI Too Long', 415 =&gt; 'Unsupported Media Type', 416 =&gt; 'Range Not Satisfiable', 417 =&gt; 'Expectation Failed', 421 =&gt; 'Misdirected Request', 422 =&gt; 'Unprocessable Entity', 423 =&gt; 'Locked', 424 =&gt; 'Failed Dependency', 426 =&gt; 'Upgrade Required', 428 =&gt; 'Precondition Required', 429 =&gt; 'Too Many Requests', 431 =&gt; 'Request Header Fields Too Large',# Server Error 500 =&gt; 'Internal Server Error', 501 =&gt; 'Not Implemented', 502 =&gt; 'Bad Gateway', 503 =&gt; 'Service Unavailable', 504 =&gt; 'Gateway Timeout', 505 =&gt; 'HTTP Version Not Supported', 506 =&gt; 'Variant Also Negotiates', 507 =&gt; 'Insufficient Storage', 508 =&gt; 'Loop Detected', 510 =&gt; 'Not Extended', 511 =&gt; 'Network Authentication Required'} 還是不知道從何下手記憶嘛？來看保哥已經整理好一篇完整的HTTP Status Code文章囉^^ The Will Will Web 網頁開發人員應了解的 HTTP 狀態碼","link":"/2015/10/10/old%20posts/2015-10-10-http-status-code-in-rails/"},{"title":"Landing Page 實作：來做個簡單的Jumbotron","text":"製作jumbotron有兩個重點 垂直置中 設定背景。 Background 設定position: center bottom讓圖片顯示出需要的區塊 使用background-size: cover;讓圖片滿版 1234567891011section.intro{ padding: $baseline * 2; background-image: url('../images/intro-bg.jpg') ; background-position: center bottom; height: 100%; width: 100%; -moz-background-size :cover ; -webkit-background-size :cover ; background-size: cover; background-attachment: scroll;} 複習背景的用法背景的屬性： background-repeat，常用的是no-repeat background-attachment，有fixed和scroll兩種，fixed圖片不會動，只有轉的空間會動。 background-position left 為水平靠左， right 為水平靠右， top 為垂直置頂， bottom 為垂直置底center 則是水平或垂直都置中。 前後需設定兩組，若是數字或百分比前為水平後為垂直，若是關鍵字則順序無關，例如 1234background-position: 25% 50%; /* 水平 25% ，垂直 50% */background-position: 50px 25px; /* 水平 50px ，垂直 25px */background-position: center; /* 水平垂直都 50% */background-position: bottom right; /* 水平 100% ，垂直 100% */ 使用Table-cell水平置中 外層display設成table 內層display設成table-cell，並加上vertical-align: middel即可 這種方法的優點是用起來很簡單，缺點是會增加html複雜度。 123456789101112&lt;section class=&quot;intro&quot;&gt; &lt;div class=&quot;intro-body&quot;&gt; &lt;div class=&quot;container t-padding&quot;&gt; &lt;div class=&quot;row text-center&quot;&gt; &lt;div class=&quot;col-md-8 col-md-offset-2&quot;&gt; &lt;h1&gt;welcome&lt;/h1&gt; &lt;h3&gt;&lt;strong&gt;Digital Agency&lt;/strong&gt; is here all of your technology, advertising, SEO and marketing needs.&lt;/h3&gt; &lt;/div&gt;&lt;!-- col-md-8 offset-2 --&gt; &lt;/div&gt;&lt;!-- row --&gt; &lt;/div&gt;&lt;!-- container --&gt; &lt;/div&gt;&lt;!-- intro-body --&gt;&lt;/section&gt;&lt;!-- intro --&gt; 12345678.intro{ display: table;}.intro-body{ display: table-cell; vertical-align: middle;} 置中小整理 table-cell可以用在jumbotron這種結構較單純的區塊上，因為使用這種方式會增加html的複雜度。 單行多個置中可以使用偽元素的技巧 css3的技巧雖然很方便，但支援度可以能沒那麼高。 行高的技巧簡單易用，但只能用在文字上。","link":"/2015/10/19/old%20posts/2015-10-19-dynamic-landing-page-1-jumbotron-make/"},{"title":"使用Github展示靜態網頁","text":"這篇很簡短，但還是筆記一下怎麼用，因為網路上找的資料有點繁雜。 原理github的gh-pages分支可以用來展示靜態網頁，推上去就可以正確展示了。 步驟 建立新的branchgit branch gh-pages 推上githubgit push origin gh-pages 需要注意的是首頁要命名為index.html 到[github name].github.io/[repository name]網址查看，你的網頁已經展示在這個網址。","link":"/2015/10/12/old%20posts/2015-10-12-use-github-show-static-pages/"},{"title":"Demo：使用scrollspy讓畫面更生動","text":"Demo展示頁 作法說明1.幫body加工將body加上display: relative，如果還是不行使用的話加上width: 100%與height: 100%。 123display: relative;width: 100%;height: 100%; 2. 宣告navbar並設定target使用js宣告target，這次我使用的target是整個navbar，用.navbar-custom來指定之，有需要的話可以調整offset修正navbar的觸發情形。 123456$(document).ready(function(){ $(&quot;body&quot;).scrollspy({ target: &quot;.navbar-custom&quot;, offset: 370 })}); 12345678nav class=&quot;navbar navbar-default navbar-custom navbar-fixed-top&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;container&quot;&gt; . . . &lt;/div&gt;&lt;!-- /.container --&gt;&lt;/nav&gt; 3. 設定個區塊的id，並關聯到導覽列的連結每個區塊設定id，例如： 12345&lt;section class=&quot;client t-padding&quot; id=&quot;clients&quot;&gt;...&lt;/section&gt; 幫導覽列的連結加上href=&quot;#id&quot; 12345678&lt;div id=&quot;navbar&quot;class=&quot;collapse navbar-collapse navbar-right navbar-main-collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav &quot;&gt; &lt;li class=&quot;page-scroll&quot;&gt;&lt;a href=&quot;#why&quot;&gt;why us?&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-scroll&quot;&gt;&lt;a href=&quot;#who&quot;&gt;who are we?&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-scroll&quot;&gt;&lt;a href=&quot;#clients&quot;&gt;clients&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-scroll&quot;&gt;&lt;a href=&quot;#contact&quot;&gt;contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; Bonus. 自行撰寫點擊導覽列連結就可以緩緩移動的JS將li加上.page-scroll的屬性，以便之後選取。 123456789&lt;div id=&quot;navbar&quot;class=&quot;collapse navbar-collapse navbar-right navbar-main-collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav &quot;&gt; &lt;li class=&quot;page-scroll&quot;&gt;&lt;a href=&quot;#why&quot;&gt;why us?&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-scroll&quot;&gt;&lt;a href=&quot;#who&quot;&gt;who are we?&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-scroll&quot;&gt;&lt;a href=&quot;#clients&quot;&gt;clients&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;page-scroll&quot;&gt;&lt;a href=&quot;#contact&quot;&gt;contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; 當點擊到連結時，畫面會垂直位移到相對硬的區塊。 1234567$('.page-scroll &gt; a').click(function(){ var $anchor = $(this); $('html, body').stop().animate({ scrollTop: $($anchor.attr('href')).offset().top-100 }, 1500, 'easeInOutExpo'); event.preventDefault();}); 加上CSS的轉場效果，讓效果更漂亮。 12345678.page-scroll{ -moz-transition-property: -webkit-transform ; -webkit-transition-property: -webkit-transform; transition-property: -webkit-transform; transition-duration: 1s; -moz-transition-duration: 1s; -webkit-transition-duration: 1s; } 參考連結JavaScript · Bootstrap How to Create Bootstrap 3 Scrollspy - Tutorial Republic","link":"/2015/10/19/old%20posts/2015-10-19-landing-page-implements-a/"},{"title":"Demo：實作捲動觸發CSS動畫","text":"demo 第一部分：使用CSS撰寫Slide In效果這個單元使用的技巧有： 使用transition讓屬性值改變時有動畫的效果 使用animation-fill-mode設定結束狀態 使用transform:translate移動元素 1. 使用transition讓屬性值改變時有動畫的效果transition 可以將CSS改變的過程變成動畫。詳細玩一下CSS3 Transitions就懂了。 2. 使用animation-fill-mode設定結束狀態animation-fill-mode 結束後的狀態 none：默认值。不设置对象动画之外的状态 forwards：结束后保持动画结束时的状态，但当animation-direction为0，则动画不执行，持续保持动画开始时的状态 backwards：结束后返回动画开始时的状态 both：结束后可遵循forwards和backwards两个规则。 3. 使用transform:translate移動元素使用transform: translate(x,y)來移動元素。其他常用的還有： rotate(-20deg) 用來旋轉元素 scale(x,y) 等比例放大或縮小元素 可以到W3C Scholl玩玩看CSS3 2D Transforms 程式碼(CSS部分)123@-webkit-keyframes fadeIn { from { opacity:0; } to {opacity: 1;} }@-moz-keyframes fadeIn { from { opacity:0; } to {opacity: 1;} }@keyframes fadeIn { from { opacity:0; } to {opacity: 1;} } 1234567891011121314151617.animate{ -moz-transition: 2s ease-in-out; -webkit-transition: 2s ease-in-out; transition: 2s ease-in-out; -moz-animation: fadeIn ease-in 1; -webkit-animation: fadeIn ease-in 1; animation: fadeIn ease-in 1; -webkit-animation-fill-mode: forwards; -webkit-animation-fill-mode: forwards; animation-fill-mode: forwards; -webkit-animation-duration: 1s; -moz-animation-duration: 1s; animation-duration: 1s;} 1234567891011#phone.animate { -webkit-transform: translate(14em,0); -moz-transform: translate(14em,0); transform: translate(14em,0);}#monitor.animate { -webkit-transform: translate(3em,0); -moz-transform: translate(3em,0); transform: translate(3em,0);} 程式碼(JS部分)用簡單的addClass方法即可完成。 1234567891011121314$(function () { $(window).scroll(function () { var y = $(this).scrollTop(); if (y &gt; 300) { $('#monitor').addClass('animate'); $('#phone').addClass('animate'); }; . . . });}); 第二部分：使用CSS讓圖片永久旋轉keyframe:用來編寫這個動畫的過程。設定好旋轉的動作命名為rotaRadial。 1234567891011121314151617@-webkit-keyframes rotateRadial { from { -webkit-transform: rotate(0deg); } to { -webkit-transform: rotate(360deg); }}@keyframes rotateRadial { from { transform: rotate(0deg); } to { transform: rotate(360deg); }} 設定幾個參數來達到我們要的效果： 動畫名稱指定剛剛創造的keyframe名稱rotateRadial。 完成一次動畫的時間設為10s秒。 永不停止。animation-iteration-count: infinite; 將動畫轉變的加速曲線設為線性。animation-timing-function: linear; 1234567891011.always-rotate{ -webkit-animation-name: rotateRadial; -webkit-animation-duration: 10s; -webkit-animation-iteration-count: infinite; -webkit-animation-timing-function: linear; animation-name: rotateRadial; animation-duration: 10s; animation-iteration-count: infinite; animation-timing-function: linear;} 第三部分：讓圖片變大原本圖片的大小，設成0。 12345.anim-img{ position: absolute; left: 0; opacity: 0;} 後來圖片的大小 1234img.grow-img{ width: 200px; height: 200px;} 用.animate設定了transition，因此會有動畫效果。 1234567891011121314151617$(function () { $(window).scroll(function () { var y = $(this).scrollTop(); if (y &gt; 300) { $('#monitor').addClass('animate'); $('#phone').addClass('animate'); }; if(y &gt; 400){ $('#support').find('img').addClass('animate grow-img'); $('#speed').find('img').addClass('animate grow-img'); $('#smart').find('img').addClass('animate grow-img'); }; });}); 參考連結大量範例展示CSS動畫可以做到的效果。 Transitions &amp; Animations - Learn to Code Advanced HTML &amp; CSS MDN 的 CSS 動畫說明頁，有不少的範例可以玩。 CSS 動畫 MDN 中文版的CSS字典 CSS参考手册_web前端开发参考手册系列","link":"/2015/10/20/old%20posts/2015-10-20-demo-implemented-scrolling-trigger-the-css-animation/"},{"title":"Demo：使用wow.js快速打造捲動式動畫網頁","text":"我用兩個不同方法個別製作出網站來讓大家比較看看： 純CSS打造捲動式動畫網站wow.js打造的捲動式動畫網站 接著來介紹這wowjs的製作方法與其優缺點。 使用方法：第一步要做的是animate.css與wow.js載進網頁中。接著幫要使用動畫的部份加上.wow .animate動畫名稱屬性。wow.js用來負責偵測捲動到的位置，animate.css用來決定呈現的動畫。 HTML 12&lt;section class=&quot;wow slideInLeft&quot;&gt;&lt;/section&gt;&lt;section class=&quot;wow slideInRight&quot;&gt;&lt;/section&gt; JavaScript 1new WOW().init(); 就是這麼簡單。還有其他客製化的設定，不過彈性也不大，使用最基本的功能cp值最高。 跟手工打造的CSS動畫的不同 wow.js + animate.css易於撰寫但彈性不大。 wow.js + animate.css 製作的動畫位置是預先設定好的。不能移動也不能重疊。 使用純CSS需要撰寫兩份CSS，一份是改變前的狀態，一份是改變後的狀態。而使用 wow.js + animate.css 只需要撰寫結束後的狀態，只要在div加上.wow與.slideInLeft等等的動畫名稱即可完成。撰寫的CSS少了許多。 結論wow.js + animate.css 能夠打造的捲動式動畫角色很鮮明。但是彈性不大。如果要更加生動的畫面還是得自己設計CSS。 參考資料Animate.cssmatthieua/WOW","link":"/2015/10/22/old%20posts/2015-10-22-use-wowjs-to-quickly-create-scrolling-animation/"},{"title":"從 Tealeaf 課程學習模組化 - Sluggify Module","text":"因為 Post 與 Category 都的網址都需要 Sluggify 以便 SEO 的進行。所以我們把 Sluggify 模組化，讓同樣的程式碼只要寫一次就好。 1. 建立module Sluggable，並引入之在lib資料夾中建立一個名為sluggable.rb的檔案。加入extend ActiveSupport::Concern，這個技巧會讓模組間的耦合變得更加簡單。而一個class載入Sluggable時，會先做完include區塊中寫下的事情。 1234567module Sluggable extend ActiveSupport:Concern include do endend 打開config/application.rb加入路徑config.autoload_paths &lt;&lt; Rails.root.join('lib') 還有另一個方法把rb檔initializers中，放在這個資料夾裡面代表app打開初始化時就會先跑過一遍。 2. 跟sluggify有關的方法通通搬過來接著我們要把原本model(post.rb,category.rb)跟sluggify有關的方法搬過來。 把after_validation :generate_slug!放在include區塊。 其他方法貼進model中。 這樣會出現幾個問題，接下來的步驟會解決他們並且解釋之。 12345678910111213141516171819202122232425262728293031323334353637module Sluggable extend ActiveSupport::Concern # executes this code when included only once included do after_validation :generate_slug! end def generate_slug the_slug = to_slug(title) post = Post.find_by slug: the_slug count = 2 while post &amp;&amp; post != self the_slug = append_suffix(the_slug, count) post = Post.find_by slug: the_slug count += 1 end self.slug = str.downcase end def append_suffix(_the_slug, count) if str.split('-').last.to_i != 0 return str.split('-').slice(0...-1).join('-') + '-' + count.to_s else return str + '-' + count.to_s end end def to_slug(name) str = name.strip str.gsub! /\\s*[^A-Za-z0-9]\\s*/, '-' # 將符號轉成&quot;-&quot; str.gsub! /-+/, '-' # 將多個&quot;-&quot;轉成一個&quot;-&quot; str endend 3. class_attribute特性新增屬性到model上因為post與category所要轉換成網址的欄位一個是title、一個是name。所以我們必須想個方法讓module至換掉原本設定the_slug的這一行： 1234567def generate_slug the_slug = to_slug(title) . . .end class_attribute這個ruby語言獨有的特性可以幫助我們解決這個問題，簡單的說class_attribute可以讓屬性繼承給子class使用。所以我們先在剛剛建立的模組sluggable.rb中加入 1234include do before_save :generates_slug! class_attibute :slug_columnend 接著在post.rb中加入 這樣一來就可以使用post.slug_column這個新的變數。 4. 新增類別方法sluggable_cloumn讓model能夠初始化slug_column12345678910module Sluggable . . . module ClassMethods def sluggable_column(col_name) self.slug_column = col_name end endend 在Post中呼叫剛剛建立的sluggable_column方法，把title設成slug_column。 123456789class Post . . sluggable_column :title . .end 5. 置換欄位123456def generate_slug the_slug = to_slug(title) . . .end 置換成 123456def generate_slug the_slug = to_slug(self.send(self.class.slug_column.to_sym)) . . .end 這句是什麼意思呢？以Post為例來解析一下它的意思 self.class就是Post，所以變成了self.send(Post.slug_column.to_sym) Post.slug_column我們在post中設定成slug_column: title所以變成了self.send(&quot;title&quot;.to_sym) title字串轉成symbol，變成self.send(:title) self我們可以想像成一個新增的post物件post=Post.new，置換後post.send(:title) post.send(:title)就等同於post.(:title)就等同於post.title，我們成功的呼叫了post.title屬性！ 6. 有了the_slug之後我們就可以來置換post與Post Post用self.class來取代 post用obj來取代 =&gt; obj = self.class.find_by slug: the_slug 12345678910111213def generate_slug! the_slug = to_slug(self.send(self.class.slug_column.to_sym)) I obj = self.class.find_by slug: the_slug count = 2 while obj &amp;&amp; obj != self the_slug = append_suffix(the_slug, count) obj = self.class.find_by slug: the_slug count += 1 end self.slug = the_slug.downcase # self.slug = self.title.sub(&quot; &quot;,&quot;-&quot;).downcase # prefer the following # self.slug = self.title.parameterize # rails way without gemend 7. 完成品lib/slugabble.rb 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748module Sluggable extend ActiveSupport::Concern # executes this code when included only once included do after_validation :generate_slug! class_attribute :slug_column end def generate_slug! the_slug = to_slug(self.send(self.class.slug_column.to_sym)) obj = self.class.find_by slug: the_slug count = 2 while obj &amp;&amp; obj != self the_slug = append_suffix(the_slug, count) obj = self.class.find_by slug: the_slug count += 1 end self.slug = the_slug.downcase # self.slug = self.title.sub(&quot; &quot;,&quot;-&quot;).downcase # prefer the following # self.slug = self.title.parameterize # rails way without gem end def append_suffix(str, count) if str.split('-').last.to_i != 0 return str.split('-').slice(0...-1).join('-') + '-' + count.to_s else return str + '-' + count.to_s end end def to_slug(name) str = name.strip str.gsub! /\\s*[^A-Za-z0-9]\\s*/, '-' str.gsub! /-+/, '-' str.downcase end def to_param self.slug end module ClassMethods def sluggable_column(col_name) self.slug_column = col_name end endend Post.rb 12345678class Post &lt; ActiveRecord::Base include Sluggable has_many :post_categories has_many :categories, through: :post_categories has_many :comments sluggable_column :titleend","link":"/2015/11/02/old%20posts/2015-11-02-tealeaf-course-2-sluggify-module/"},{"title":"CSS排版技巧 - 文繞圖","text":"文繞圖先看效果，這次要做的是文繞圖技巧，可以選擇靠左或靠右。 html結構圖片(img)必須在段落(p)的上面，當圖片加上float:left屬性時，圖片的空間會消失，變成浮在畫面上，利用這個技巧，我們來做到文繞圖的效果。 123&lt;div class=&quot;image-container&quot;&gt; &lt;img class=&quot;image1&quot; src=&quot;http://zh-tw.learnlayout.com/images/ilta.png&quot; alt=&quot;&quot;/&gt; &lt;p class=&quot;pp1&quot;&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley o.......(略)&lt;/p&gt; 完整範例 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .image-container{ max-width: 60%; margin: 0 20%; } .image1{ float: right; } .image2{ float: left; margin-right: 20px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;image-container&quot;&gt; &lt;img class=&quot;image1&quot; src=&quot;http://zh-tw.learnlayout.com/images/ilta.png&quot; alt=&quot;&quot;/&gt; &lt;p class=&quot;pp1&quot;&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum. Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.&lt;/p&gt; &lt;img class=&quot;image2&quot; src=&quot;http://zh-tw.learnlayout.com/images/ilta.png&quot; alt=&quot;&quot; /&gt; &lt;p class=&quot;pp2&quot;&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum. Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.&lt;/p&gt; &lt;/div&gt;&lt;!-- image-container --&gt;&lt;/body&gt;&lt;/html&gt; 容器水平置中是使用把最大寬度設成60%，並使用margin:auto技巧。 想要分段的時候用div包起來並加上.clear-fix如果段落(p)高比圖片(img)小的時候會出現這樣的情況。有時候我們想要段落分明，這時候使用div包覆並幫div加上.clear-fix。 加完之後的效果，圖片一已經展開了一個長方形的空間。 完整範例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .image-container{ max-width: 60%; margin: 0 auto; } .image1{ float: right; clear:right; } .image2{ float: left; margin-right: 20px; } .image1-wrapper{ border: 3px dashed black; } .clear-fix{ overflow: auto; zoom: 1; } @media screen and (max-width: 767px) { .image-container { background-color: lightgreen; max-width: 100%; } } &lt;/style&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styke.css&quot; media=&quot;all&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;image-container&quot;&gt; &lt;div class=&quot;clear-fix image1-wrapper&quot;&gt; &lt;img class=&quot;image1&quot; src=&quot;http://zh-tw.learnlayout.com/images/ilta.png&quot; alt=&quot;&quot;/&gt; &lt;p class=&quot;pp1&quot;&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type&lt;/p&gt; &lt;p class=&quot;pp1&quot;&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type&lt;/p&gt; &lt;/div&gt;&lt;!-- clear-fix --&gt; &lt;img class=&quot;image2&quot; src=&quot;http://zh-tw.learnlayout.com/images/ilta.png&quot; alt=&quot;&quot; /&gt; &lt;/div&gt;&lt;!-- image-container --&gt;&lt;/body&gt;&lt;/html&gt; 幫段落左邊加上斷行效果用clear:left這次段落和img的html是： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .image-container{ max-width: 60%; margin: 0 auto; } .image1{ float: right; clear:right; } .image2{ float: left; margin-right: 20px; } .image1-wrapper{ border: 3px dashed black; } .clear-fix{ overflow: auto; zoom: 1; } @media screen and (max-width: 767px) { .image-container { background-color: lightgreen; max-width: 100%; } } &lt;/style&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styke.css&quot; media=&quot;all&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;image-container&quot;&gt; &lt;img class=&quot;image2&quot; src=&quot;http://zh-tw.learnlayout.com/images/ilta.png&quot; alt=&quot;&quot; /&gt; &lt;p class=&quot;pp2&quot;&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type&lt;/p&gt; &lt;/div&gt;&lt;!-- image-container --&gt;&lt;/body&gt;&lt;/html&gt; 呈現的效果： 幫段落(p)加上clear:left後： 程式碼 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; .image-container{ max-width: 60%; margin: 0 auto; } .image1{ float: right; } .image2{ float: left; margin-right: 20px; } .image1-wrapper{ border: 3px dashed black; } .clear-fix{ overflow: auto; zoom: 1; } .pp2{ clear: left; } @media screen and (max-width: 767px) { .image-container { background-color: lightgreen; max-width: 100%; } } &lt;/style&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styke.css&quot; media=&quot;all&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;image-container&quot;&gt; &lt;img class=&quot;image2&quot; src=&quot;http://zh-tw.learnlayout.com/images/ilta.png&quot; alt=&quot;&quot; /&gt; &lt;p class=&quot;pp2&quot;&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type&lt;/p&gt; &lt;/div&gt;&lt;!-- image-container --&gt;&lt;/body&gt;&lt;/html&gt; 結論 加上 float 屬性之後在空間會受到外部 .image-wrapper 的限制。 然而對同層元素來說，設成 float 的 img 空間會消失，因此在float img 下方的同層元素會直接浮上來，空間跟下方的同層元素共用，內容卻是流動的，形成文繞圖的效果。 如果想要斷行在 p 的左方幫p加上float:left，想要斷行在 p 右方幫 p 加上 float:right。 .image-wrapper高度比圖片的時候需要加上clear-fix。 參考資料float與clear用法 - 布魯克斯- 點部落CSS - 關於 float 屬性","link":"/2015/11/12/old%20posts/2015-11-12-css-layout-techniques-spelling/"},{"title":"Rails - 如何解決ajax沒有CSRF Key的問題","text":"錯誤訊息當瀏覽器發生422錯誤，很有可能是缺少CSRF Key所引起的。這時候可以到 Log 確認一下是否是缺少 CSRF Key的情形。 方法一：用js抓mete的csrf-token1234$(document).ajaxSend(function(e, xhr, options) { var token =$j(&quot;meta[name='csrf-token']&quot;).attr(&quot;content&quot;); xhr.setRequestHeader(&quot;X-CSRF-Token&quot;, token);}); 想要學習處理csrf可以看看jquery-ujs的source code jquery-rails/jquery_ujs.js at master · rails/jquery-rails 方法二：在controller加上一個方法[SOLVD] Rails: How Does csrf_meta_tag Work? | DevSolvd 配合ajax 使用12345678910111213$.ajax({ url: &quot;your_url&quot;, type: &quot;DELETE&quot;, dataType: &quot;json&quot;, beforeSend: function(xhr) {xhr.setRequestHeader('X-CSRF-Token', $('meta[name=&quot;csrf-token&quot;]').attr('content'))}, data: {id: attr.ta_attr_id }, success: function(data) { console.log(data); attr.is_added = false; attr.position = undefined; }}); 結論這是在前端做的事情，所以我會選擇使用js來抓","link":"/2015/11/12/old%20posts/2015-11-12-rails-how-to-solve-the-problem-of-ajax-without-csrf-key/"},{"title":"Rails - Sortable Table With Ajax","text":"前端使用sortable 後端在幫要排序的類別(這邊是Memo)加上position欄位 原理與流程jquery-ui 的 sortable 套件內建了 serilize ，它的功用是把 id 變成 query string 依順序回傳，所以我們只要找出規則就可以知道移動的是哪些欄位，把移動後的結果用 ajax 存進資料庫即完成拖曳的動作。 程式結構(html)html指定要排序的Container為id=&quot;memo-table&quot;，讓js可以幫他加上sortable()方法。要排序的欄位加上id=&quot;id-&lt;%= memo.id %&gt;&quot;，這樣 jquery-ui sortable 套件的 serialize 時就會以 query string 的方式把排序送到server。 12345678910111213141516171819202122232425262728293031&lt;p id=&quot;notice&quot;&gt;&lt;%= notice %&gt;&lt;/p&gt;&lt;h1&gt;Listing Memos&lt;/h1&gt;Query string: &lt;span&gt;&lt;/span&gt;&lt;table class=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Content&lt;/th&gt; &lt;th&gt;Position&lt;/th&gt; &lt;th colspan=&quot;3&quot;&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=&quot;memo-table&quot;&gt; &lt;% @memos.each do |memo| %&gt; &lt;tr id=&quot;id-&lt;%= memo.id %&gt;&quot;&gt; &lt;td&gt;&lt;%= memo.content %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= memo.position %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= link_to 'Show', memo %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= link_to 'Edit', edit_memo_path(memo) %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= link_to 'Destroy', memo, method: :delete, data: { confirm: 'Are you sure?' } %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% end %&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;br&gt;&lt;%= link_to 'New Memo', new_memo_path %&gt; 程式結構(js)123456789101112131415$(function() { $('#memo-table').sortable({ axis: 'y', stop: function(event,ui) { var data = $(this).sortable('serialize'); $('span').text(data); $.ajax({ data: data, type: 'POST', url: '/memos/batch_update' }); } });}); Controllermemo_controller 中新增一個action來接這個ajax。因為要表示的是一個列表(List)中許多欄位(column)的順序，所以回傳的params[:id]會是一個陣列，我們把它存成變數ids。我們把改變過的欄位一一更新資料庫的資料。這邊我有點偷懶，沒有比對是否順序不一樣就全部存進去，不過第一次做就先用笨一點的方法，把功能做出來，之後再改進效能。 123456789101112131415def batch_update @memos = Memo.all ids = params[:id] ids.each.with_index do |id, index| memo = @memos[id.to_i-1] memo.position = index + 1 memo.save end respond_to do |format| format.js { render nothing: true } endend Route因為batch_update沒有針對特定的memo，而是一次插入多筆post，所以我把url設定為/posts/batch_update而不是/posts/:id/batch_update。 12345resources :memos do collection do post :batch_update endend 遇到的Bug與解決方法Post 422javascript - POST 422 (Unprocessable Entity) in Rails? Due to the routes or the controller? - Stack Overflow Ajax造成的HTTP 500 Server Error處理 missing template 12345678910def batch_update . . respond_to do |format| format.js { render nothing: true } endend 參考資源 php - jQuery UI Sortable, then write order into a database - Stack Overflow Extending the jQuery Sortable With Ajax &amp; MYSQL","link":"/2015/11/12/old%20posts/2015-11-12-rails-sortable-table-with-ajax/"},{"title":"Rails - 使用 will pagniate 搭配 ajax 實作無限捲動","text":"概念：will paganiate 由送到 controller 的 params[:page] 決定回傳的@posts。 可以由我們在 controller 中定義@posts所知道。 1@posts = Post.paginate(:page =&gt; params[:page]) inifite scroll event12345$(window).scroll(function () { if ($(window).scrollTop() &gt;= $(document).height() - $(window).height() - 10) { //Add something at the end of the page }}); 記得要減10，或任何你覺得適合的數，可以幫助捲動正確觸發。 javascript - infinite-scroll jquery plugin - Stack Overflow 程式碼 - HTML因為我們使用 will pagniate 也就是分頁的GEM來實作，所以我們必須用 hidden field 來儲存目前捲動的最後一頁是哪一頁。image_tag 是 rails 特有的用法，會對應到 assets/images 資料夾下的圖片。 index.html.erb 123456789101112&lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;My Post&lt;/h1&gt;&lt;/div&gt;&lt;!-- page-header --&gt;&lt;div id=&quot;my-posts&quot;&gt; &lt;%= render @posts %&gt;&lt;/div&gt;&lt;!-- my-posts --&gt;&lt;div id=&quot;loadmoreajaxloader&quot; style=&quot;display:none;&quot;&gt;&lt;center&gt;&lt;%= image_tag &quot;ajax-loader.gif&quot; %&gt;&lt;/center&gt;&lt;/div&gt;&lt;%= hidden_field_tag &quot;current_page&quot;, &quot;1&quot; %&gt; _post.html.erb 123456&lt;div&gt; &lt;h2&gt;&lt;%= link_to post.title, post %&gt;&lt;/h2&gt; &lt;small&gt;&lt;em&gt;&lt;%= post.timestamp %&gt;&lt;/em&gt;&lt;/small&gt; &lt;p&gt;&lt;%= truncate(strip_tags(post.body), length: 600) %&gt;&lt;/p&gt;&lt;/div&gt; 程式碼 - JS實作了兩種觸發的方式，先完成較簡單的 click ，之後再把 click 事件替換成捲動至頁尾會觸發的事件即完成無限下拉式瀏覽。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768$(function () { // Load more var $loadmore = $(&quot;#loadmore&quot;); var $current_page = $(&quot;#current_page&quot;); var $my_posts = $(&quot;#my-posts&quot;); var addPostToList = function (post) { var postStri = &quot;&quot;; postStri += &quot;&lt;div&gt;&quot;; postStri += &quot; &lt;h2&gt;&lt;a href=\\&quot;#\\&quot;&gt;&quot; + post.title + &quot;&lt;\\/a&gt;&lt;\\/h2&gt;&quot;; postStri += &quot; &lt;small&gt;&lt;em&gt;&quot; + post.created_at + &quot;&lt;\\/em&gt;&lt;\\/small&gt;&quot;; postStri += post.body; postStri += &quot;&lt;\\/div&gt;&quot;; $my_posts.append(postStri); }; var addPosts = function (posts) { $.each(posts, function () { addPostToList(this); }); }; $(window).on(&quot;scroll&quot;, function () { if ($($(window).scrollTop() &gt;= $(document).height() - $(window).height() - 50)) { var current_page = parseInt($current_page.val()); current_page++; console.log(&quot;111&quot;); $('div#loadmoreajaxloader').show(); $.ajax({ url: &quot;/posts.json&quot;, type: &quot;GET&quot;, dataType: &quot;json&quot;, data: { page: current_page }, success: function (data) { console.log(data); $current_page.val(String(current_page)); var posts = data; $('div#loadmoreajaxloader').hide(); addPosts(posts); } }); } }); // var $loadmore_gif = $(&quot;a.loading-gif&quot;); $loadmore.click(function (e) { e.preventDefault(); var current_page = parseInt($current_page.val()); current_page++; $loadmore.hide(); console.log(&quot;click&quot;); $.ajax({ url: &quot;/posts.json&quot;, type: &quot;GET&quot;, dataType: &quot;json&quot;, data: { page: current_page }, success: function (data) { console.log(data); $current_page.val(String(current_page)); var posts = data; addPosts(posts); $loadmore.show(); } }); });});(function ($) {})(jQuery); 其他：javascript小技巧 - 過濾url獲取id1var str_sub = str.substr(str.lastIndexOf(&quot;=&quot;)+1); Javascript: 標籤過濾從url獲取id - 數碼維基","link":"/2015/11/12/old%20posts/2015-11-12-rails-will-pagniate-implement-an-infinite-scroll/"},{"title":"Rails - 使用 dropzone.js 實現檔案上傳","text":"實現上傳檔案create的時候controller要設定一些值給js接。 123456789101112def create @upload = Upload.create(upload_params) if @upload.save # send success header render json: { message: &quot;success&quot;, fileID: @upload.id }, :status =&gt; 200 else # you need to send an error header, otherwise Dropzone # will not interpret the response as an error: render json: { error: @upload.errors.full_messages.join(',')}, :status =&gt; 400 endend 成功後用success狀態設定div的id 1234567success: function(file, response){ // find the remove button link of the uploaded file and give it an id // based of the fileID response from the server $(file.previewTemplate).find('.dz-remove').attr('id', response.fileID); // add the dz-success class (the green tick sign) $(file.previewElement).addClass(&quot;dz-success&quot;);}, 要傳給rails要注意的事情，要修改params的名稱 12345678910$(&quot;#new_upload&quot;).dropzone({ . . . // changed the passed param to one accepted by // our rails app paramName: &quot;upload[image]&quot;, . . . 設定成按下按鈕才送出用js的方式宣告myDropzone。並設定自動送出false 12345678910 var myDropzone = new Dropzone(&quot;#new_upload&quot;,{ . . . autoProcessQueue: false, parallelUploads: 10, . . .} 幫按鈕加上click handlerd，processQueue()按下時會把Queue中的檔案依照添加順序上傳到server。 123$(&quot;#gogo&quot;).click(function() { myDropzone.processQueue();}) 跟一般的form結合123456789&lt;form id=&quot;my-awesome-dropzone&quot; class=&quot;dropzone&quot;&gt; &lt;div class=&quot;dropzone-previews&quot;&gt;&lt;/div&gt; &lt;!-- this is were the previews should be shown. --&gt; &lt;!-- Now setup your input fields --&gt; &lt;input type=&quot;email&quot; name=&quot;username&quot; /&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Submit data and files!&lt;/button&gt;&lt;/form&gt; js部分: 按下submit的時候順便送出圖片。 接收事件的時候改成監視sendingmultiple 12345678910111213141516171819202122232425262728293031323334353637Dropzone.options.myAwesomeDropzone = { // The camelized version of the ID of the form element // The configuration we've talked about above autoProcessQueue: false, uploadMultiple: true, parallelUploads: 100, maxFiles: 100, // The setting up of the dropzone init: function() { var myDropzone = this; // First change the button to actually tell Dropzone to process the queue. this.element.querySelector(&quot;button[type=submit]&quot;).addEventListener(&quot;click&quot;, function(e) { // Make sure that the form isn't actually being sent. e.preventDefault(); e.stopPropagation(); myDropzone.processQueue(); }); // Listen to the sendingmultiple event. In this case, it's the sendingmultiple event instead // of the sending event because uploadMultiple is set to true. this.on(&quot;sendingmultiple&quot;, function() { // Gets triggered when the form is actually being sent. // Hide the success button or the complete form. }); this.on(&quot;successmultiple&quot;, function(files, response) { // Gets triggered when the files have successfully been sent. // Redirect user or notify of success. }); this.on(&quot;errormultiple&quot;, function(files, response) { // Gets triggered when there was an error sending the files. // Maybe show form again, and notify user of error }); }} Combine normal form with Dropzone · enyo/dropzone Wiki 可以覆寫事件Dropzone.js 參考資料AJAX Photo Uploading the Easy Way with Rails 4 and Paperclip - JustPayme — Muno Creative Ajax file upload with DropezoneJs and Paperclip - Rails | Joseph Ndungu Dropzone.js","link":"/2015/11/12/old%20posts/2015-11-12-rails-use-dropzonejs-for-file-upload/"},{"title":"Rails 筆記 - 使用 ActiveRecord::Enum 設定狀態","text":"使用 Array 表達狀態123class Order KIND = [ ['未付款', 0], ['已付款', 1], ['已出貨',2] ]end 代表 orders 這張表中的 kind 欄位如果是 1 ，則此訂單狀態是未付款的。寫成這樣的好處是在使用 select view helper 的時候可以直接丟進去 1&lt;%= select_tag &quot;訂單狀態&quot;, options_for_select( Order::KIND ) %&gt; 把 KIND 打成這樣是 OK 的，但是我想把它打的好看一點。今天發現了有 ActiveRecord Enum 可以讓他變得有趣點。而且是只要有 ActiveRecord 就可以用，不需要裝其他的 gem。 ActiveRecord::Enum 介紹首先需要宣告對應 DB 裡面的值，第一個就代表對應 0 , 第二個就代表對應 1。 123class Conversation &lt; ActiveRecord::Base enum status: [ :active, :archived ]end 除了可以用文字表示原本是數字的 conversation 的狀態以外，也加了 active! 和 active? 這種方便的方法，active!用來改變 conversation 的狀態為 active ，而 active? 則用來辨識 conversation 狀態是否為 active。這樣寫語意上更棒，更好讀。 12345678910# conversation.update! status: 0conversation.active!conversation.active? # =&gt; trueconversation.status # =&gt; &quot;active&quot;# conversation.update! status: 1conversation.archived!conversation.archived? # =&gt; trueconversation.status # =&gt; &quot;archived&quot; 當然你也可以直接指定值給 conversation.status 123456# conversation.status = 1conversation.status = &quot;archived&quot;conversation.status = nilconversation.status.nil? # =&gt; trueconversation.status # =&gt; nil 用 Hash 儲存 enum宣告成 hash 型態的話，我們可以用 status 的複數型態 statuses 來取得這個 Hash，之後的取值也從 Conversation.active 變成了 Conversation.statuses[:active]，兩個得到的結果是一樣的。不過使用 Hash 時可以明確知道我現在在修改的是 status，屬性一多的時候不會造成混淆。 123456class Conversation &lt; ActiveRecord::Base enum status: { active: 0, archived: 1 }endConversation.statuses[:active] # =&gt; 0Conversation.statuses[&quot;archived&quot;] # =&gt; 1 取得 options_for_select 所需的陣列這樣宣告後，使用 status 的複數型態 statuses 可以取得剛剛輸入的陣列 12[5] pry(main)&gt; Conversation.statuses=&gt; {&quot;active&quot;=&gt;0, &quot;archived&quot;=&gt;1} OK 現在要的東西很接近我們要的了，再做一點加工。 12[11] pry(main)&gt; Conversation.statuses.invert.to_a=&gt; [[0, &quot;active&quot;], [1, &quot;archived&quot;]] done! 現在用 enum 也可以製作 options_for_select 專屬的陣列了。 參考資料ActiveRecord::EnumWhat’s new in edge Rails: Active Record enums","link":"/2016/05/01/old%20posts/2016-05-01-rails-activerecord-enum-api/"},{"title":"在 Mac OS X 下使用 brew 安裝 Go","text":"兩種安裝方法在 Mac OS X 下安裝 Go 有兩種方法，一種是去官網下載安裝包，另一種是使用 Homebrew 來安裝，為了以後更新的便利性著想，我決定使用 Homebrew 來安裝 Golang。 ps: 如果你還沒有 Homebrew 的話，需要先安裝 Homebrew 才能進行以下的安裝。 更新 Brew 到最新狀態打開你的 Terminal，輸入： 1brew update &amp;&amp; brew upgrade 安裝 Golang使用 brew 安裝 go 1brew install go 完成安裝，安裝完畢之後使用 go run file_name 指令時會出現 path error 因為我們還沒設定 $GOPATH 路徑。 設置 $GOPATHbash打開 bash 設定檔 1vim ~/.bashrc 設定 GOPATH 參數 12export GOPATH=&quot;${HOME}/go&quot;export PATH=&quot;${GOPATH}/bin:${PATH}&quot; 重載參數 1source ~/.bashrc fish因為我用的是 fish shell，所以也要設定 fish 的 GOPATH 路徑。輸入以下指令打開 fish 設定檔： 1vim ~/.config/fish/config.fish 加上 GOPATH 參數 12set -gx GOPATH &quot;$HOME/Code/go&quot;set -gx PATH &quot;$GOPATH/bin&quot; $PATH 重載參數 1. ~/.config/fish/config.fish 建立你的第一個 Go 程式建立 hello.go 檔案 1vim /tmp/hello.go 幫剛剛建立的檔案加上以下內容 1234567package mainimport &quot;fmt&quot;func main() { fmt.Println(&quot;Hello, World!&quot;);} 儲存後在 terminal 中輸入go run /tmp/hello.gov 恭喜！ 你可以在 OS X 內使用 Golang 來開發了。 參考資料Mac下安装Go和配置相应环境 Arron.y’s blog Getting Started with Golang on OS X","link":"/2016/01/09/old%20posts/2016-01-09-install-go-in-mac-osx-with-homebrew/"},{"title":"jQuery vs Ruby - 取得倒數的元素並組成字串","text":"摘要本篇利用把陣列轉成字串這個題目，探討 jquery 和 ruby 中，map 和 join 行為的差異。 1. 在 jQuery 中可以用類似 Ruby 的方式取得尾部的倒數第幾個元素。1$('span[itemprop=title]').eq(-2) 對照 ruby 語法 123arr=[1,2,3,4,5,6]arr[-2]=&gt; 5 2. 也可以取出倒數的三個元素剛剛取出的是倒數的第二個元素，而現在我們要把倒數的三個元素都取出來 1$('span[itemprop=title]').slice(-3) 對照的 ruby 語法 123arr=[1,2,3,4,5,6]arr[-3..-1]=&gt; [4, 5, 6] 3.1 取出元素中的text後，存到陣列中先把要的字串存到陣列裡面 1234arr = [];$('span[itemprop=title]').slice(-3).each(function(i,f){ arr.push( $(f).text())}); 3.2 反轉陣列內容並用逗號 join這邊是純 js 陣列的操作。 1arr.reverse().join(&quot;,&quot;); 4. 另一種方法：使用 map 加上 join1234arr = [];$('span[itemprop=title]').slice(-3).map(function(i,f){ return $(f).text();}).get().join(&quot;,&quot;) ; 跟 Ruby 的 map 有些許不同： 需要 return 處理過後的值。 map完的陣列型態會是預設的jquery物件集合而不是Array。需要先使用 get() 取得 return 的值，再進行 join 。 如果你在 ruby 中使用 return，會出現錯誤。 12[9] pry(main)&gt; [&quot;1&quot;, &quot;2&quot;, &quot;2&quot;].map{|x| return x.to_i }LocalJumpError: unexpected return 直接寫出要的結果就沒問題了 12[&quot;1&quot;, &quot;2&quot;, &quot;2&quot;].map{|x| x.to_i + 1 }=&gt; [2, 3, 3] 因為輸出的結果是 array，所以直接 join 即得串聯後的字串。 12[13] pry(main)&gt; [&quot;1&quot;, &quot;2&quot;, &quot;2&quot;].map{|x| x.to_i + 1 }.join(&quot;,&quot;)=&gt; &quot;2,3,3&quot;","link":"/2016/05/31/old%20posts/2016-05-31-jquery-notes-get-last-element/"},{"title":"JS - 確認 jQuery 是否正確載入","text":"使用情境有時候你不能確定環境是否已經載入 jQuery，所以你也不能使用 jQuery.ready()。例如：你想要在別人的網頁上執行一段 javascript 程式碼。這時候你就可以用本篇筆記記錄的方法等待 jQuery 載入後再執行自己的程式碼。 程式碼： 123456789101112131415//如果沒有載入的話，會再執行一次直到 jQuery 正確載入。function defer(method) { if (window.jQuery) method(); else setTimeout(function() { defer(method) }, 1000);}//要執行內容用 function 包起來，丟進 defer 裡面執行。defer(function () { alert(&quot;jQuery is now loaded&quot;);}); 不過這樣如果 jQuery 一直找不到的話就會變成無限迴圈，所以我們加個機制 - 如果重試超過五次，我們就結束程式。 123456789101112131415var i = 0;function defer(method) { if ( i &gt; 5 ) return ; if (window.jQuery) method(); else{ i++; setTimeout(function() { defer(method) }, 1000); }}//要執行內容用 function 包起來，丟進 defer 裡面執行。defer(function () { alert(&quot;jQuery is now loaded&quot;);}); 這邊因為是簡單例子，全域變數就不做處理，一般來說要盡量避免全域變數的使用。 How to check if jQuery library is loaded? javascript - How to make script execution wait until jquery is loaded - Stack Overflow","link":"/2016/06/15/old%20posts/2016-06-15-js-sure-jquery-is-loaded-correctly/"},{"title":"在 Atom 設定 .god 對應至 Ruby Syntax","text":"簡介 GodGod 是以 Ruby 撰寫而成，但不僅限於使用於執行 Ruby 檔，常見的用途是維持程式的運行使程式不中斷，萬一中斷可以自動重啟。不過本篇的重點不在於 God 的使用方法，而是在 Atom 編輯器中於如何讓.god可以對應到 .rb 的語法高亮。 這邊就是設定的方法，打開 config.cson，可以經由 menu 列的 Atom &gt; config 開啟。在 core 的部份加上以下的設定。即可讓 .god 類型的檔案對應至 .rb 的語法高光。 123456&quot;*&quot;: core: customFileTypes: &quot;source.ruby&quot;: [ &quot;god&quot; ] 簡單的說明一下設定方法：外層輸入已知的檔案類型，內層輸入自定義的檔案類型，即可完成。 123456&quot;*&quot;: core: customFileTypes: &quot;source.已存在的檔案類型&quot;: [ &quot;自定義檔案類型&quot; ] Make file type -&gt; language mapping locally configurable · Issue #1718 · atom/atom","link":"/2016/06/27/old%20posts/2016-06-27-in-the-atom-set-god-corresponds-to-ruby-syntax/"},{"title":"Generate Safety Query String In ActiveRecord","text":"Solution 1: sanitize_sql12ActiveRecord::Base.send(:sanitize_sql,[&quot;select * from my_table where description='%s' and id='%s'&quot;,&quot;mal'formed&quot;, 55], &quot;my_table&quot;)=&gt; &quot;select * from my_table where description='mal\\\\'formed' and id='55'&quot; Can also use instance method to do the same thing 123MyTable.send(:sanitize_sql,[&quot;select * from my_table where description='%s' and id='%s'&quot;,&quot;mal'formed&quot;, 55])=&gt; &quot;select * from my_table where description='mal\\\\'formed' and id='55' Solution 2: ActiveRecord::Base.connection.quoteActiveRecord::Base.connection.quote only escape quotes of query. So… it’s not a good solution. 12[17] pry(main)&gt; ActiveRecord::Base.connection.quote([&quot;select * from my_table where description='%s' and id='%s'&quot;,&quot;mal'formed&quot;, 55])=&gt; &quot;'---\\\\n- select * from my_table where description=\\\\'%s\\\\' and id=\\\\'%s\\\\'\\\\n- mal\\\\'formed\\\\n- 55\\\\n'&quot; 12[20] pry(main)&gt; ActiveRecord::Base.connection.quote(&quot;select * from my_table where description='%s' and id='%s'&quot;)=&gt; &quot;'select * from my_table where description=\\\\'%s\\\\' and id=\\\\'%s\\\\''&quot; Solution 3: sanitize_sql_arrayWhen you using sanitize_sql_array, the output will the same as when you using sanitize_sql.But your dont need to send useless table name in third parameter anymore. 12[24] pry(main)&gt; ActiveRecord::Base.send(:sanitize_sql_array, [&quot;select * from my_table where description='%s' and id='%s'&quot;,&quot;mal'formed&quot;, 55])=&gt; &quot;select * from my_table where description='mal\\\\'formed' and id='55'&quot; If we call sanitize_sql_array not through send, you’ll get error message protected methodsanitize_sql_array’ called for ActiveRecord::Base:Class`, So we have to use send to avoid this situation. 123[25] pry(main)&gt; ActiveRecord::Base.sanitize_sql_array( [&quot;select * from my_table where description='%s' and id='%s'&quot;,&quot;mal'formed&quot;, 55])NoMethodError: protected method `sanitize_sql_array' called for ActiveRecord::Base:Classfrom /Users/Steven/.rvm/gems/ruby-2.2.2/gems/activerecord-4.2.6/lib/active_record/dynamic_matchers.rb:26:in `method_missing'","link":"/2016/07/07/old%20posts/2016-07-07-security-of-raw-sql-in-ruby/"},{"title":"Rails: 使用 Whenever 產生 Cronjob","text":"Part 1 - Crontab 介紹Crontab 是 Linux 中用來管理例行事務的程式，而 whenever 實際上的作用就是用來產生 cronjob 的，所以先介紹一下 Linux 系統中的 crontab 如何操作。 crontab 指令比較常用指令的有以下幾項： crontab -l 顯示目前排程 (list cron)crontab -e 編輯排程 (edit cron)crontab -r 移除排程 (remove cron)crontab -u 改變排程的執行身分: crontab -u user filename crontab 的欄位與對應的意義整個指令會長得像樣子，這個指令做的事情是先移動到某個資料夾後執行User.delete_three_day_ago!。 10 4 * * * /bin/bash -l -c 'cd /Users/oceanttd/rails_whenerver &amp;&amp; bundle exec bin/rails runner -e development '\\''Users.delete_three_day_ago!'\\''' 第一到六項分別是： 分鐘 1～59 小時 0～23 日 1～31 月 1～12 0～6（0表示星期天） 要運行的命令 需要注意的是6要運行的命令必須輸入絕對路徑，輸入相對路徑是沒有任何效果的。 使用 crontab 產生器產生 cronjob看完上面規則後一定覺得很難撰寫，不直覺。來推薦一個網站 crontab.guru - the cron schedule expression editor輸入 cronjob 後可以立即顯示正確時間。 Part 2 - 使用 Whenver 產生 cronjobWhenever 是一個 Ruby 的 Gem，沒錯，你不在 Rails 環境下也可以使用。他的功能是讓 cronjob 變得很好撰寫。 安裝在 Gemfile 中加入whenever 或是輸入gem install whenever 初始化移動到 Rails 資料夾輸入 wheneverize .，會幫你建立config/schedule.rb，如果你要建在非 Rails 的資料夾，可能需要自己創一個 config 資料夾來避免發生錯誤。 把 whenever 中的內內容轉為 crontab後面可以指定環境 1whenever --update-crontab --set environment=development 接著用crontab -l指令就可以查看創建的 cronjobs。 來看看 whenever 怎麼撰寫原本難以閱讀的 crontab 與 cronjob，變得很容易閱讀，很且可以跟 rake 或是 ActiveRecord 一起作用。這邊在 Rails 環境下為例。他的原理就是先幫你 cd 到 Rails 資料夾後，再執行 Rake 指令，或是執行 model 的方法。 rake 就直接用 rake 指令執行就好 12345# run this task only on servers with the :app role in Capistrano# see Capistrano roles section belowevery :day, :at =&gt; '12:20am', :roles =&gt; [:app] do rake &quot;app_server:task&quot;end 12345every 3.hours do runner &quot;MyModel.some_process&quot; rake &quot;my:rake:task&quot; command &quot;/usr/bin/my_great_command&quot;end 如果是執行 model 方法要用 runner 1234567891011every 1.day, :at =&gt; '4:30 am' do runner &quot;MyModel.task_to_run_at_four_thirty_in_the_morning&quot;endevery :hour do # Many shortcuts available: :hour, :day, :month, :year, :reboot runner &quot;SomeModel.ladeeda&quot;endevery :sunday, :at =&gt; '12pm' do # Use any day of the week or :weekend, :weekday runner &quot;Task.do_something_great&quot;end call system 123every '0 0 27-31 * *' do command &quot;echo 'you can use raw cron syntax too'&quot;end 如此一來 cronjob 是不是變得很好寫了呢:D 參考資料javan/whenever: Cron jobs in RubyLinux / UNIX Crontab File Location","link":"/2016/07/08/old%20posts/2016-07-08-rails-gem-use-whenever-the-schedule-of-daily-routine/"},{"title":"Linux - 如何查詢 OS 版本","text":"要接手 Server 第一件事情就是要了解 server 的環境啦。這邊要記錄的是如何判別 Linux 系統類別的方式 1. 確認 Kernel 版本使用 uname -or 可以取得 kernel 的版本 12$ uname -or=&gt; 3.10.0-327.el7.x86_64 GNU/Linux 如果要知道詳細的資訊，輸入 uname -a，但即使這樣也無法清楚的看出 OS 的種類。 12$ uname -a=&gt; Linux username 3.10.0-327.el7.x86_64 #1 SMP Thu Nov 19 22:10:57 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux 2. 針對不同 OS 查找對應的說明系統名稱的文件如果是 Ubuntu，輸入 cat /etc/lsb-release。有找到的情況會出現以下訊息 12345$ cat /etc/lsb-releaseDISTRIB_ID=UbuntuDISTRIB_RELEASE=14.04DISTRIB_CODENAME=trustyDISTRIB_DESCRIPTION=&quot;Ubuntu 14.04.5 LTS&quot; 如果你的系統不是 Ubuntu，則會出現以下訊息 12$ cat /etc/lsb-releasecat: /etc/lsb-release: No such file or directory Debian 雖然跟 Ubuntu 同體系但是存放版本號文件的位置不太一樣，輸入cat /etc/debian_version 12$ cat /etc/debian_version8.0 Fedora, Red Hat and CentOS have: 12345678Fedora: $ cat /etc/fedora-releaseFedora release 10 (Cambridge)Red Hat/older CentOS: $ cat /etc/redhat-releaseCentOS release 5.3 (Final)newer CentOS: $ cat /etc/centos-releaseCentOS Linux release 7.1.1503 (Core) 最後用表格來整理以上資訊 系統 位置 ubuntu /etc/lsb-release debian /etc/debian_version Fadoara /etc/fedora-release Red Hat/older CentOS /etc/redhat-release newer CentOS /etc/centos-release 如果你的 OS 上面列表都找不到的話，可以找 etc 資料夾內的有 release 這個詞的 1cat /etc/*{release,version} Referencecommand line - How do I find out what version of Linux I’m running? - Super UserHow to Check CentOS Version Number","link":"/2016/07/29/old%20posts/2016-07-29-linux-how-to-check-os/"},{"title":"Deploy Redmine to VPS by Rails way in Ubuntu 14.04","text":"前言Redmine 是一套以 Ruby 為基底的專案管理網頁應用程式。而且正好就是使用 Ruby on Rails 開發的。所以如果你是 Rails 工程師，使用一般部屬 Rails 專案的方式就可將 Redmine 架起來。 本文記錄下來的方法，是我覺得最簡單，並且沒有副作用的架設方法。如果你要架設的不是 Redmine ，而是其他的 Rails 專案，也同樣適用。 本文採用的環境：OS: Ubuntu 14.04VPS: Digital Ocean 在 Ubuntu 創造新的使用者Linux 是非常嚴謹的系統，不同資料夾放的東西都有其規範。而 root 帳號在 Linux 系統中是超人，可以做任何的事情。為了維持 Linux 系統的乾淨度，我們要建立一個專用的使用者 oceanttd 而不是直接使用 root 帳號來部屬。這樣在有多人要同時使用同一個 Linux 作業系統的時候會減少很多麻煩。 創造部屬的帳號 oceanttd 1sudo adduser oceanttd 把 oceanttd 帳號加到 sudo 群組(?) 1sudo adduser oceanttd sudo 切換到 oceanttd 帳號 1su oceanttd 更新 Ubuntu apt-get 的套件1sudo apt-get update 安裝 Mysql 或是其他資料庫1sudo apt-get install mysql-server 安裝 RVM輸入指令安裝 RVM，過程中可能會出現一些錯誤訊息，因為我沒有預先使用 apt-get 安裝需要的套件。不過不要緊，跟著系統會告訴哪些還沒裝好，並且會給你安裝的指令，跟著系統指示很快的就可以完成。 1curl -L https://get.rvm.io | bash 重新登入 vps，輸入 rvm -v 查看 rvm 是否有裝好。 在 RVM 中安裝 Ruby1rvm install 2.2.3 將 ruby 2.2.3 設定成預設的 Ruby 語言，這個動作很重要一定要做，因為預設的 Ruby 會是 Ubuntu 系統中預裝的版本，換成 RVM 的版本我們才好處理 Gem 之類的安裝問題 1rvm use 2.2.3 --default 檢查系統中的 ruby 是否使用 rvm 的 ruby 輸入ruby -v檢查版本輸入which ruby 檢查路徑，路徑裡面有 rvm 的才是正確 安裝 Rails記得加上 --no-ri --no-rdoc ，意思是不要裝文件，因為我們上網查就好了。可以省下很多時間。 1gem install rails --no-ri --no-rdoc 把 Redmine 專案載下來，( 如果你要部屬的是自己的專案，請 git clone 你自己的專案 ) 到 Redmine 官方的下載頁面下載最新版本或是你想要的版本的 Redmine。我的版本是 3.2.0 有支援 markown。就以 3.2.0 為例好了，如果你想要用別的版本可以自行替換。 1wget http://www.redmine.org/releases/redmine-3.2.0.tar.gz 解壓縮 1tar xzf redmine-3.2.0.tar.gz 現在你有一個 Redmine 的 Rails 專案了。 對 Rails 專案的一些處理bundle 一下。可能會有一些 Ubuntu 的套件沒有裝會噴錯誤。不過都還滿簡單的。 1bundle 缺少 imagemagick 的話可以下下面指令。 12$ sudo apt-get install imagemagick$ sudo apt-get install libmagickwand-dev Rails 資料庫處理12rake db:createrake db:migrate 建之前要更新一下 config/database.yml 的內容，把 VPS Server 上的 mysql 帳號密碼寫進去。 安裝 Passenger1gem install passenger --no-ri --no-rdoc 使用 Passenger 安裝 nginx1rvmsudo passenger-install-nginx-module 安装 Nginx init script1234$ cd ~/$ git clone git://github.com/jnstq/rails-nginx-passenger-ubuntu.git$ sudo mv rails-nginx-passenger-ubuntu/nginx/nginx /etc/init.d/nginx$ sudo chmod +x /etc/init.d/nginx 開機自動啟動 1$ sudo update-rc.d nginx defaults (內容來自 ruby china 文尾有連結) 設定 nginx.conf打開 nginx.conf 1sudo vim /opt/nginx/conf/nginx.conf 123456789101112131415161718192021222324252627282930313233343536373839404142user jason; # 修改成你的系统帐号名，不然项目目录 /home/jason/www 这里没有权限worker_processes 8; # 修改成和你 CPU 核数一样pid /var/run/nginx.pid;http { include mime.types; default_type application/octet-stream; client_max_body_size 50m; sendfile on; access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; gzip on; gzip_disable &quot;msie6&quot;; ## ------------ 重点修改内容 -------- server { # 此处用于防止其他的域名绑定到你的网站上面 listen 80 default; return 403; } server { listen 80; server_name you.host.name; # 请替换成你网站的域名 rails_env production; root /home/jason/www/gitlab/public; passenger_enabled on; location ~ ^(/assets) { access_log off; # 设置 assets 下面的浏览器缓存时间为最大值（由于 Rails Assets Pipline 的文件名是根据文件修改产生的 MD5 digest 文件名，所以此处可以放心开启） expires max; } } ## ---------------------------------} 重新啟動 Nginx 1sudo /etc/init.d/nginx start 到 Rails project 下重啟 nginx1touch tmp/restart.txt 大功告成，現在你應該可以透過你的 server ip，連接到你架設的 Redmine 上了^^ 在過程中可能遇到的錯誤Incomplete response received from application打開瀏覽器看到 Incomplete response received from application 時。這時候我們可以去看看/opt/nginx/logs/error.log。發現有以下訊息： 1*** Exception RuntimeError in Rack application object (Missing `secret_token` and `secret_key_base` for 'production' environment, set these values in `config/secrets.yml`) (process 5076, thread 0x007fd841f79d58(Worker 1)): 這時候我們在 secret.yml 中加入 secret_token 即可。 參考連結Deploy Ruby On Rails on Ubuntu 14.04 Trusty Tahr - GoRails 雨蒼的終端機: 如何在Ubuntu 13.04 Server上部署Ruby on Rails app 在 Ubuntu 14.04 Server 上安装部署 Ruby on Rails 应用 - Wiki » Ruby China Blog of Ryan Bigg - Deploying a Rails application on Ubuntu: Passenger Edition","link":"/2016/02/13/old%20posts/2016-02-13-deploy-redmine-to-vps-by-rails-way-in-ubuntu-14-04/"},{"title":"ActiveRecord - 更新大量資料","text":"前言本文使用的兩種方法，實際上都是用一個 sql 插入或更新所有的資料。原因是使用其他的方法都沒有使用一個sql插入快。如果插入的筆數過多，需要調整 sql buffer 的大小。本例子的情景是一次更新100筆資料，資料量不大，所以不會遇到這個問題。 方法一：純 SQL 因為欄位很多，我要傳送的欄位又是完整的一個不少，所以我用 Model.attribute_names 來組合要傳入的欄位名稱。 然後將要更新的 Hash 組成 VALUES (x1, y1, z1, ...), (x2, y2, z2, ...), ...字串 最後將要更新的欄位組成 flag_string=VALUES(flag_string) 這種格式 想要組出的 sql 12345ActiveRecord::Base.connection.execute(&quot; INSERT INTO linkouts (#{linkouts_attr_names_string}) VALUES #{query_string} ON DUPLICATE KEY UPDATE #{equal_val_string}&quot;) 組出來的結果 query string 這邊比較難處理，因為是 raw sql，如果在 integer 型態的欄位塞入 ''，或是在字串的欄位沒有用引號括起來都會噴錯。這也是使用 raw sql 撰寫的缺點。 123456789[1] pry(#&lt;MastersController&gt;)&gt; linkouts_attr_names_string=&gt; &quot;id,kind,report_id,keyword_id,ezpd_id,url,name,price,full_match,created_at,updated_at,merchant_price,price_check,status,merchant_id,remark,out_of_stock,flag_at,flag_string,remark_status&quot;[2] pry(#&lt;MastersController&gt;)&gt; query_string=&gt; &quot;(22442,'0',8,126,'https://www.etungo.com.tw/inside/413/419/608/20711.html','【CLENSURE可蘭秀】美容離子導入儀 (SNOWY)',1580,1/1,'2016-08-01 17:31:20','2016-08-01 18:01:52',2)&quot;[3] pry(#&lt;MastersController&gt;)&gt; equal_val_string=&gt; &quot;kind=VALUES(kind),report_id=VALUES(report_id),keyword_id=VALUES(keyword_id),ezpd_id=VALUES(ezpd_id),url=VALUES(url),name=VALUES(name),price=VALUES(price),full_match=VALUES(full_match),created_at=VALUES(created_at),updated_at=VALUES(updated_at),merchant_price=VALUES(merchant_price),price_check=VALUES(price_check),status=VALUES(status),merchant_id=VALUES(merchant_id),remark=VALUES(remark),out_of_stock=VALUES(out_of_stock),flag_at=VALUES(flag_at),flag_string=VALUES(flag_string),remark_status=VALUES(remark_status)&quot; 完整程式碼： 123456789101112131415161718192021222324252627282930313233343536373839linkouts_attr_names = Linkout.attribute_names linkouts_attr_names_string = linkouts_attr_names.join(&quot;,&quot;) string_arr = [] bm[:linkout_list].each_with_index do |l, i| l[&quot;status&quot;] = 2 l[&quot;flag_string&quot;] = nil l[&quot;flag_at&quot;] = nil if i == 0 # 這邊只拿出一組來組合sql，以免sql太亂難除錯 current_arr = [] l.each_pair do |k, v| if k == &quot;created_at&quot; || k == &quot;updated_at&quot; current_arr &lt;&lt; + &quot;'&quot; + v.strftime('%Y-%m-%d %H:%M:%S') + &quot;'&quot; elsif v.class == 'boolean' &quot;#{v}&quot; elsif v.to_i &gt; 0 current_arr &lt;&lt; &quot;#{v}&quot; elsif v != nil current_arr &lt;&lt; &quot;'#{v}'&quot; end end string_arr &lt;&lt; &quot;(&quot; + current_arr.join(&quot;,&quot;) + &quot;)&quot; end end query_string = string_arr.join(&quot;,&quot;) linkouts_attr_names.delete(&quot;id&quot;) equal_val_string = linkouts_attr_names.inject([]) do |result, attr| result &lt;&lt; &quot;#{attr}=VALUES(#{attr})&quot; end equal_val_string = equal_val_string.join(&quot;,&quot;) ActiveRecord::Base.connection.execute(&quot; INSERT INTO linkouts (#{linkouts_attr_names_string}) VALUES #{query_string} ON DUPLICATE KEY UPDATE #{equal_val_string} &quot;) 這樣組出的 SQL 結果如下 1234INSERT INTO linkouts (id,kind,report_id,keyword_id,ezpd_id,url,name,price,full_match,created_at,updated_at,merchant_price,price_check,status,merchant_id,remark,out_of_stock,flag_at,flag_string,remark_status) VALUES (22442,'0',8,126,'https://www.etungo.com.tw/inside/413/419/608/20711.html','【CLENSURE可蘭秀】美容離子導入儀 (SNOWY)',1580,1/1,'2016-08-01 17:31:20','2016-08-01 18:01:52',2) ON DUPLICATE KEY UPDATE kind=VALUES(kind),report_id=VALUES(report_id),keyword_id=VALUES(keyword_id),ezpd_id=VALUES(ezpd_id),url=VALUES(url),name=VALUES(name),price=VALUES(price),full_match=VALUES(full_match),created_at=VALUES(created_at),updated_at=VALUES(updated_at),merchant_price=VALUES(merchant_price),price_check=VALUES(price_check),status=VALUES(status),merchant_id=VALUES(merchant_id),remark=VALUES(remark),out_of_stock=VALUES(out_of_stock),flag_at=VALUES(flag_at),flag_string=VALUES(flag_string),remark_status=VALUES(remark_status) ) 方法二：使用 AcitveRecord-importAcitveRecord Import 是一個專門用來批次新增或是修改資料的 gem。用法很簡單，在原本的 Model 後面加上要新的陣列，並指定要更新的欄位即可。要更新的欄位也支援使用 sql 語句。 12Model.import array_to_be_update, on_duplicate_key_update: [:title]Model.import [book1, book2], on_duplicate_key_update: &quot;author = values(author)&quot; 結論組 Sql 不需要先把資料包成物件，效能會比較好。不過相對來說需要多花一些時間處理資料欄位型態的問題，而本例中的 mysql 因為是一個指令加上要更新的欄位可能很多，所以 debug 的難度比較高。這時候就看取捨了，如果初期趕著功能上線可以先用 activeRecord-import 來寫，當遇到效能需要最佳化的時候再改成純 sql 會是比較好的處理方式。","link":"/2016/08/03/old%20posts/2016-08-03-active-record-batch-update/"},{"title":"Ruby - 利用 ARGV 特性執行指定的方法","text":"情境我想手動執行 class 的某個方法。這邊的例子是當我想移動的時候，我可以選擇走路、跑步或是游泳。 方法一： 在 irb 中引入 Ruby 檔123456789101112131415class Move def self.walking puts &quot;walking&quot; end def self.running puts &quot;running&quot; end def self.swimming puts &quot;swimming&quot; endend 打開 irb ，輸入 require_relative argv_ex1.rb，argv_ex1.rb 是上面程式碼的檔名。 12345[1] pry(main)&gt; require_relative 'argv_ex1.rb'=&gt; true[2] pry(main)&gt; Move.swimmingswimming=&gt; nil 用這樣的方式我們可以執行 Class 中的某個方法，不過還是麻煩了點。現在我們來試試透過 ARGV 來執行 Move 中的方法。 方法二：使用 ARGV 執行指定的 method2.1 簡單介紹 ARGV當你在 Command line 模式中輸入除了原本檔名以外的參數，會自動被儲存成一個 ARGV 陣列。 12345argv = ARGVputs &quot;ARGV Type is: &quot; + argv.class.to_sputs &quot;array elements are: &quot;puts argv 打開 Terminal 輸入ruby argv_ex1.rb cat dog rabbit snake，會得到： 123456ARGV Type is:Arrayarray elements are:catdograbbitsnake 簡單的說參數的第一個會對應 ARGV[0]，第二個會對應 ARGV[1]，運用這個特性我們可以依照需求來決定要執行的方法或內容。 2.2 應用到例子12345678910111213141516171819202122232425class TryARGV def self.execute( command ) if command.to_sym == :walk self.walking elsif command.to_sym == :swim self.swimming else puts &quot;swim or walk?&quot; end end def self.walking puts &quot;walking&quot; end def self.running puts &quot;running&quot; end def self.swimming puts &quot;swimming&quot; endendTryARGV.execute( ARGV[0] ) 現在我們只要在 terminal 中輸入 swim 或是 walk 即會呼叫對應的方法。 1234$ argv_practice ruby argv.rb swimswimming$ argv_practice ruby argv.rb walkwalking 結論可以用來呼叫類別方法的還有 rake 也可以達到相同效果。不過如果要使用的話還需要另外設定 .rake 檔。ARGV 的方式在輕量使用的時候是個不錯的選擇。","link":"/2016/08/26/old%20posts/2016-08-26-using-the-argv-characteristic-method-to-excute-specific-method/"},{"title":"Ruby - 爬網頁時遇到的編碼錯亂問題","text":"問題描述編碼問題是寫爬蟲常會遇到的問題。當你沒有處理好編碼問題，爬回來的網頁無法進行字串的切割，也無法使用 nokogiri 抽離需要的部份。 解決方法 找到原始網頁的編碼chartset='big' 把網頁 force_encoding 至原始格式 將網頁轉換成 utf-8，這是 ruby 預設的編碼，也是 nokogiri 接受的編碼。 force_encoding 的意思是強制使用某種編碼格式，但是其實不會進行編碼的轉換，因為ruby預設是utf-8，所以如果網頁是 big5 我們就得先幫網頁加上網頁原有的編碼格式。 設定好網頁原始的編碼之後，我們才可以將載下來的網頁轉成我們要的格式，所以最後得使用encode指令來轉換成我們要的utf-8格式。 完成以上步驟之後，你就可以順利的進行字串的處理了:)","link":"/2016/09/10/old%20posts/2016-09-10-ruby-crawler-encoding-problem/"},{"title":"Ruby 爬蟲小技巧 - 處理 Html Entity","text":"這是一個在工作上遇到的小問題。把網頁爬回來的時候有 HTML Entity 的編碼，看起來很不美觀。舉例來說，爬回來的標題如果含有 HTML Entity 會是這個樣子: 1PURUS空氣清淨器&amp;#40;鴻海集團創星出品&amp;#41; 如果我想要使用資料建立自己資料庫的時候勢必要對 html entity 做一些處理這時候 Gemhtmlentities就派上用場了。使用方法： 12345require 'htmlentities'str = &quot;PURUS空氣清淨器&amp;#40;鴻海集團創星出品&amp;#41;&quot;puts HTMLEntities.new.decode(str)=&gt; PURUS空氣清淨器(鴻海集團創星出品) 現在你可以把品名存進資料庫了 :D其實這篇只是想記錄一下，HTML Entity這個名詞。歸類到編碼的類別方便以後查找。 參考資料：htmlentities.rubyforge.org","link":"/2016/08/12/old%20posts/2016-08-12-a-ruby-tip-html-entity-encode/"},{"title":"Ruby metaprogramming - Method Lookup","text":"介紹ruby metaprogramming 這本書除了教如何用 ruby 來生成其他的程式語言外，對語言特性的描述是比較深入的。因此在研讀這本書的同時，記錄下一些我覺得重要的部份。這些筆記不會依照章節的順序性。而是隨機記錄我需要的部分。 Method Lookup 即 Ruby 物件中查找方法的順序。從 Module 得到的方法與從 Class 繼承的方法其實是有順序性的。知道其順序性後我們在編寫的程式碼的時候才可以比較清楚的預想程式行為的發生的情況。在追蹤原始碼的時候對語言特性多一份的理解追起來就會順利一點快速一點。 prepend 與 include這邊是 Method Lookup 的順序圖，左邊是 instance method 右邊是 class method。使用 include 的時候可以發現，如果 class 中原本就有方法，那 include 進來優先權還是無法比 class 原有的方法高。但是如果使用 prepend ，則可以取代。我們用個小例子來證實這點。 ex1 - 使用 include 引入方法 123456789101112131415161718module IAmModule def meow puts &quot;Module Meow&quot; endendclass Cat include IAmModule def meow puts &quot;Meow&quot; endendc = Cat.newc.meow 執行結果： 12$ ruby ex1.rb-&gt; Meow ex2 - 使用 prepend 引入方法 123456789101112131415161718module IAmModule def meow puts &quot;Module Meow&quot; endendclass Cat prepend IAmModule def meow puts &quot;Meow&quot; endendc = Cat.newc.meow 12$ ruby ex2.rb-&gt; Module Meow 我們可以使用 ancestor 方法來看看優先順序： ex1 1[ Cat, IAmModule, Object, Kernel ,BasicObject ] ex2 1[IAmModule, Cat, Object, Kernel, BasicObject] ex1 使用 include 所以 Module 在 Class 之後，會優先呼叫 Class 的方法。ex2 使用 prepend ， Module 引入的順序在 Class 之前，因此會優先執行 Module 的方法。 相關的還有與 refine 的比較，不過我想要把 refine 整理在 open class 獨立成一篇。敬請期待~ 參考資料 &amp; 圖片來源Get the Lowdown on Ruby Modules","link":"/2016/09/10/old%20posts/2016-09-10-ruby-metaprogramming-method-lookup/"},{"title":"Elasticsearch 筆記","text":"前言最近工作上使用的資料庫主要以 Elasticsearch 為主。而 Elasticsearch 跟傳統的關聯式資料庫有諸多的不同之處。初期在開發的時候並不是那麼快的上手。所以記錄下該如何使用 Elasticsearch 與如何在官方文件中找到自己需要的功能。 1. 準備工作1.1 你需要知道的名詞一開始我對名詞的對應並不是特別的重視，隨著實戰上的需求，我開始需要查找 API 的時候，發現文件有點不知道從何看起。後來隨著使用的功能越來越多。必須對 Elasticsearch 有更深一層的了解，於是花了大約兩天左右的時間把文件重要的部份大略的看過一次。這樣的過程讓我理解了哪些功能可以在哪些地方找到，也是我寫下這篇筆記的動機， index 對應關聯式資料庫中的 database。type 對應關聯式資料庫中的 table。docuement 對應的是關聯式資料庫中的一筆資料。mapping 對應關聯式資料庫中的 schema。 1.2 文件導覽常用的文件分為兩部分 definitive guide 與 referenece 。為了直接對應官方文件這邊就直接用英文名詞。 基本的資料操作和一些基本的用法可以在 The Definitive Guide 中找到，Definitive Guide 整體比較偏向 如何達成你要做的事情。包括以下幾種： 文件的新增刪除 如何做全文搜索 如何搜尋 而 API 的詳細分類和用法的範例則可以在 Elasticsearch Reference 中找到。比較常用的有： Document API - 單筆資料的操作在這邊查找 Search API - Elasticsearch 支援的搜尋方法非常多種，Search API 是非常重要的一環。了解 search api 後可以搭配 update_by_query 或 delete_by_query 等等的 api 來做更新或刪除的動作 Cat API - 可以獲得系統目前的資訊 Indice API - 用來管理 index 的 api。這邊我一開始看到疑惑了一下。過了一會兒才聯想到 elasticsearch 的 index 等於關聯式資料庫的 db。所以其實每個 api 開的名稱都是很有條理和整齊度的 Aggregations - aggregation 對應關聯式資料庫的 GROUP，做分組後取得結果。 Query DSL - 如果需要自定義搜尋，elasticsearch 有提供query DSL 讓你可以高度彈性的組出想要的搜尋。 另外 Elasticsearch Ruby 的 API 位置在這邊。因為文件的連結沒有在官方 github 中明顯的寫出來，一開始讓我疑惑了一下。 1.3 可以用哪些方法存取 Elasticsearch跟 Elasticsearch 的溝通只要透過 HTTP Request 就可以存取。這也是雖然 Elasticsearch 是以 Java 作為底層，但是卻可以跟大多數其他程式語言製作系統輕鬆串接重要原因。所以操作上只要你可以發出 HTTP Request 就可以跟 Elasticsearch 溝通。而因為安全性的關係，Elasticsearch 常常架設在內網。需要在遠端存取的時候透過VPN 會是比較安全的作法。 我比較常用的方法有以下幾種： 直接在終端機下使用 curl 取得結果，指令由官網複製下來修改成自己的格式。好處是這樣做可以排除很多不確定因素，例如gem是否有bug等等的問題。壞處是取得的結果並不好看。如果要好看的話需要自行處理。 使用 Restclient 將 curl 指令包起來發 HTTP Reqeust 給 Elasticsearch。跟 Elasticsearch-ruby 比較起來，這是單純的 HTTP Request，比較不容易有 Gem 中的 Bug。如果在終端機中確定指令可用，可以直接用 Restclient打造。直接使用system call也是這邊的替代方案之一。 使用外掛(plugin)存取，好處是方便存取，看到的結果也會是整理過的。缺點是要架設需要花一段時間先把環境整理好。 使用 Elasticsearch-ruby存取 Elasticsearch 。好處是搜尋出來的結果已經經過包裝。缺點是需要大量新增或更新資料的時候因為過度包裝速度會比較慢。一開始使用的時候會擔心有些API不是官方的最新版本。實際測試的心得是大部分都是可行的。如果得不到預期的結果再使用 curl 來下原始的指令。到這邊可以發現，你需要對 elasticsearch的行為有一定的認識，不然你是無法好好的使用他。 2. mapping2.1 Schema Free 更要嚴謹的定義資料庫mapping 即關聯式資料庫中的 schema。但是 Elasticsearch 有著 schema free 的特性。即如果你想存入的欄位的型別與 mapping的型別不同時你仍然可以存入。還未定義過的欄位也可以直接存入資料庫。 有著 schema free 的特性更需要注重資料的格式與資料欄位的設計，如果不當的使用很可能讓資料庫中資料變成一堆難以整理的垃圾。 2.2 特別需要注意的 String 型態Elasticsearch 的 String 比較特別。如果不做特別設定的話，Elasticsearch 會預設處理方式為 full text，也就是會幫你的 string 做切字的動作。如果要把整個 string 欄位視為一個 keyword ，則需要在 mapping 的時候加上 index: &quot;not_analyzed&quot;。 12345678910111213141516PUT my_index{ &quot;mappings&quot;: { &quot;my_type&quot;: { &quot;properties&quot;: { &quot;full_name&quot;: { &quot;type&quot;: &quot;string&quot; }, &quot;status&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;index&quot;: &quot;not_analyzed&quot; } } } }} 相關連結: String datatype - Elasticsearch Reference [2.4] - ElasticField datatypes - Elasticsearch Reference [2.4] - Elastic 2.3 keyword 、 full text 與 analyzerkeyword的行為跟關聯式資料庫的欄位行為比較像。除了用字串比對的方式以外沒什麼其他的搜尋方法。而full text 則會通過 analyzer 進行分析，你可以使用系統提供的 analyzer。系統提供的 analyzer 只能切英文字。如果要切中文可以用一套叫做 elasticsearch-analysis-ik的開源解決方案來處理。或是自行撰寫也是一個選項。 2.4 查詢 mapping 的語法在終端機中使用 curl 1curl -XGET 'http://localhost:9200/spider/_mapping/tkecw' 使用RestClient 12res = RestClient.get &quot;http://localhost:9200/spider/_mapping/tkecw&quot;JSON.parse res.body 相關連結： Get Field Mapping - Elasticsearch Reference [2.4] - Elastic 參考資料Getting Started - Elasticsearch: The Definitive Guide [2.x] - ElasticModule: Elasticsearch::API::Actions — Documentation for elasticsearch-api (2.0.0)Field datatypes - Elasticsearch Reference [2.4] - Elastic","link":"/2016/09/11/old%20posts/2016-09-11-Elastic%20Search%20Note/"},{"title":"Ruby metaprogramming - Open Class and Refine","text":"簡介Open Class 是 Ruby 常用的技巧，指的是我們可以覆寫已經存在的方法，來修改物件或類別的行為。在這邊我沒有要講詳細的作法，要介紹的是在 Ruby 2.0 中新增的 refine RefineRefine 是 ruby 2.0 之後加入的元素。會使用 Refine 的原因是使用一般 Open Class 的技巧時並不會有明顯的提示。所以我們如果沒有用比較清楚的方法標示 Open Class 作用的地方，造成的後果是非常難以維護且可怕的。透過 refine 我們可以更安全的覆寫原本的 Class，尤其是系統中本來存在的一些方法。用法是先定義一個 Module ，Module 裡面寫下你要覆寫的 Class 與要覆寫的方法。並且用 Using 決定在何時使用。 12345678910111213141516171819202122class Cat def meow puts &quot;Meow&quot; endendmodule IAmRefineModule refine Cat do def meow puts &quot;meow in Refine Module&quot; end endendc = Cat.newc.meowusing IAmRefineModulec = Cat.newc.meow 執行結果： 123$ ruby refine_ex.rb-&gt; Meow-&gt; meow in Refine Module 要呼叫using IAmRefineModule後，我們定義的 refine Module，那麼 Class 方法才會被覆寫到原有的 class。 Method Lookup接下來我們來跟 Module 的 Prepend 來比較看看，看看 refine 定義的方法，是否會優先於 prepend module 所引入的方法。 1234567891011121314151617181920212223242526272829303132333435module IAmModuleInclude def meow puts &quot;Module include Meow&quot; endendmodule IAmModulePrepend def meow puts &quot;Module prepend Meow&quot; endendclass Cat prepend IAmModulePrepend # include IAmModuleInclude def meow puts &quot;Meow&quot; endendmodule IAmRefineModule refine Cat do def meow puts &quot;meow in Refine Module&quot; end endendc = Cat.newc.meowusing IAmRefineModulec = Cat.newc.meow 來執行看看 123$ ruby refine_prepend_compare.rb-&gt; Module prepend Meow-&gt; meow in Refine Module 我們發現，即使 prepend Module 之後，只要我們使用 refine，就會優先使用 refine 所定義的方法。實際上使用 refine 的時候，因為語意上非常明顯，作為 open class 的選擇我覺得是很棒的。","link":"/2016/09/11/old%20posts/2016-09-11-ruby-meta-programming-refine/"},{"title":"Ruby - 讓 irb 更好用","text":"前言在使用pry的時候我們可以回到上一個輸入的指令，擁有記錄指令歷史的功能。其實irb也可以！ 開始修改修改~/.irbrc 123require 'irb/ext/save-history'IRB.conf[:SAVE_HISTORY] = 200IRB.conf[:HISTORY_FILE] = &quot;#{ENV['HOME']}/.irb-history&quot; 修改完之後按下方向鍵上和下即可使用上一個用過的指令。而實際上，歷史紀錄是儲存在~/.irb_history。 另一個常用的功能 - autocomplete 我們也順便把它開起來。在~/.irbrc中irb/completion即可，現在你的 irb 按下 tab 即可以自動補完。 12345require 'irb/ext/save-history'require 'irb/completion'IRB.conf[:SAVE_HISTORY] = 200IRB.conf[:HISTORY_FILE] = &quot;#{ENV['HOME']}/.irb-history&quot;IRB.conf[:AUTO_INDENT] = true 參考資料 Module: IRB (Ruby 2.0.0) Have ruby irb console save history - kitt hodsden’s nags of a similar ilk","link":"/2016/10/24/old%20posts/2016-10-24-let-irb-better/"},{"title":"在 OSX 環境中測試 etc&#x2F;hosts 是否成功修改","text":"前言透過修改 etc/hosts 讓我們不需要透過 DNS 也能模擬網域名稱連線到伺服器。可是設定是否成功？這時候我們可以用一些測試工具來檢測之。 OSX環境下OSX 內建 dscacheutil 工具，可以用來檢測網址名稱對應 ip 的結果。使用方法 1dscacheutil -q host -a name 檢測的網域名稱 比如說我想要檢測 google.com 對應的 ip 1234567891011$ dscacheutil -q host -a name google.comname: google.comipv6_address: 2404:6800:4008:c03::66lsname: google.comip_address: 74.125.203.101ip_address: 74.125.203.100ip_address: 74.125.203.138ip_address: 74.125.203.139ip_address: 74.125.203.113ip_address: 74.125.203.102 如果我在 etc/hosts 將 google.com 設定至自定義的 ip。 1111.111.111.111 google.com 檢測的結果即變成 123456$ dscacheutil -q host -a name google.comname: google.comipv6_address: 2404:6800:4008:c03::64name: google.comip_address: 111.111.111.111 參考資料mac - How can I install getent on Snow Leopard? - Ask Different 其他相關工具 macos - OS X 10.10.1 /etc/hosts &amp; /private/etc/hosts file is being ignored and not resolving - Ask Different Linux 環境 dns - How to test /etc/hosts - Unix &amp; Linux Stack Exchange","link":"/2016/11/09/old%20posts/2016-11-09-testing-ip-after-modifing-etc-hosts/"},{"title":"EFK(1) - 介紹 ELK Stack( Elasticsearch + Logstash + Kibana)","text":"ELK整體架構 最左邊的 Logstash Shipper 用來運送 Log 到 Log 處理中心。 Redis 當做 Buffer 來緩衝資料量瞬間爆量的問題。 右邊的 Logstash 將 Log 加工成 Elasticserach、Kibana 可以處理的格式。 Kibana 是一個後台，可以看到我們所有蒐集的 Log，輸入搜尋條件後就可以很快的找到需要的資料。 為什麼我們要蒐集 log? 想像一下在被攻擊時我想列出某一ip的所有記錄或是某個使用者的行為蹤跡，以做對應的處理。 伺服器在記憶體標高的那段時間系統到底做了些什麼事情，可以幫助我們迅速找到系統問題、對症下藥。 LogstashLogstash 是一套 Log 分析框架，可以幫助我們處理各式各樣的 Log 2.1 Beats 介紹Beat 即為 logstash forwarder 又稱為 shipper，因為之前的 logstash forwarder 有著效能問題，elastic.co 公司推出 Beat 來取代之。除了原本的 log 蒐集(filebeat)以外，也可以監控系統狀態(metricbeat)，或是伺服器網路是否正常運作(heartbeat)除此之外，社群上也有大量各式各樣的 Beat (Community Beats | Beats Platform Reference 5.2 | Elastic) 可以使用 ElasticsearchKibanaKibana 是一個可以顯示 Logstash 處理後格式的後台。資料儲存於 Elasticsearch。整理與視覺化我們需要的資料。","link":"/2017/05/14/old%20posts/2017-05-14-introduce-to-elasticsearch-logstash-kibana-aka-elk/"},{"title":"EFK(2) - 介紹 EFK (Elasticsaerch + Fluentd + Kibana)","text":"Fluentd 介紹 Fluentd 跟 Logstash 扮演的角色相同。過去 Logstash 的歷史有效能不佳的記錄，Fluentd 在效能上的口碑更好。如下圖所示，Fluentd 可以將蒐集 Log 負責的過程統一規格化。我們在使用的時候，選用想要蒐集Log樣式的 input plugin，例如：要蒐集 apache 的 log 我們就選用 fluentd 的 apache input plugin。輸出的時候選擇 output plugin，例如: logstash output plugin，這樣就能夠讓 Elasticsearch 和 Kibana 接受。有著這種特性我們可以用 Fluentd 來取代 Logstash，讓原本的 ELK Stack (Elasticsearch + Logstash + Kibana) 變成 EFK。(Elasticsearch + Fluentd + Kibana)。 Fluentd 是值得信賴的Ruby 之父 Matz 與 Heroku co-founder 推薦 企業推薦 隸屬 CNCF 聯盟 Fluentd 與 Logstash 比較這邊有兩篇很棒的比較： Loom Systems - AI Log Analysis for All Your Applications Log Aggregation with Fluentd, Elasticsearch and Kibana 其他資源List of All Plugins","link":"/2017/05/15/old%20posts/2017-05-15-introduce-to-fluentd-efk/"},{"title":"EFK(3) - Rails 與 Fluentd 的串接方法","text":"幾種可以跟 Rails 串接的方式 gem ‘fluent-logger’ Centralize Logs from Ruby Applications 自定解析 fluent/fluent-plugin-grok-parser: Fluentd’s Grok parser 使用 Rails-logger 來蒐集, 如果你的目標是讓 EFK 變成一個 log 整合系統，這個方式是你的最佳選項。搭配 act-fluent-logger-rails' 與 lograge 這兩個 gem, 可以將你的 log 更加的組織化。詳細教學請參照下方連結: Collecting and Analyzing Ruby on Rails Logs | Fluentd 這篇我們採用的方式是 1，優點是可以自定義 log 的形式，缺點是需要自行設計 log 系統。如果你只是想把原本存在於 log/prodcution.log 搜集到 EFK Stack，那可以使用 3 的方式來整合 Rails-app 的 log。而如果你想蒐集 Rails 以外的 log 如 apache 或是 nginx 的 log，則可以使用 2 的方式。 Fluentd agent 與 Rails 的串接step 1: 使用 Gem 安裝 Fluentd這邊使用的方法是使用 gem 安裝，配合 rvm 方便管理，不會污染環境 1gem install fluentd -v &quot;~&gt; 0.12.0&quot; --no-ri --no-rdoc Error: 因為我的開發環境用的 Rails 版本較舊，bundler 使用的是 1.14.4，在開發的時候遇到錯誤訊息gems/bundler-1.14.4/lib/bundler/rubygems_ext.rb:45:in full_gem_path'。Solution：輸入 gem update --system 更新系統 gem 的版本。 step 2: 產生設定檔輸入以下指令 1fluentd --setup ./fluent 資料夾會變成這樣 12345$ tree ..└── fluent ├── fluent.conf └── plugin step 3: 啟動 fluentd1fluentd -c ./fluent/fluent.conf -vv &amp; 輸入後 fluentd 就可以順利跑起來了 step 4: 測試 fluentd 功能是否正常1require 'fluent-logger' 初始化 Fluentd 1Fluent::Logger::FluentLogger.open(nil, :host=&gt;'localhost', :port=&gt;24224) 來測試一下訊息 1Fluent::Logger.post(&quot;fluentd.test.follow&quot;, {&quot;from&quot;=&gt;&quot;userA&quot;, &quot;to&quot;=&gt;&quot;userB&quot;}) 結果 12017-05-09 15:09:00 +0800 [warn]: fluent/agent.rb:170:emit: no patterns matched tag=&quot;fluentd.test.follow&quot; 可以看到 fluentd 並沒有成功收到我們想記錄的 log，並發現警告訊息，原因是 Fluentd 蒐集 log pattern 並沒有包含 fluentd.test.follow step 5: 讓 Fluentd 可以蒐集到我們要的 log pattern來修改 Fluentd 的設定檔，打開設定檔： 1vim ./fluent/fluent.conf 加入 pattern 1234&lt;match fluentd.test.follow.**&gt; @type stdout @id stdout_output&lt;/match&gt; 重新啟動 fluentd，再記錄一次 log 看看： 12Fluent::Logger::FluentLogger.open(nil, :host=&gt;'localhost', :port=&gt;24224)Fluent::Logger.post(&quot;fluentd.test.follow&quot;, {&quot;from&quot;=&gt;&quot;userA&quot;, &quot;to&quot;=&gt;&quot;userB&quot;}) 結果 12017-05-09 15:16:19 +0800 fluentd.test.follow: {&quot;from&quot;:&quot;userA&quot;,&quot;to&quot;:&quot;userB&quot;} 這樣就完成單機上的 fluentd-agent 與 Rails Application 的串接了。 介紹 Forward Input PluginFluentd 蒐集 Rails 的 Log 的時候，並不是使用讀取檔案的方式。而是使用 forward input plugin 來幫助蒐集。forward input plugin 是一個可以蒐集 tcp 或是 utp 協定的 fluentd plugin。 forward Input Plugin - Fluentd 參考資料Quickstart Guide - FluentdInstalling Fluentd Using Ruby Gem - FluentdCentralize Logs from Ruby Applications - Fluentd","link":"/2017/05/16/old%20posts/2017-05-16-rails-connect-to-fluentd/"},{"title":"EFK(4) - 讓 Elasticsearch 與 Kibana 能夠接收 Rails 的 log","text":"架構 安裝步驟2.1 安裝 elasticsearch123$ curl -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.0.2.tar.gz$ tar zxvf elasticsearch-5.0.2.tar.gz$ cd elasticsearch-5.0.2 啟動 elasticsearch 1$ ./bin/elasticsearch 2.2 安裝 Kibana123curl -O https://artifacts.elastic.co/downloads/kibana/kibana-5.0.2-darwin-x86_64.tar.gz$ tar zxvf kibana-5.0.2-darwin-x86_64.tar.gz$ cd kibana-5.0.2-darwin-x86_64 啟動 kibana 1$ ./bin/kibana 2.3 安裝 fluentd透過fluentd 的 elasticsearch 套件fluent-plugin-elasticsearch我們可以讓 fluentd 輸出的 log 變成 logstash 輸出的格式，這樣一來 kibana 就可以顯示我們儲存的 log。 安裝 fluent-plugin-elasticsearch 1fluent-gem install fluent-plugin-elasticsearch --no-document 設定 fluentd 設定檔 12mkdir td-agenttouch ./td-agent/td-agent.conf 編輯 td-agent.conf因為 Rails 是使用 forward input，我們只需要開啟 forward input 就好。如果你想監測其他的 log 類型例如：syslog，也可以透過設定 source 來達成。 1234567891011121314151617# get logs from syslog#&lt;source&gt;# @type syslog# port 42185# tag syslog#&lt;/source&gt;# get logs from fluent-logger, fluent-cat or other fluentd instances&lt;source&gt; @type forward&lt;/source&gt;&lt;match syslog.**&gt; @type elasticsearch logstash_format true flush_interval 10s # for testing&lt;/match&gt; 執行 fluentd 1fluentd -c ./fluent/td-agent.conf -vv 參考資料Free Alternative to Splunk Using Fluentd - Fluentd","link":"/2017/05/17/old%20posts/2017-05-17-fluentd-connect-to-elasticsearch-kibana/"},{"title":"EFK(5) - Fluentd 高可用架構(High Availibity)","text":"架構之前我們的架構是直接由 fluentd td-agent 傳送到 elasticsearch (如下圖) 為了更高的可用性(High Availibity)，我們在中間加入 aggregator 的角色，讓在 td-agent 扮演 forwarder 角色，職責更加單一，forwarder 只負責「傳送資料給 aggregator」。過濾(filter)資料的工作轉由 aggregator 負責，這樣的架構下降低了原本應用程式伺服器(application server)的負擔，提供了更高的可用性。架構如下： 實際配置方式2.1 如何配置 Forwarder1234567891011121314151617181920212223242526272829303132# TCP input&lt;source&gt; @type forward port 24224&lt;/source&gt;# HTTP input&lt;source&gt; @type http port 8888&lt;/source&gt;# Log Forwarding&lt;match mytag.**&gt; @type forward # primary host &lt;server&gt; host 192.168.0.1 port 24224 &lt;/server&gt; # use secondary host &lt;server&gt; host 192.168.0.2 port 24224 standby &lt;/server&gt; # use longer flush_interval to reduce CPU usage. # note that this is a trade-off against latency. flush_interval 60s&lt;/match&gt; 2.2 如何配置 Aggregator12345678910# Input&lt;source&gt; @type forward port 24224&lt;/source&gt;# Output&lt;match mytag.**&gt; ...&lt;/match&gt; 參考資料Fluentd High Availability Configuration - Fluentd","link":"/2017/05/18/old%20posts/2017-05-18-efk-high-availbility/"},{"title":"EFK(6) - 使用 docker 包裝 Fluentd","text":"Aggregator 與 Forwarder 使用 docker 建立 fluentd image為了模擬需要的環境，我們來使用 docker 建立 fluentd image 參考fluent/fluentd-docker-image來製作個人化的 fluentd image 2.1 準備工作建立 custom-fluentd 資料夾 1mkdir custom-fluentd 建立 plugin 資料夾 12cd custom-fluentdmkdir plugins 下載 Dockerfile 範例 1curl https://raw.githubusercontent.com/fluent/fluentd-docker-image/master/Dockerfile.sample &gt; Dockerfile 下載 fluent.conf 範例 1curl https://raw.githubusercontent.com/fluent/fluentd-docker-image/master/fluent.conf.erb &gt; fluent.conf 2.2 製作 Fluentd Log Aggregator Image1234567891011121314151617181920FROM fluent/fluentd:onbuildLuka &lt;Luka@gmail.com&gt;USER rootRUN apk add --update --virtual .build-deps \\ sudo build-base ruby-dev \\ # cutomize following instruction as you wish &amp;&amp; sudo -u fluent gem install \\ fluent-plugin-secure-forward \\ &amp;&amp; sudo -u fluent gem sources --clear-all \\ &amp;&amp; apk del .build-deps \\ &amp;&amp; rm -rf /var/cache/apk/* \\ /home/fluent/.gem/ruby/2.3.0/cache/*.gemUSER fluentEXPOSE 24284 因為我們需要輸出給 Elasticsearch Kibana 可以接收的格式，所以需要安裝 elasticsearch plugin 在的下面fluent-plugin-secure-forward \\加上 fluent-plugin-elasticsearch \\ 變成： 1234# cutomize following instruction as you wish&amp;&amp; sudo -u fluent gem install \\ fluent-plugin-secure-forward \\ fluent-plugin-elasticsearch \\ Aggregator 與 Forwarder 不同之處會是 config 檔與 plugin 的安裝，因為 Forwarder 不負責過濾與輸出 log 格式，只負責運送 Log，以此觀念下我們來構建 Fluentd 的高可用架構。 編輯 fluntd.conf (官方 image 所設定路徑)input 使用 forward 來接收從 Fowarder 傳過來的 log。output 傳送到 elasticsearch。 123456789101112# Input&lt;source&gt; @type forward port 24224&lt;/source&gt;# Output&lt;match fluentd.es.**&gt; @type elasticsearch logstash_format true flush_interval 1s # for testing&lt;/match&gt; 產生 docker image 的方法是到剛剛我們編輯好的 Docker File 資料夾底下(包含 config 檔案)輸入 1docker build -t my-fluentd-aggregator:1.0 ./ 編譯完成後即會有叫做 my-fluentd-aggregator 的 image 可以使用。 接著輸入 docker run -p 24224:24224 custom-fluentd 即可啟動 container，並 bind 至本機 24224 port 上。 2.3 製作 Fluentd Log Aggregator ImageForwarder 也是如法炮製，差別在於 Dockerfile 不需加上 Elasticsearch Output 套件。 並修改 fluent.conf 檔： 12345678910111213141516171819202122232425262728293031323334353637# input&lt;source&gt; @type forward port 24224&lt;/source&gt;# forward to aggregator&lt;match fluentd.forwarder.**&gt; @type forward send_timeout 10s heartbeat_interval 1s heartbeat_type tcp # optional recover_wait 10s phi_threshold 16 hard_timeout 10s buffer_type file buffer_path ~/splashtop/EFK/buffer/ buffer_chunk_limit 8m buffer_queue_limit 4096 flush_interval 5s retry_wait 20s &lt;server&gt; # primary host host xxx.xxx.xxx.xxx port 25225 &lt;/server&gt; &lt;server&gt; host 192.168.0.2 port 24224 standby &lt;/server&gt;&lt;/match&gt; 完成後輸入 1docker build -t my-fluentd-forwarder:1.0 ./ 編譯完成後即會有叫做 my-fluentd-forwarder 的 image 可以使用。 接著輸入 docker run -p 24225:24224 custom-fluentd 即可啟動 container，並 bind 至本機 24225 port 上。 使用 docker-compose 整合容器可以使用 docker-compose 節省 build 的動作。新增檔案 docker-compose.yml，輸入以下內容： 12345678910version: '1'services: forwarder: build: ./fluentd-forwarder ports: - &quot;24224:24224&quot; aggregator: build: ./fluentd-aggregator ports: - &quot;24225:24224&quot; 輸入 docker-compose up 一次 build forwarder 和 aggregator 兩個 image，並將容器跑起來。 實際運作實際運作的時候只需將 fluent.conf 中的 ip 位置，改成真實 Server IP，即可開始運作。","link":"/2017/05/19/old%20posts/2017-05-19-use-docker-to-build-efk-stack/"},{"title":"Go - 在 OSX 安裝 GVM","text":"前言之前有寫過一篇用 Brew 安裝 GO，因為習慣上會用 rvm、nvm 來管理程式語言的版本，所以心血來潮也想試試看安裝 GVM 在作業環境，不過如標題所示，gvm Bug 滿多，而且跟我慣用的 Fish shell 不太相容。總結下來，如果使用 OSX 環境推薦大家使用 Brew 來安裝。 安裝 GVM安裝 gvm 完成後會跳出錯誤，沒有 gcc，所以我們來裝 gcc 。 安裝 gcc1brew install gcc 安裝完成後輸入 gcc，結果： 1&gt; Unknown command 'gcc' brew 安裝的 gcc 並不能讓你直接用指令使用。安裝完成後切換至 /usr/local/bin 資料夾，輸入 ls 查看資料夾。 並沒有直接對應到 gcc，而是 gcc-4.9，來測試看看 gcc-4.9 能否正常動作： 123456789$ /usr/local/bin/gcc-4.9 -vUsing built-in specs.COLLECT_GCC=/usr/local/bin/gcc-4.9COLLECT_LTO_WRAPPER=/usr/local/Cellar/gcc@4.9/4.9.3/bin/../libexec/gcc/x86_64-apple-darwin15.0.0/4.9.3/lto-wrapperTarget: x86_64-apple-darwin15.0.0Configured with: ../configure --build=x86_64-apple-darwin15.0.0 --prefix=/usr/local/Cellar/gcc49/4.9.3 --libdir=/usr/local/Cellar/gcc49/4.9.3/lib/gcc/4.9 --enable-languages=c,c++,objc,obj-c++ --program-suffix=-4.9 --with-gmp=/usr/local/opt/gmp4 --with-mpfr=/usr/local/opt/mpfr2 --with-mpc=/usr/local/opt/libmpc08 --with-cloog=/usr/local/opt/cloog018 --with-isl=/usr/local/opt/isl011 --with-system-zlib --enable-libstdcxx-time=yes --enable-stage1-checking --enable-checking=release --enable-lto --with-build-config=bootstrap-debug --disable-werror --with-pkgversion='Homebrew gcc49 4.9.3' --with-bugurl=https://github.com/Homebrew/homebrew-versions/issues --enable-plugin --disable-nls --enable-multilibThread model: posixgcc version 4.9.3 (Homebrew gcc49 4.9.3) OK 看來沒問題！剩下的是把 gcc 指令對應 /usr/local/bin/gcc-4.9，輸入以下指令： 1ln -s /usr/local/bin/gcc-4.9 gcc 來測試看看 gcc 指令： 12345678$ gcc -vUsing built-in specs.COLLECT_GCC=gccCOLLECT_LTO_WRAPPER=/usr/local/Cellar/gcc@4.9/4.9.3/bin/../libexec/gcc/x86_64-apple-darwin15.0.0/4.9.3/lto-wrapperTarget: x86_64-apple-darwin15.0.0Configured with: ../configure --build=x86_64-apple-darwin15.0.0 --prefix=/usr/local/Cellar/gcc49/4.9.3 --libdir=/usr/local/Cellar/gcc49/4.9.3/lib/gcc/4.9 --enable-languages=c,c++,objc,obj-c++ --program-suffix=-4.9 --with-gmp=/usr/local/opt/gmp4 --with-mpfr=/usr/local/opt/mpfr2 --with-mpc=/usr/local/opt/libmpc08 --with-cloog=/usr/local/opt/cloog018 --with-isl=/usr/local/opt/isl011 --with-system-zlib --enable-libstdcxx-time=yes --enable-stage1-checking --enable-checking=release --enable-lto --with-build-config=bootstrap-debug --disable-werror --with-pkgversion='Homebrew gcc49 4.9.3' --with-bugurl=https://github.com/Homebrew/homebrew-versions/issues --enable-plugin --disable-nls --enable-multilibThread model: posixgcc version 4.9.3 (Homebrew gcc49 4.9.3) It’s working!! lion - How to set gcc 4.8 as default gcc compiler - Ask Different 安裝 GO 1.4要安裝 go 1.4 以上的版本前，你得先安裝 go 1.4。而安裝 go 1.4 的時候會遇到以下的 bug: 12345$ gvm install go1.4Installing go1.4... * Compiling...ERROR: Failed to compile. Check the logs at /Users/andrew/.gvm/logs/go-go1.4-compile.logERROR: Failed to use installed version 這邊有個 work around 的方式，使用 binary 檔安裝。 1gvm install go1.4 --binary go1.4 compile error in Mac OS 10.11 · Issue #217 · moovweb/gvm 安裝 GO 1.8安裝完成後要設定 GOROOT_BOOTSTRAP 變數，這樣就可以安裝 go 1.4 以上的版本了 1234gvm install go1.4gvm use go1.4export GOROOT_BOOTSTRAP=$GOROOTgvm install go1.8 expo Error with go1.5 install · Issue #155 · moovweb/gvm 將 gvm 指定加到 shellbash要將 gvm 指令加到 bash，將以下指令加到 ~/.bashsrc 123456# added gvm command to shellsource &quot;$HOME/.gvm/scripts/gvm&quot;# directory path for GOexport GOPATH=$HOME/gopathexport GOROOT=$HOME/goexport PATH=$PATH:$GOROOT/bin fish要將 gvm 指令加到 fish shell，把以下指令加到 ~/.config/fish/config.fish 123function gvm bass source ~/.gvm/scripts/gvm ';' gvm $argvend Fish shell環境でgvmを導入する - メンチカツ","link":"/2017/05/21/old%20posts/2017-05-21-gvm-in-osx/"},{"title":"CORS in Rails","text":"Problem跨網域存取的時候需要使用 CORS 來讓不同網域也可以存取相同網域的資源。請看下圖，Server 返回的 Response 必須明確指出哪些網域可以存取該 Server 的資源。有這樣的行為模式的話，是不是可以在 Controller 中的 Response 加上 Header 來達成 CORS 呢？ 答案是否定的。 因為當 PUT 或是 POST … 等等的 HTTP Verb 使用 CORS 時，需要先使用 PATCH 這個 HTTP Verb 來確認有沒有跨網域存取的權限。當 PATCH 動作打到 Rails Route 的時候，就會發現，沒有對應的 Route，於是就回 404 了。 (圖片來源: MDN) Solution所以如果以後有 CORS 需求的話，請使用 gem ‘rack-cors’，從 middleware 層處理 CORS，會是比較萬用的解法。","link":"/2017/05/20/old%20posts/2017-05-20-cors-in-rails/"},{"title":"Time in Rails","text":"Rails 中的時間Rails 中的時間是個有趣的議題，如果不多加注意，很容易被雷到。尤其是一般在本地端開發的的時候並不會有時區不同的問題，但是一放到 Server 上，\b就會忽然爆炸。是不能不小心的一個問題。如果你在 config/application.rb 設定 Time.zone，範例如下: 1config.i18n.default_locale = &quot;zh-TW&quot; 如果透過 ActiveRecord 來存取，取得的會是你在 application.rb 裡面設定的 Time.zone比如說你有一個 User 物件: 123user = User.firstuser.created_at.zone# =&gt; &quot;CST&quot; CST 即中原標準時間. it’s right! Time.now VS Time.current接著來比較 Time.now 和 Time.current 1234Time.now.zone=&gt; &quot;UTC&quot;Time.current.zone=&gt; &quot;CST&quot; 很明顯的可以看到\b，如果是 Time.now 的話回傳的會是格林威治時間 UTC, 但若是使用 Time.current 回傳的則會是我們在 config/application.rb 裡面設定的 Time.zone。究竟為什麼會有這個差異呢? 其實很簡單，因為 Time.now 是 Ruby 的原生物件，而 Time.current 是 Rails ActiveSupport 的物件。 1234Time.now.class=&gt; TimeTime.current.class=&gt; ActiveSupport::TimeWithZone \b我們再來做個測試，來看看剛剛的 user.created_at 是不是真的如果們所想: 12User.last.created_at.class=&gt; ActiveSupport::TimeWithZone 太棒了! 果然如此，這樣一來是不是很容易理解 Rails 的時間了。 Rails 時間的另一個重點 - SQLRails 時間另一個需要注意的地方是 SQL 的時間。來比較一下使用 Time.now 和 Time.current 在 ActiveRecord Relation 中的時間: 12345User.where(&quot;created_at &gt; ?&quot;, Time.now)#=&gt; SELECT &quot;users&quot;.* FROM &quot;users&quot; WHERE &quot;users&quot;.&quot;deleted_at&quot; IS NULL AND (created_at &gt; '2017-11-17 14:46:01.698018')User.where(&quot;created_at &gt; ?&quot;, Time.current)#=&gt; SELECT &quot;users&quot;.* FROM &quot;users&quot; WHERE &quot;users&quot;.&quot;deleted_at&quot; IS NULL AND (created_at &gt; '2017-11-17 14:46:09.655406') 筆者在測試的時候是台北時間(CST)晚上 22:46，可以發現兩者依賴的時區都是在 config/application.rb 設定的時區。","link":"/2017/10/23/old%20posts/2017-10-23-time-in-rails/"},{"title":"使用 GIT Precommit hooks 防止 Binding.pry 進入 Commit","text":"Problem如果不小心把 binding.pry commit 進 git 而且不幸的 push 的話, 勢必要使用另一個 commit 來修正。如果要讓這個 commit 不見可能就需要用 git push -f 來修改。這樣做很醜，不優雅。根治的方法是 - 根本不應該將 debug code 進入 commit 。但是人總是會有不小心的時候。最近發現一個工具可以做到這件事情: GIT Precommit hooks。 What is GIT Precommit hooks?GIT Precommit hooks 是一種可以在你每次 Commit 之前的 Callback。每次 Commit 前都會執行。我們利用這個特性，可以用來檢查，防止如 Binding.pry 的 Debug Code 進入 Git 中。 Solution 1 - Use Script在你的 git 專案底下，.git/hooks/pre-commit.sample 這是 Precommit hook 編寫的範本。將 .sample 結尾去除掉，就可以真正作用在當前的 Git 專案目錄上。不過因為我們想作用的是在 Rails 專案上，所以需要客製化腳本。 這邊已經有寫好的腳本: Source Code 1.1 How to Use切換到專案底下 1cd project_name 下載腳本 1curl https://raw.githubusercontent.com/Luka/githooks/master/pre-commit &gt; .git/hooks/pre-commit 讓腳本擁有執行的權限 1chmod +x .git/hooks/pre-commit 做完這些已經具有自動檢查的功能了 1.2 Demo123456git commit -m &quot;hello world&quot;File: app/views/company/jobs/new.html.slim:99:binding.pryThere are some occurrences of console.log|debugger|binding.pry at your modification.Are you sure want to continue? (y/n) looks great! 1.3 referenceGIT Precommit hooks Basics : Block debug command from commit Solution 2 - Use Gem如果嫌上述方法麻煩，不好管理。也可以考慮使用 Gem 來管理 Precommit HookGem 'pre-commit' 可以做到這件事情。把 pre-commit 加入你的開發環境。 Usage123group :development do gem &quot;pre-commit&quot;, require: falseend 接著輸入 bundle 更新 Gem Set 1bundle 設定需要的 check 1git config pre-commit.checks &quot;[pry, debugger,yaml]&quot; 要取消某個設定 1git config pre-commit.checks &quot;[pry, debugger]&quot; 可\b檢查的項目可到 github 查詢 jish/pre-commit: A slightly improved pre-commit hook for git","link":"/2017/12/06/old%20posts/2017-12-06-git-precommit-hooks-copy/"},{"title":"Web 基本功 - Cookie 與 Session","text":"Cookie1.1 什麼是 Cookie ?Cookie 在使用者第一次進入網站的時候產生。Browser 記錄一些隱私性較低的資料。例如: 使用者第一次進入網站的時候會跳出教學視窗。當使用者點擊[關閉]後，Cookie內記錄使用者已經看過教學了。使用者在下次登入的時候因為 Cookie 內記錄著使用者已經看過教學，所以就不會跳出教學視窗。 1.2 Cookie 的特性 每個網站的 Cookie 是分開的, 例如: www.google.com 無法取得 www.yahoo.com 的 cookie。 能夠設定失效的時間。比如說過一段時間你就需要重新登入，就是由設定 Cookie Expired Time 來完成。有時候為了方便，也可能將 Cookie 設定為永久不失效。 1.3 Server 端如何讓 Browser 儲存 Cookie Client 請求 Server 給予頁面 Server 回 Response 給 Browser 的時候，HTTP Header 帶上 Set-Cookie。Browser 接收到 Set-Cookie 指令時，會將 Cookie 的名稱和值儲存在 Browser 的 Cookie。 1.4 Browser 在每次 Request 的時候會帶上 CookieBrowser 在每次對 Server 發出 Request 的時候會帶上 Cookie 的 Header，讓 Server 能夠正確的存取當前 Cookie。 Session2.1 什麼是 SessionSession 就像你進入一個遊樂園，手上先蓋個章，下次進入的時候就知道你是誰。遊樂園就好比是 Server，你就好比是 Client (Browser)。Client 要怎麼儲存這個章呢? 有兩種方法: 使用 Cookie (set cookie) 使用 html 儲存，例如: hidden input。 拿章去 Server 換資料也有兩種方法: 使用 Cookie Query string/POST 因為實作上的方便程度與效能考量，大部分的網站採用 Cookie 來完成 Session 的實作。 2.2 Cookie-based Session 與 Session StorageCookie-based Session 指的 Session 儲存的方式不同，而不是拿章去 Server 換資料的時候有沒有使用 Cookie。 常見的 Session Storage 有這幾種: Database Memcached Cookie 2.3 比較 Cookie-based Session 與 Memcached Store Session來比較一下這兩者的優缺點。 Cookie-based Session 的優點: 對伺服器的效能負擔很低 方便使用 缺點: 大小最多存4Kb。 資料存放在瀏覽器上如果 config/secrets.yml 外流可能存在被破解的風險 (詳見 Rails CookieStore 的安全議題)。 Memcached Store Session 的優點: memcached 使用記憶體來儲存，讀取速度快。 可以實現集中式管理。 不會受到 cookie 4kb 大小的限制。 缺點： 儲存方式用記憶體，持久化有疑慮。 在追求高性能高併發的情景下，cookies 的表現更好，因此很多大網站採用 cookies 作為 session store. 2.4 Session 傳值Session 傳值指的是利用 Session 儲存資料的機制，讓不同頁面間可以互相傳遞資料。 使用 Query String 或是 POST 把資料往 Server 傳 Server 將收到的資料存到 Session 中。 在不同頁面的時候因為你的章是同一個，可以讀取 Session 中儲存的資料也是同一份，達到傳值的目的。 Rails 中的 Cookie-based Session 安全性問題Rails 3 以前 cookie-based session 如果不特別設定，可以輕易的被解開: 123require 'base64'session_cookie = 'your session cookie'Marshal.load(Base64.decode64(sesson_cookie.split('--').first)) 解開後會像這個樣子 123456{ &quot;session_id&quot; =&gt; &quot;3223668cb4b04296c006e190ce2b1a17&quot;, &quot;user_return_to&quot; =&gt; &quot;/&quot;, &quot;flash&quot; =&gt; #&lt;ActionDispatch::Flash::FlashHash:0x007f80d1090250 @used=#&lt;Set: {:alert}&gt;, @closed=false, @flashes={:alert=&gt;&quot;You need to sign in or sign up before continuing.&quot;, :warning=&gt;nil, :error=&gt;nil, :notice=&gt;nil}, @now=nil&gt;, &quot;_csrf_token&quot; =&gt; &quot;BxX8rLulhq2v2YSKrLxIIkYeV4IYNTNceT2ib1BrO08=&quot;} Rails 4 以後的 Cookie-based Session 會經過 Secret 加密。好好保護你的 config/secret.yml 能夠讓 Session 中的隱密資料不會被解開，從下面 code 可以看出要解開的話需要不少的麻煩: 123456789101112131415161718192021222324252627require 'rubygems'require 'cgi'require 'active_support'def decrypt_session_cookie(cookie, key) cookie = CGI::unescape(cookie) # Default values for Rails 4 apps key_iter_num = 1000 key_size = 64 salt = &quot;encrypted cookie&quot; signed_salt = &quot;signed encrypted cookie&quot; key_generator = ActiveSupport::KeyGenerator.new(key, iterations: key_iter_num) secret = key_generator.generate_key(salt) sign_secret = key_generator.generate_key(signed_salt) encryptor = ActiveSupport::MessageEncryptor.new(secret, sign_secret) puts encryptor.decrypt_and_verify(cookie)end# Time to test ... (With data from Arbeit327)cookie = 'WVFQVTFtbmNxWWJPODZNb3NUMVZzZGtDVjZQNXpMYStFMWdiZlJPMkdjRFRBOGZ5T3pOTzBPKzk3NWxvQUJvTlRRU2t4MXZmdG8rT0I0R2M3Ulh0YXpxRVhNMll5UW1xUHhvVXBLbXozZ3ZyNjB4VDU4dWRIUkxBWjBXbDJhci93YkYrZWswUHdFL0hUNDJaUHo2cEpxbXFvdlFZMjJWVU9KTWhHb3NyalFwTkphd0pUQVZSTXRHbkVqRlFnSGpNVTNFQlVxYlRmT3pWbXNjK0JuQ3FydzQvODRhbmtuU29haGNRbXQ4T3o1ZjhqMk53WTRMa0pVd1hPb2NHTVFQY3dvanE2ZElqUk1Mc21HS0k2SHVuZEZ3OWhjdzZPQnRSMEdVVkQwL2IxSVh5QzNSWVlJZms5c1JJV0lzUE1Zb1NHbEtqYm5nTGRKd1ZSdGpOQ1RZZWthR1A2anRFMEluaTcyWTNaNHJBR1N0dklzMkg1RjVmVmY4azEzV3o0N2Z2LS1wQlowRUZ6cjI3SVFQU0F5bGlYSDNnPT0%3D--19650cc5c3e2599fb43b7235ab4de5a1ce8a46ac'key = 'aeb977de013ade650b97e0aa5246813591104017871a7753fe186e9634c9129b367306606878985c759ca4fddd17d955207011bb855ef01ed414398b4ac8317b'decrypt_session_cookie(cookie, key) references介紹 Session 及 Cookie 兩者的差別說明 FRED - Web 技術中的 Session 是什麼？ Rails CookieStore 的安全議題 - Shaolin.TW The Will Will Web - 解釋 Cookie 的特性 A simple script to decode Rails 4 session cookies","link":"/2017/12/22/old%20posts/2017-12-22-web-foundation-the-different-of-cookie-and-session/"},{"title":"OLTP 與 OLAP","text":"什麼是 OLTP?最近在讀資料庫文件的時候接觸到 OLTP 這個名詞，大致上理解並比記下來。數據處理大致可以分成兩類: OLTP 與 OLAP。OLTP (Online Analytical Processing)指的就是傳統式關聯式資料庫。用在日常的的事物處理，比如說資料庫的增、刪、查、改。有以下特性: 並發性高 嚴格要求事務的種安全性 Realtime 要求高 什麼是 OLAP?OLAP (On-Line Analytical Processing) - 數據分析處理。是一個以決策為導向的數據處理方式，針對你想要做的決策，動態處理資料，用多種維度來解讀資料，讓高階主管可以做出更好的決策。 OLAP支援的分析包刮下列幾點: 階層式維度與資料的模組化 趨勢分析 解讀深層資訊 於視覺範圍內轉換於另一維度以作比較 個人覺得認為 OLAP 更像一種分析方法論，與現今的資料視覺概念相似，將資料經過加工處理後，由萃取出來的數據來幫助做決策。 比較表 ReferenceOLTP vs. OLAPOLAP example","link":"/2017/12/22/old%20posts/2017-12-29-oltp-vs-olap/"},{"title":"[譯] Amazon S3 Delimiter and Prefix","text":"From: Amazon S3 Delimiter and Prefix - realguessposted at 2014/05/24 AWS S3 是一個不昂貴的線上檔案儲存服務，我們可以透過 javascript SDK 來使用 S3。當我使 SDK 的時候有以下幾件令人疑惑的事情: 如何使用參數 Delimiter 和 Prefix ? CommonPrefixes 與 Contents 的差別是什麼? 如何透過 Javascript SDK 建立 folder / directory 取回在 Amazon S3 Bucket 的物件得操作 (operation) 是 listObject. listObjects 不會回傳 (return) 物件的內容, 而會回傳 key 與 meta data 像是物件的大小 (size) 或是物件的擁有者。 使用指令呼叫以取得 bucket 中的物件清單: 123s3.listObjects(params, function (err, data) { // ...}); params 可以設置以下的參數: Bucket Delimiter EncodingType Marker MaxKeys Prefix 但是什麼是 Delimeter 和 Prefix? 如何使用他們? 我們開始在 S3 中創建一些物件，格式如下方的檔案結構。這可以用 Aws Console 很快的完成。 1234567.├── directory│ ├── directory│ │ └── file│ └── file└── file2 directories, 3 files 在 Amazon S3 中，這些物件為: 12345directory/directory/directory/directory/directory/filedirectory/filefile 一個需要留心的事情是 S3 不是檔案系統。S3 並沒有真正的檔案或是資料夾的概念。從 Console 中看到的是 2 個資料夾和 3 個檔案。但是它們全部都是物件。這些物件會用他們的 Key 值按照字母排序。 為了讓概念更清楚點，我們來調用 (invoke) 方法 listObjects。而這個操作只需要參數 Bucket。 123params = { Bucket: 'example'}; Response data 包含下列的 callback function: 12345678910111213141516171819202122232425262728293031323334353637{ Contents: [ { Key: 'directory/', LastModified: ..., ETag: '&quot;d41d8cd98f00b204e9800998ecf8427e&quot;', Size: 0, Owner: [Object], StorageClass: 'STANDARD' }, { Key: 'directory/directory/', LastModified: ..., ETag: '&quot;d41d8cd98f00b204e9800998ecf8427e&quot;', Size: 0, Owner: [Object], StorageClass: 'STANDARD' }, { Key: 'directory/directory/file', LastModified: ..., ETag: '&quot;d41d8cd98f00b204e9800998ecf8427e&quot;', Size: 0, Owner: [Object], StorageClass: 'STANDARD' }, { Key: 'directory/file', LastModified: ..., ETag: '&quot;d41d8cd98f00b204e9800998ecf8427e&quot;', Size: 0, Owner: [Object], StorageClass: 'STANDARD' }, { Key: 'file', LastModified: ..., ETag: '&quot;d41d8cd98f00b204e9800998ecf8427e&quot;', Size: 0, Owner: [Object], StorageClass: 'STANDARD' } ], CommonPrefixes: [], Name: 'example', Prefix: '', Marker: '', MaxKeys: 1000, IsTruncated: false } 如果有檔案結構，你會期待是: 12directory/file 但是並沒有，因為 bucket 運作的方式不像是 folder 或是 directory, 能夠顯示directory 中的檔案。檔案在 bucket 中會全部攤開來並且照字母排列。 在 Unit 中, directory 是檔案, 但是在 Amazon S3 中, 所有的東西都是物件,並且他們用 key 來識別。 所以，該如何讓 Amazon S3 表現的更像是 folder 或是 directory？ 或如何顯示 Bucket 中的第一層右邊的內容? 為了讓 S3 顯示的更像是 director, 你必須使用 Delimiter 和 Prefix. Delimeter 讓你可以為 key 分組 (use to group keys)。它必須是一個字元或者一個字串。Prefix 限制 response 開始於特別的 prefix。 Delimiter我們開始加入下列的 delimiter: 1234params = { Bucket: 'example', Delimiter: '/'}; 你會取得像是 directory 清單的一些資訊: 12345678{ Contents: [ { Key: 'file' } ], CommonPrefixes: [ { Prefix: 'directory/' } ], Name: 'example', Prefix: '', MaxKeys: 1000, Delimiter: '/', IsTruncated: false } 有一個資料夾叫做 directory/ 和一個檔案叫做 file. 發生的事情是下列的物件接受檔案被 delimeter / 分組。 12345directory/directory/directory/directory/directory/filedirectory/filefile 所以，結果是: 12directory/file 這感覺像是 directory 或是 folder 的清單。但如果我們把 Delimeter 改成 i, 接著你會取得空的 Contents 和 prefix。 1234567{ Contents: [], CommonPrefixes: [ { Prefix: 'di' }, { Prefix: 'fi' } ], Name: 'example', Prefix: '', MaxKeys: 1000, Delimiter: 'i', IsTruncated: false } 所有的 key 被 di 和 fi 這兩個 prefix 分組。因此，Amazon S3 不是檔案系統, 但是他們如果可以設定對的參數，那他們看起來就會像是檔案系統。 如之前提到的 Delimeter 不需要是單一的字元: 12345678910{ Contents: [ { Key: 'directory/' }, { Key: 'directory/file' }, { Key: 'file' } ], CommonPrefixes: [ { Prefix: 'directory/directory' } ], Name: 'example', Prefix: '', MaxKeys: 1000, Delimiter: '/directory', IsTruncated: false } 回想 bucket 的結構: 12345directory/directory/directory/directory/directory/filedirectory/filefile 由於分組字串/directory，directory/directory/ 和 directory/directory/file 被 prefix directory/directory 分組了。 我們來試試其他的 Delimiter: 'directory' 12345678{ Contents: [ { Key: 'file' } ], CommonPrefixes: [ { Prefix: 'directory' } ], Name: 'example', Prefix: '', MaxKeys: 1000, Delimiter: 'directory', IsTruncated: false } 好，接著來試試 ry/fi 123456789101112{ Contents: [ { Key: 'directory/' }, { Key: 'directory/directory/' }, { Key: 'file' } ], CommonPrefixes: [ { Prefix: 'directory/directory/fi' }, { Prefix: 'directory/fi' } ], Name: 'example, Prefix: '', MaxKeys: 1000, Delimiter: 'ry/fi', IsTruncated: false } 所以記得 Delimeter 只是提供將 key 分組的功能。如果你想要他們表現的像是檔案系統，那麼使用 Delimiter: '/'。 PrefixPrefix 更易於理解。它利用前綴來過濾(filter) keys。 相同的結構: 12345directory/directory/directory/directory/directory/filedirectory/filefile 我們來設定 Prefix 參數值為 directory: 12345678910{ Contents: [ { Key: 'directory/' }, { Key: 'directory/directory/' }, { Key: 'directory/directory/file' }, { Key: 'directory/file' } ], CommonPrefixes: [], Name: 'example', Prefix: 'directory', MaxKeys: 1000, IsTruncated: false } 看看設定成 directory/ 會怎麼樣: 1234567{ Contents: [ { Key: 'directory/' }, { Key: 'directory/directory/' }, { Key: 'directory/directory/file' }, { Key: 'directory/file' } ], CommonPrefixes: [], Prefix: 'directory/' } prefix 設成 directory 和 directory/ 是一樣的。如果我們嘗試一些不一樣的, Prefix: 'directory/d': 12345{ Contents: [ { Key: 'directory/directory/' }, { Key: 'directory/directory/file' } ], CommonPrefixes: [], Prefix: 'directory/d' } 同時使用 Delimiter: 'directory' and Prefix: 'directory': 123456{ Contents: [ { Key: 'directory/' }, { Key: 'directory/file' } ], CommonPrefixes: [ { Prefix: 'directory/directory' } ], Prefix: 'directory', Delimiter: 'directory' } 第一步，列出 prefix 是 directory 的清單: 1234directory/directory/directory/directory/directory/filedirectory/file 用 delimiter directory 與 prefix directory 來分組: 1directory/directory 結果的 Contents 會是: 12directory/directory/file CommonPrefixes 會是: 1directory/directory 也許改變 Delimeter 成 i 可以更好的理解: 12345{ Contents: [ { Key: 'directory/' } ], CommonPrefixes: [ { Prefix: 'directory/di' }, { Prefix: 'directory/fi' } ], Prefix: 'directory', Delimiter: 'i' } 12345directory/ # key to showdirectory/directory/ # group to 'directory/di'directory/directory/file # group to 'directory/di'directory/file # Group to 'directory/fi'file # ignored due to prefix 一個使用 Amazon S3 來列出 directory 的好處是你不需要顧慮巢狀的資料夾結構，所有東西都是扁平化的。所以你可以藉由特定的 Prefix 來 loop 出你要的資料。 Directory / Folder如果你使用 Amazon AWS console 來 Create Folder，你可以建立資料夾或是上傳檔案在該資料夾中。實際上，你使用了下列的 key 建立了兩個物件: 12directory/directory/file 如果你使用下列指令來上傳檔案，資料夾不會被建立: 1aws s3 cp file s3://example/directory/file 因為，Amazon S3 不是檔案系統，而是 key/value 的儲存空間。如果你使用 listObjects 方法，你可以看到一個物件。同理，你無法複製本地的資料夾： 12$ aws s3 cp directory s3://example/directoryupload failed: aws/ to s3://example/directory [Errno 21] Is a directory: u'/home/chao/tmp/directory/' 但我們可以用 JavaScript SDK 來創建 directory/folder: 1234s3.putObject({ Bucket: 'example', Key: 'directory/' }, function (err, data) { if (err) { return console.error(err); } console.log(data);}); 需要筆記的地方是: 你必須使用 directory/，結尾必須是斜線。此外，這只是一個檔案而不是資料夾。","link":"/2018/01/03/old%20posts/2018-01-03-aws-s3-delimiter-and-prefix/"},{"title":"[譯] 使用 AWS Ruby SDK v2 更新 S3 物件 Metadata","text":"From: Updating S3 Object Metadata With the AWS Ruby SDK v2Author: Mattposted at: 2017/5/31 今天我在 S3 就如同在玩火一樣 - 弄壞了一個網站. 我做了研究，徹底的測試了我的程式碼，接著按下了 enter. 之後沒多久，我的心掉落的和我的網站掛掉的速度一樣快。我決定寫下一篇速記來防止同樣的錯誤發生在其他人身上。 S3 不是資料庫不可能在 S3 中做到「更新」資料庫 - 在S3並沒有更新資料的方法。這在 Ruby SDK 與 AWS CLI 之中都是成立的。如果你項我一樣在找尋更新整個 Bucket 的物件來更新 metadata (舉例來說: 像是名為 Cache-Control 的 headers)，你將會需要使用 copy_to 方法。 讓我們開始認證和攫取我們的 bucket。 12345678require 'aws-sdk'Aws.config.update({ region: 'us-east-1', credentials: Aws::Credentials.new(&lt;AWS_ACCESS_KEY&gt;, &lt;AWS_SECRET_KEY&gt;)})s3 = Aws::S3::Resource.newbucket = s3.bucket('mattboldt-bucket') 現在我們可以透過每一個物件和複製它自己並且帶上一些新的 metadata. 注意我們使用 option metadata_directive: 'REPLACE' - 這個將會以新的 metadata 取代物件原有的 metadata。如果缺少它，我們將無法複製任何新的，而且會得到錯誤訊息如下： 1This copy request is illegal because it is trying to copy an object to itself without changing the object's metadata, storage class, website redirect location or encryption attributes 然而，取代 metadata 將會取代其它屬於這個物件的所有東西，例如: 權限(permission). 請勿執行以下的代碼。 123456789# the WRONG waybucket.objects.each do |object_summary| location = &quot;#{bucket.name}/#{object_summary.key}&quot; options = { cache_control: 'public, max-age=60', metadata_directive: 'REPLACE' # options: 'COPY' or 'REPLACE' } object_summary.copy_to(location, options)end 這是我所搞砸的。我更新的所有的 S3 物件因為缺少了讀的權限(read permissions)，接著 CDN 不再可以存取這些資料。現在看起來是一個很蠢的錯誤，但當時我對出錯的狀況沒有任何頭緒。 更新 / 複製物件並且保留原有的資訊讓我們再試一次；這次我們確保 request 包含(include)所有物件的欄位。這邊是一個可能的選項清單( list of possible options)，用途是傳送到 copy_to 方法。 1COPY_TO_OPTIONS = [:multipart_copy, :content_length, :copy_source_client, :copy_source_region, :acl, :cache_control, :content_disposition, :content_encoding, :content_language, :content_type, :copy_source_if_match, :copy_source_if_modified_since, :copy_source_if_none_match, :copy_source_if_unmodified_since, :expires, :grant_full_control, :grant_read, :grant_read_acp, :grant_write_acp, :metadata, :metadata_directive, :tagging_directive, :server_side_encryption, :storage_class, :website_redirect_location, :sse_customer_algorithm, :sse_customer_key, :sse_customer_key_md5, :ssekms_key_id, :copy_source_sse_customer_algorithm, :copy_source_sse_customer_key, :copy_source_sse_customer_key_md5, :request_payer, :tagging, :use_accelerate_endpoint] 用這個 List 武裝之後，我們抓取所有存在的資料並且 merge 到新的 option hash。我只想要加上驗證 (valid) 選項而不是使用 get 取得所有資訊，所以我使用 Array#slice 來對之前的清單做處理。 也需要注意的是，我使用在下面 object_summary.get - 這是因為物件的摘要並不包含 metadata, permission … 之類的東西。這會造成額外的開銷，但是此時我不確定還有其他任何方法可以達到同樣的目的。 12345678910111213141516171819202122232425262728293031bucket.objects.each do |object_summary| object = object_summary.get location = &quot;#{bucket.name}/#{object_summary.key}&quot; # Build a new options object options = {} # Merge in the object's existing properties existing_options = object.to_h.slice(*COPY_TO_OPTIONS) options.merge!(existing_options) # Add our new updates # The `acl` option here was very important in my case! options.merge!({ acl: 'public-read', # private, public-read, public-read-write, authenticated-read, aws-exec-read, bucket-owner-read, bucket-owner-full-control cache_control: 'public, max-age=60', metadata_directive: 'REPLACE' }) # multipart_copy is necessary if the object is 5GB+ if object.size &gt;= 5_000_000_000 options.merge!({multipart_copy: true}) else # Only used if multipart_copy is true options.delete(:content_length) end # Execute the copy! object_summary.copy_to(location, options)end 如果你的 bucket 的大小很大，這會用到一些時間。然而，你得知道 copy_to 方法發出請求至 S3 和不會從你的本地端上傳任何的資料。所以即使你複製到新的位置，你也不會重新上傳檔案。 這邊是完整的程式碼： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354require 'aws-sdk'require 'active_support'require 'active_support/core_ext'# http://docs.aws.amazon.com/sdkforruby/api/Aws/S3/Object.html#copy_to-instance_methodCOPY_TO_OPTIONS = [:multipart_copy, :content_length, :copy_source_client, :copy_source_region, :acl, :cache_control, :content_disposition, :content_encoding, :content_language, :content_type, :copy_source_if_match, :copy_source_if_modified_since, :copy_source_if_none_match, :copy_source_if_unmodified_since, :expires, :grant_full_control, :grant_read, :grant_read_acp, :grant_write_acp, :metadata, :metadata_directive, :tagging_directive, :server_side_encryption, :storage_class, :website_redirect_location, :sse_customer_algorithm, :sse_customer_key, :sse_customer_key_md5, :ssekms_key_id, :copy_source_sse_customer_algorithm, :copy_source_sse_customer_key, :copy_source_sse_customer_key_md5, :request_payer, :tagging, :use_accelerate_endpoint]Aws.config.update({ region: 'us-east-1', credentials: Aws::Credentials.new(AWS_ACCESS_KEY, AWS_SECRET_KEY)})s3 = Aws::S3::Resource.newbucket = s3.bucket('mattboldt-bucket')objects_count = bucket.objects.countcurrent_object = 0bucket.objects.each do |object_summary| # Get the object and all its metadata, permissions, etc object = object_summary.get # Copy to the same location location = &quot;#{bucket.name}/#{object_summary.key}&quot; # Build a new options object options = {} # Merge in the object's existing properties, but only keeping valid attributes for the copy_to method existing_options = object.to_h.slice(*COPY_TO_OPTIONS) options.merge!(existing_options) # Add our new updates options.merge!({ acl: 'public-read', # private, public-read, public-read-write, authenticated-read, aws-exec-read, bucket-owner-read, bucket-owner-full-control cache_control: 'public, max-age=60', metadata_directive: 'REPLACE' }) # multipart_copy is necessary if the object is 5GB+ if object.size &gt;= 5_000_000_000 options.merge!({multipart_copy: true}) else # Only used if multipart_copy is true options.delete(:content_length) end begin object_summary.copy_to(location, options) current_object += 1 puts &quot;Copied #{current_object} of #{objects_count}&quot; rescue =&gt; e puts &quot;Excption Raised: #{e}&quot; endend 最後如果你覺得這對你有幫助, 請 tweet @atMattb。謝謝閱讀。","link":"/2018/01/25/old%20posts/2018-01-25-use-aws-ruby-sdk-to-update-s3-metadata/"},{"title":"Mysql - 如何修改 partition 並還原資料","text":"在測試環境中我們想要置換 partition 的分區方式，而我們不想要遺失測試資料，所以需要備份 partition table 的資料。因為要修改的資料欄位很多，我不想要直接使用 alter table 的方式來修改 partition 分區，取而代之的是，我想要用 Migration 的方式來管理，所以會採用先備份 -&gt; 修改 -&gt; 接著再還原的方式。 深入了解 mysqldump一般我們在備份還原的時候會使用 Mysqldump，並使用還原指令來還原。但是因為這次我需要回復的資料已經經過 Partition 分區了。用一般的回復方式很可能會失敗。秉持的實驗精神，我就來看看 mysqldump 到底是怎麼運作的。輸入指令備份資料庫： 1mysqldump -u username -p your_database &gt; dump.sql 產生出來的檔案我們打開來看: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# dump.sql-- MySQL dump 10.13 Distrib 5.7.20, for osx10.11 (x86_64)---- Host: localhost Database: log_sharding-- -------------------------------------------------------- Server version 5.7.20/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;/*!40101 SET NAMES utf8 */;/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;/*!40103 SET TIME_ZONE='+00:00' */;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;---- Table structure for table `alert_logs`--DROP TABLE IF EXISTS `alert_logs`;/*!40101 SET @saved_cs_client = @@character_set_client */;/*!40101 SET character_set_client = utf8 */;CREATE TABLE `alert_logs` ( `id` int(11) NOT NULL AUTO_INCREMENT, `alert_id` int(11) DEFAULT NULL, `alert_code` varchar(30) COLLATE utf8_unicode_ci DEFAULT NULL, `alert_name` varchar(64) COLLATE utf8_unicode_ci DEFAULT NULL, `alert_time` datetime DEFAULT NULL, `alert_status` tinyint(2) DEFAULT '0', `created_at` datetime NOT NULL DEFAULT '2055-06-01 00:00:00', `updated_at` datetime DEFAULT NULL, PRIMARY KEY (`id`,`created_at`),) ENGINE=InnoDB AUTO_INCREMENT=4899 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci/*!50500 PARTITION BY RANGE COLUMNS(alert_time)(PARTITION p001 VALUES LESS THAN ('2018-01-01 00:00:00') ENGINE = InnoDB, PARTITION p002 VALUES LESS THAN ('2018-02-01 00:00:00') ENGINE = InnoDB, PARTITION p003 VALUES LESS THAN ('2018-03-01 00:00:00') ENGINE = InnoDB, PARTITION p004 VALUES LESS THAN ('2018-04-01 00:00:00') ENGINE = InnoDB, . . . . PARTITION p451 VALUES LESS THAN (MAXVALUE) ENGINE = InnoDB) */;/*!40101 SET character_set_client = @saved_cs_client */;---- Dumping data for table `alert_logs`--LOCK TABLES `alert_logs` WRITE;/*!40000 ALTER TABLE `alert_logs` DISABLE KEYS */;# This is fake dataINSERT INTO `alert_logs` VALUES (16,4),(49,12),(9,14),(21,17),(11,57),(71,63),(270,91),(86,180),(125,193),(99,201),(189,385),(271,390),(225,415),(305,484),(251,543),(309,545),(257,579),(258,581),(260,585),(261,588),(279,667);/*!40000 ALTER TABLE `alert_logs` ENABLE KEYS */;UNLOCK TABLES; 這不就是 SQL 的指令嘛？ 邏輯如下: 如果 alert_logs table 已經存在，就刪除掉並使用 Dump File 內的備份指令重新建立 alert_logs table lock 住整個 table 並加入資料。 從這些步驟我們可以觀察到即使 db 內已經存在 alert_logs table 了，使用 dump.sql 還原時仍然會先刪除 alert_logs table，再使用 dump.sql 中的 schema 來重建 table。 知道這些情報之後 partition 的 backup 與 restore 有了頭緒。 Partition backup and restore首先備份原先的 partition 1mysqldump -h 'your-my-sql-ip' -u your_user_name -p your_database_name table_name_1 table_name_2 --no-create-info --ssl-ca=your_ssl.pem &gt; dump.sql 關鍵在於: 需要加上 --no-create-info 產生的 dump.sql 不會把本來的 table 刪除，直接 insert 資料。 123456789101112131415161718192021222324252627# dump.sql-- MySQL dump 10.13 Distrib 5.7.20, for osx10.11 (x86_64)---- Host: localhost Database: pro_devel-- -------------------------------------------------------- Server version 5.7.20/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;/*!40101 SET NAMES utf8 */;/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;/*!40103 SET TIME_ZONE='+00:00' */;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;--alert_logs-- Dumping data for table `alert_logs`--LOCK TABLES `alert_logs` WRITE;/*!40000 ALTER TABLE `alert_logs` DISABLE KEYS */;INSERT INTO `alert_logs` VALUES (16,4),(49,12),(9,14),(21,17),(11,57),(71,63),(270,91),(86,180),(125,193),(99,201),(189,385),(271,390),(225,415),(305,484),(251,543),(309,545),(257,579),(258,581),(260,585),(261,588),(279,667);/*!40000 ALTER TABLE `alert_logs` ENABLE KEYS */;UNLOCK TABLES; 備份完資料後我們將原有的 database 刪除 1DROP TABLE alert_logs; 用新的 create partition 方法建立 table，將本來用 alert_time 做分區，改成用 created_at 做分區。 12345678910111213141516171819202122CREATE TABLE `alert_logs` ( `id` int(11) NOT NULL AUTO_INCREMENT, `alert_id` int(11) DEFAULT NULL, `alert_code` varchar(30) COLLATE utf8_unicode_ci DEFAULT NULL, `alert_name` varchar(64) COLLATE utf8_unicode_ci DEFAULT NULL, `alert_time` datetime DEFAULT NULL, `alert_status` tinyint(2) DEFAULT '0', `created_at` datetime NOT NULL DEFAULT '2055-06-01 00:00:00', `updated_at` datetime DEFAULT NULL, PRIMARY KEY (`id`,`created_at`),) ENGINE=InnoDB AUTO_INCREMENT=4899 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci/*!50500 PARTITION BY RANGE COLUMNS(created_at)(PARTITION p001 VALUES LESS THAN ('2018-01-01 00:00:00') ENGINE = InnoDB, PARTITION p002 VALUES LESS THAN ('2018-02-01 00:00:00') ENGINE = InnoDB, PARTITION p003 VALUES LESS THAN ('2018-03-01 00:00:00') ENGINE = InnoDB, PARTITION p004 VALUES LESS THAN ('2018-04-01 00:00:00') ENGINE = InnoDB, . . . . PARTITION p451 VALUES LESS THAN (MAXVALUE) ENGINE = InnoDB) */;/*!40101 SET character_set_client = @saved_cs_client */; 最後將資料還原 1mysql -u username -p database_name &lt; dump.sql 檢視一下目前的 table 1SHOW CREATE TABLE alert_logs; 確認結果是否正確檢視一下目前的 table 1SHOW CREATE TABLE alert_logs; 輸出 12345678910111213141516171819202122CREATE TABLE `alert_logs` ( `id` int(11) NOT NULL AUTO_INCREMENT, `alert_id` int(11) DEFAULT NULL, `alert_code` varchar(30) COLLATE utf8_unicode_ci DEFAULT NULL, `alert_name` varchar(64) COLLATE utf8_unicode_ci DEFAULT NULL, `alert_time` datetime DEFAULT NULL, `alert_status` tinyint(2) DEFAULT '0', `created_at` datetime NOT NULL, `updated_at` datetime DEFAULT NULL, PRIMARY KEY (`id`,`created_at`),) ENGINE=InnoDB AUTO_INCREMENT=4899 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci/*!50500 PARTITION BY RANGE COLUMNS(created_at)(PARTITION p001 VALUES LESS THAN ('2018-01-01 00:00:00') ENGINE = InnoDB, PARTITION p002 VALUES LESS THAN ('2018-02-01 00:00:00') ENGINE = InnoDB, PARTITION p003 VALUES LESS THAN ('2018-03-01 00:00:00') ENGINE = InnoDB, PARTITION p004 VALUES LESS THAN ('2018-04-01 00:00:00') ENGINE = InnoDB, . . . . PARTITION p451 VALUES LESS THAN (MAXVALUE) ENGINE = InnoDB) */;/*!40101 SET character_set_client = @saved_cs_client */; 確認建立 table 的資料無誤後，進入 Rails console 試試看 \bAlertLog 是否可以正常存取，這樣就完成了整個 partition 轉換並還原的流程。 地雷 - created_at需要特別注意的是 - partition 中 為 key 的值一定必須是 NOT NULL，且不要設 DEFAULT VALUE，否則 Rails 不會幫你自動填入 created_at。 Rails Migration如果你使用的是 Rails Migration，步驟是: backup entire database dump the partition database rake db:rollback modify migration of partition rake db:migrate restore partition database 參考資料DBAStuff: Mysql Dump and partitions","link":"/2018/03/04/old%20posts/2018-03-04-modify-and-restore-mysql-partition/"},{"title":"Hello Python","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2014/01/01/python/hello-world/"},{"title":"細讀 Bootstrap 3 文件","text":"使用Bootstrap好一段時間了，卻沒有好好的把官方文件讀過一遍，雖然寫的出來但是速度不盡理想，所以這兩天花些時間將幾個不太理解的常用元件與一些以前有使用到卻不太了解的data-attribute用法寫下筆記，好提高生產力。 Part 1: Navbar這是一個bootstrap官網上的完整navbar範例。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;nav class=&quot;navbar navbar-default|navbar-inverse&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-expanded=&quot;false&quot;&gt;Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;One more separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class=&quot;navbar-form navbar-left&quot; role=&quot;search&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-expanded=&quot;false&quot;&gt;Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt;&lt;/nav&gt; 外部的navnavbar的外部由nav包覆，但是這樣的作法其實不太妥當，因為有時候navbar中的元素並不完全是用來導覽(navigate)整個網站。所以我們將範例修改成使用div配合role=&quot;navigation&quot;來避免這個問題。 123456789&lt;nav class=&quot;navbar navbar-default|navbar-inverse&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; . . . &lt;/div&gt;&lt;/nav&gt; Use .container-fluid for a full width container, spanning the entire width of your viewport. Brand與手機版本的元素除了Brand以外的上半部程式碼顯示的是手機版本的畫面。 123456789101112&lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;!-- Brand 在這--&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Brand&lt;/a&gt; &lt;/div&gt; 容器navbar的容器有幾種： div.navbar-header裡面常裝brand與手機版網頁元素 ul.navbar-nav form.navbar-form ：在navbar中可以使用form，加上 .navbar-form可以讓form垂直置中。 123456789101112131415161718192021222324252627282930313233 &lt;div class=&quot;navbar-header&quot;&gt; . . . &lt;/div&gt;&lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt; &lt;!-- 我是ul.navbar-nav --&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; . . . &lt;/ul&gt; &lt;!-- 這是一個nav-form --&gt; &lt;form class=&quot;navbar-form navbar-left&quot; role=&quot;search&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt; &lt;!-- 向右對齊的非依序清單 --&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; . . . &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt; 最外層div class=&quot;collapse navbar-collapse&quot;讓這個navbar套用了reponsive design。reponsive navbar必須要有collapse plugin，不過不用擔心，bootstrap已經內建了collapse js plugin。 容器一：navbar-navul.navbar-nav本質上是unorder list ( ul )，裡面可以裝的元素必須為List item( li ) 。裡面可以裝： Link Dropdown link的例子如下：內部可以加上連結 1&lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; dropdown本身是unorder list，因為他屬於ul.navbar-nav的其中之一個選項，所以外層必須由li包覆。形成巢狀。 12345678910111213141516&lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-expanded=&quot;false&quot;&gt;Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;One more separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; 容器二：navbar-formform的使用跟一般的form是相同的，特別注意的是加上.navbar-form讓form在navbar中可以垂直置中。 123456&lt;form class=&quot;navbar-form navbar-left&quot; role=&quot;search&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;Search&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt; 詳細form的使用方法會開另一篇來做記錄。 配合Snippet加快開發效率我使用的是 atom-bootstrap3 和 bootstrap-3-snippetset 這兩個package。 使用指令navbar建構出navbar雛形 ，包含brand、navbar-form。 要加上dropdwon時使用指令navbar-dropdown 各式各樣input : radiobs checkboxbs btn textareabs selectbs 參考資料：官方Doc - navbar ##Part 2: Form input type=&quot;text&quot;常跟label成對出現，並且用form-group裝起來。form-control讓input有百分之百的長度，form-group則讓form的空間看起來更合適。 1234&lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;recipient-name&quot; class=&quot;control-label&quot;&gt;Recipient:&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;recipient-name&quot;&gt;&lt;/div&gt; checkbox因為不需要佔有一整行的空間，所以也不需要加上.form-group調整表單間隔。 12345&lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; Remember me &lt;/label&gt; &lt;/div&gt; 同理radio也是一樣 123456&lt;div class=&quot;radio&quot;&gt; &lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;optionsRadios&quot; id=&quot;optionsRadios1&quot; value=&quot;option1&quot; checked&gt; Option one is this and that&amp;mdash;be sure to include why it's great &lt;/label&gt;&lt;/div&gt; select加上form-control可以讓選項延伸到該列的100% 1234567&lt;select class=&quot;form-control&quot;&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt;&lt;/select&gt; 需要文字說明的時候，也可以搭配form-group使用 123456&lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;disabledSelect&quot;&gt;Disabled select menu&lt;/label&gt; &lt;select id=&quot;disabledSelect&quot; class=&quot;form-control&quot;&gt; &lt;option&gt;Disabled select&lt;/option&gt; &lt;/select&gt;&lt;/div&gt; form的最後使用submit，使用class修飾外觀。 1&lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Send invitation&lt;/button&gt; 水平形式的form要達成水平的form可以用兩種方式，第一種是form-inline。缺點是不能自行設定label的長度。 1234567891011&lt;form class=&quot;form-inline&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputName2&quot;&gt;Name&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;exampleInputName2&quot; placeholder=&quot;Jane Doe&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;exampleInputEmail2&quot;&gt;Email&lt;/label&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;exampleInputEmail2&quot; placeholder=&quot;jane.doe@example.com&quot;&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Send invitation&lt;/button&gt;&lt;/form&gt; 另一種方式是使用Horizontal form便可以對label和input使用grid system。 12345678910111213141516171819202122232425262728&lt;form class=&quot;form-horizontal&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;inputEmail3&quot; class=&quot;col-sm-2 control-label&quot;&gt;Email&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;inputEmail3&quot; placeholder=&quot;Email&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;inputPassword3&quot; class=&quot;col-sm-2 control-label&quot;&gt;Password&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;inputPassword3&quot; placeholder=&quot;Password&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt; &lt;div class=&quot;checkbox&quot;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Sign in&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 這樣子基本的需求大概都可以cover到了。CSS class的查詢就直接看官方文件。 參考資料http://getbootstrap.com/css/#forms Part 3: JS LibaraysCarouselHTML分為三個部分： indecator : 下面用來代表目前頁面的小圈圈 wrapper : 投影片資料放這裡面 Controls : prev 和 next操作上需注意，投影片最外層需要加上data-ride=&quot;carousel&quot;套用carousel javascript plugin。12345&lt;div id=&quot;carousel-example-generic&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt; . . .&lt;/div&gt; indecator和controls需要跟外層的#carousel-example-generic&quot;一致。12345678910111213141516171819202122&lt;!-- Indicators --&gt; &lt;ol class=&quot;carousel-indicators&quot;&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt; &lt;/ol&gt;&lt;!-- Wrapper for slides --&gt; . . .&lt;!-- Controls --&gt; &lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt; &lt;/a&gt;&lt;/div&gt; modal1234&lt;!-- Button trigger modal --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-lg&quot; data-toggle=&quot;modal&quot; data-target=&quot;#myModal&quot;&gt; Launch demo modal&lt;/button&gt; data-toggle=&quot;modal&quot;代表這個button是用來觸發modal。data-target=&quot;#myModal&quot;則指定了要用id為myModal的元素來作為跳出的視窗。完整範例如下： 123456789101112131415161718&lt;!-- Modal --&gt;&lt;div class=&quot;modal fade&quot; id=&quot;myModal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot; aria-hidden=&quot;true&quot;&gt; &lt;div class=&quot;modal-dialog&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h4 class=&quot;modal-title&quot; id=&quot;myModalLabel&quot;&gt;Modal title&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; ... &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;Close&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;Save changes&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Collapse123456789&lt;a class=&quot;btn btn-primary&quot; data-toggle=&quot;collapse&quot; href=&quot;#collapseExample&quot; aria-expanded=&quot;false&quot; aria-controls=&quot;collapseExample&quot;&gt; Link with href&lt;/a&gt;&lt;div class=&quot;collapse&quot; id=&quot;collapseExample&quot;&gt; &lt;div class=&quot;well&quot;&gt; ... &lt;/div&gt;&lt;/div&gt; bootstrap使用data-attribute的方式來綁定js plugin，讓我們不需撰寫js檔也能使用javascript效果。每個tag中可以有一個data-開頭的屬性，根據使用的狀況不同data-後面接的會有所不同，Collapse用來展開或收起區域，所以後面接的是toggle字樣。(如果對toggle這個單字不太了解，可以玩玩看jQuery的toggle()方法。)data-toggle除了用在modal以外，也會使用在同樣有展開/收起特性的dropdown。來看看dropdown的button： 1&lt;button id=&quot;dLabel&quot; type=&quot;button&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; button中的data-toggle=&quot;dropdown&quot;代表這個button觸發的會是dropdown menu。 Collapse的第一個例子中的aria-controls=&quot;collapseExample&quot;輸入的「要跳出文字的id」。如此一來簡簡單單的完成了一個效果。 ScrollSpyScrollspy可以讓你滾動到哪個div時，就讓navbar選擇到相對應的button。使用方式除了需要在html中加上data-spy=&quot;scroll&quot;以外，css必須對body使用position: relative才能夠使用。css檔長這樣： 123body { position: relative;} html檔者這樣： 123456789&lt;body data-spy=&quot;scroll&quot; data-target=&quot;.navbar-example&quot;&gt; ... &lt;div class=&quot;navbar-example&quot;&gt; &lt;ul class=&quot;nav nav-tabs&quot; role=&quot;tablist&quot;&gt; ... &lt;/ul&gt; &lt;/div&gt; ...&lt;/body&gt; 如果不想使用data-attribute的方式，也可以透過javascript來使用。 1$('body').scrollspy({ target: '.navbar-example' }) jumbto12345&lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;col-sm-offset-2 col-sm-10&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Sign in&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; Cheetsheethttp://getbootstrap.com/css/#buttonshttp://getbootstrap.com/css/#tableshttp://getbootstrap.com/css/#helper-classeshttp://getbootstrap.com/components/#dropdownsbootstrap 3 不使用 pull-right 而使用dropdown-menu-righthttp://getbootstrap.com/components/#jumbotronhttp://getbootstrap.com/components/#thumbnailshttp://getbootstrap.com/javascript/#modalshttp://getbootstrap.com/components/#pagination 其他常見的data-attribute Hide an element to all devices except screen readers with .sr-only. All textual &lt;input&gt;, &lt;textarea&gt;, and &lt;select&gt; elements with .form-control are set to width: 100%; by default. Wrap labels and controls in .form-group for optimum spacing. 要使用sass開發的話有bootstrap for sass。 Tag role甚麼時候要用到role，根據官方文件的說法，當你所編寫的 tag 代表的意義已不符合本身的 default implicit roles，那你便需要再加上 role 屬性來說明其正確用途。而在W3C的官方文件中也載明了一個表格(見參考資料2 標題 Recommended ARIA usage by HTML language feature) 其中詳列的各 HTML Tag 的預設隱性 role，以及其可支援的其他 role (引用自 ARIA role 相關筆記 « Lobster 亂七八糟筆記 ) containerUse .container for a responsive fixed width container. 123&lt;div class=&quot;container&quot;&gt; ...&lt;/div&gt; Use .container-fluid for a full width container, spanning the entire width of your viewport. 123&lt;div class=&quot;container-fluid&quot;&gt; ...&lt;/div&gt;","link":"/2015/03/15/old%20posts/2015-03-15-bootstrap-note-preface-cheetsheet/"}],"tags":[{"name":"Harbor","slug":"Harbor","link":"/tags/Harbor/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"DevOps","slug":"DevOps","link":"/tags/DevOps/"},{"name":"DroneCI","slug":"DroneCI","link":"/tags/DroneCI/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/tags/Kubernetes/"},{"name":"Minikube","slug":"Minikube","link":"/tags/Minikube/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Flask","slug":"Flask","link":"/tags/Flask/"},{"name":"Unit Test","slug":"Unit-Test","link":"/tags/Unit-Test/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Open Source","slug":"Open-Source","link":"/tags/Open-Source/"},{"name":"Design Pattern","slug":"Design-Pattern","link":"/tags/Design-Pattern/"},{"name":"UML","slug":"UML","link":"/tags/UML/"},{"name":"Learning","slug":"Learning","link":"/tags/Learning/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Bootstrap","slug":"Bootstrap","link":"/tags/Bootstrap/"},{"name":"Sublime","slug":"Sublime","link":"/tags/Sublime/"},{"name":"Text Editor","slug":"Text-Editor","link":"/tags/Text-Editor/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"Meteor","slug":"Meteor","link":"/tags/Meteor/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"Ruby","slug":"Ruby","link":"/tags/Ruby/"},{"name":"Ruby Bit","slug":"Ruby-Bit","link":"/tags/Ruby-Bit/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"EDX Linux Foundation","slug":"EDX-Linux-Foundation","link":"/tags/EDX-Linux-Foundation/"},{"name":"Vim","slug":"Vim","link":"/tags/Vim/"},{"name":"Agile","slug":"Agile","link":"/tags/Agile/"},{"name":"Kanban","slug":"Kanban","link":"/tags/Kanban/"},{"name":"CI&#x2F;CD","slug":"CI-CD","link":"/tags/CI-CD/"},{"name":"Sinatra","slug":"Sinatra","link":"/tags/Sinatra/"},{"name":"Atom","slug":"Atom","link":"/tags/Atom/"},{"name":"Rails","slug":"Rails","link":"/tags/Rails/"},{"name":"PSD to HTML","slug":"PSD-to-HTML","link":"/tags/PSD-to-HTML/"},{"name":"Course","slug":"Course","link":"/tags/Course/"},{"name":"Typescript","slug":"Typescript","link":"/tags/Typescript/"},{"name":"SCSS","slug":"SCSS","link":"/tags/SCSS/"},{"name":"Golang","slug":"Golang","link":"/tags/Golang/"},{"name":"OSX","slug":"OSX","link":"/tags/OSX/"},{"name":"ActiveRecord","slug":"ActiveRecord","link":"/tags/ActiveRecord/"},{"name":"Cronjob","slug":"Cronjob","link":"/tags/Cronjob/"},{"name":"Redmine","slug":"Redmine","link":"/tags/Redmine/"},{"name":"Crawler","slug":"Crawler","link":"/tags/Crawler/"},{"name":"Metaprogramming","slug":"Metaprogramming","link":"/tags/Metaprogramming/"},{"name":"Elasticsearch","slug":"Elasticsearch","link":"/tags/Elasticsearch/"},{"name":"Fluentd","slug":"Fluentd","link":"/tags/Fluentd/"},{"name":"EFK","slug":"EFK","link":"/tags/EFK/"},{"name":"ELK","slug":"ELK","link":"/tags/ELK/"},{"name":"Devops","slug":"Devops","link":"/tags/Devops/"},{"name":"CORS","slug":"CORS","link":"/tags/CORS/"},{"name":"gem","slug":"gem","link":"/tags/gem/"},{"name":"Time","slug":"Time","link":"/tags/Time/"},{"name":"Web Foundation","slug":"Web-Foundation","link":"/tags/Web-Foundation/"},{"name":"Coockie","slug":"Coockie","link":"/tags/Coockie/"},{"name":"Session","slug":"Session","link":"/tags/Session/"},{"name":"Database","slug":"Database","link":"/tags/Database/"},{"name":"AWS","slug":"AWS","link":"/tags/AWS/"},{"name":"S3","slug":"S3","link":"/tags/S3/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"}],"categories":[{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"01 基礎教學","slug":"Python/01-基礎教學","link":"/categories/Python/01-%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8/"},{"name":"02 爬蟲教學","slug":"Python/02-爬蟲教學","link":"/categories/Python/02-%E7%88%AC%E8%9F%B2%E6%95%99%E5%AD%B8/"},{"name":"03 Flask 教學","slug":"Python/03-Flask-教學","link":"/categories/Python/03-Flask-%E6%95%99%E5%AD%B8/"},{"name":"04 Django 教學","slug":"Python/04-Django-教學","link":"/categories/Python/04-Django-%E6%95%99%E5%AD%B8/"},{"name":"05 資料庫教學","slug":"Python/05-資料庫教學","link":"/categories/Python/05-%E8%B3%87%E6%96%99%E5%BA%AB%E6%95%99%E5%AD%B8/"},{"name":"06 資料分析","slug":"Python/06-資料分析","link":"/categories/Python/06-%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90/"},{"name":"07 機器學習","slug":"Python/07-機器學習","link":"/categories/Python/07-%E6%A9%9F%E5%99%A8%E5%AD%B8%E7%BF%92/"}]}